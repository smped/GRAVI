```{r example, echo = FALSE, eval=TRUE}
## This module requires the following to be set during preparation
target <- "ER"
threads <- 6
```

```{r packages}
library(tidyverse)
library(glue)
library(pander)
library(BiocParallel)
library(yaml)
library(plyranges)
library(rtracklayer)
library(GenomeInfoDb)
library(Rsamtools)
library(cowplot)
library(ngsReports)
library(csaw)
library(edgeR)
library(scales)
library(quantro)
library(qsmooth)
library(magrittr)
library(statmod)
library(IHW)
library(ggrepel)
library(rlang)
library(UpSetR)
library(ggside)
library(InteractionSet)
library(reactable)
library(htmltools)
library(DT)
```

```{r remotes, results = 'hide'}
if (!"extraChIPs" %in% rownames(installed.packages()))
  BiocManager::install("steveped/extraChIPs")
stopifnot(library(extraChIPs, logical.return = TRUE))
source(here::here("workflow", "scripts", "autoload.R"))
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )
)
register(MulticoreParam(workers = threads))
str_sep_to_title <- function(x, sep = "_", replacement = " ", exclude = c()) {
  out <- x
  out[!x %in% exclude] <- out[!x %in% exclude] %>% 
    str_replace_all(sep, replacement) %>% 
    str_to_title()
  out
}
```

```{r load-config}
colours <- read_rds(
  here::here("output", "annotations", "colours.rds")
) %>% 
  lapply(unlist)
config <- read_yaml(
	here::here("config", "config.yml")
)
samples <- here::here("output", target, "qc_samples.tsv") %>% 
  read_tsv() %>% 
  dplyr::filter(
    qc == "pass",
    treat %in% names(colours$treat)
  ) %>% 
  mutate(treat = factor(treat, levels = names(colours$treat))) %>% 
  droplevels()
stopifnot(nrow(samples) > 0)
treat_levels <- levels(samples$treat)
treat_cols <- colours$treat[treat_levels]
rep_col <- setdiff(
  colnames(samples), c("sample", "treat", "target", "input", "label", "qc")
)
samples[[rep_col]] <- as.factor(samples[[rep_col]])
fdr_alpha <- config$comparisons$fdr
```

```{r set-paths}
bam_path <- here::here(config$paths$bam)
stopifnot(dir.exists(bam_path))
ext_path <- here::here("data", "external")
stopifnot(dir.exists(ext_path))
annotation_path <- here::here("output", "annotations")
stopifnot(dir.exists(annotation_path))
bw_path <- here::here(config$paths$bigwig, target)
stopifnot(dir.exists(bw_path))
out_path <- here::here("output", target)
if (!dir.exists(out_path)) dir.create(out_path)
```


```{r load-annotations}
sq <- file.path(annotation_path, "seqinfo.rds") %>% 
  read_rds()
blacklist <- here::here(annotation_path, "blacklist.bed.gz") %>%
  import.bed(seqinfo = sq) %>%
  sort()

bands_df <- config$genome$build %>% 
  str_to_lower() %>% 
  paste0(".cytobands") %>% 
  get()
stopifnot(
  colnames(bands_df) == c("chrom", "chromStart", "chromEnd", "name", "gieStain")
)

genes_gr <- file.path(annotation_path, "all_gr.rds") %>% 
  read_rds() %>% 
  .[["gene"]]
trans_models <- file.path(annotation_path, "trans_models.rds") %>% 
  read_rds() 

external_features <- GRanges(seqinfo = sq)
if (!is.null(config$external$features)) {
  external_features <- suppressWarnings(
    import.gff(here::here(config$external$features), genome = sq)
  )
  keep_cols <- !vapply(
    mcols(external_features), function(x) all(is.na(x)), logical(1)
  )
  mcols(external_features) <- mcols(external_features)[keep_cols]
}
has_features <- length(external_features) > 0
gene_regions <- file.path(annotation_path, "gene_regions.rds") %>% 
  read_rds()
regions <- vapply(gene_regions, function(x) unique(x$region), character(1))
any_detected <- gene_regions %>% 
  vapply(function(x) any(x$detected), logical(1)) %>% 
  any()

rna_path <- here::here(config$external$rnaseq)
rnaseq <- tibble(gene_id = character())
if (!is.null(rna_path)) {
  stopifnot(file.exists(rna_path))
  if (str_detect(rna_path, "tsv$")) rnaseq <- read_tsv(rna_path)
  if (str_detect(rna_path, "csv$")) rnaseq <- read_csv(rna_path)
  if (!"gene_id" %in% colnames(rnaseq)) stop("Supplied RNA-Seq data must contain the column 'gene_id'")
}
tx_col <- intersect(c("tx_id", "transcript_id"), colnames(rnaseq))
rna_gr_col <- ifelse(length(tx_col) > 0, "transcript_id", "gene_id")
rna_col <- c(tx_col, "gene_id")[[1]]
```


```{r load-hic}
hic <- GInteractions()
if (!is.null(config$external$hic)) {
  hic_path <- here::here(config$external$HiC)
  stopifnot(file.exists(hic_path))
  # hic <- autoload(hic_path) ## Needs to handle bedpe format
}
stopifnot(is(hic, "GInteractions"))
seqinfo(hic) <- sq
hic <- hic[!overlapsAny(hic, blacklist)]
```


# Data Preparation

```{r import-peaks}
consensus_peaks <- here::here("output", target, "consensus_peaks.bed") %>%
	import.bed(seqinfo = sq)
```


```{r bfl}
bfl <- bam_path %>%
  file.path(target, glue("{samples$sample}.bam")) %>%
  c(
    file.path(bam_path, "Input", glue("{unique(samples$input)}.bam"))
  ) %>% 
  BamFileList() %>%
  setNames(c(samples$sample, unique(samples$input)))
```


```{r get-bfl-summary}
ys <- 1000
bfl_summary <- bfl %>%
	bplapply(
		function(x) {
			yieldSize(x) <- ys
			sbp <- ScanBamParam(what = c("qwidth", "mapq"))
			open(x)
			vals <- scanBam(x, param = sbp)[[1]]
			close(x)
			list(as_tibble(vals))
		}
	) %>% 
	as_tibble() %>%
	pivot_longer(everything(), names_to = "sample") %>%
   	unnest(value) %>% 
	pivot_longer(
		cols = c("qwidth", "mapq"),
		names_to = "stat",
		values_to = "value"
	) %>%
	left_join(samples) %>% 
	mutate(
		across(
			all_of(c("target", "label", "treat")),
			str_replace_na, replacement = "Input"
		),
		treat = factor(treat, levels = c("Input", treat_levels)),
		label = fct_inorder(label)
	) %>% 
	split(f = .$stat)
anyDups <- bplapply(
	bfl,
	function(x) {
		sbp <- ScanBamParam(
			flag = scanBamFlag(isDuplicate = TRUE),
			which = GRanges(sq)[which.min(seqlengths(sq))],
			what = "qname"
			)
		length(scanBam(x, param = sbp)[[1]]$qname)  > 0
	}
) %>%
  unlist()
anyPE <- bplapply(
	bfl,
	function(x){
		yieldSize(x) <- ys
		open(x)
		flag <- scanBam(x, param=ScanBamParam(what="flag"))[[1]]$flag
		close(x)
		any(bamFlagTest(flag, "isPaired"))
	}
) %>% 
  unlist()
```


Taking thefirst `r comma(ys)` alignments, a brief inspection of the Bam Files revealed:

- Aligned read lengths ranged between `r glue_collapse(range(bfl_summary$qwidth$value), last = " and ")`. The median length was `r median(bfl_summary$qwidth$value)`.
- MAPQ scores of aligned reads ranged between `r glue_collapse(range(bfl_summary$mapq$value), last = " and ")`. The median score was `r median(bfl_summary$mapq$value)`.
- `r ifelse(any(anyDups), glue("Duplicate alignments were detected in ", glue_collapse(names(anyDups), sep = ", ", last = " & ")), "All bam files have been de-duplicated")`
- `r case_when(!any(anyPE) ~ "All alignments were single-end", all(anyPE) ~ "All Alignments were paired-end", TRUE ~ "Bam files appear to be a mixture of single-end and paired-end samples")`


## Sliding Window Counts

```{r window-counts}
macs2_merged_logs <- here::here(
	"data", "macs2", target, glue("{treat_levels}_merged_callpeak.log")
	) %>%
	importNgsLogs()
fl <- max(macs2_merged_logs$fragment_length)
rp <- readParam(
  pe = ifelse(any(anyPE), "both", "none"),
  dedup = any(anyDups),
  restrict = seqnames(sq),
  discard = blacklist,
)
win_step <- 10*(1 + fl %/% 30)
win_size <- 3*win_step
window_counts <- windowCounts(
  bam.files = bfl,
  spacing = win_step,
  width = win_size,
  ext = fl,
  filter = length(bfl) - 1,
  param = rp,
  BPPARAM = bpparam()
)
colData(window_counts) <- colData(window_counts) %>% 
  as_tibble(rownames = "sample") %>% 
  dplyr::select(all_of(c("sample", "bam.files", "totals", "ext", "rlen"))) %>% 
  left_join(samples, by = "sample") %>% 
  mutate(
    treat = fct_explicit_na(treat, "Input"), 
    target = str_replace_na(target, "Input")
  ) %>% 
  as.data.frame() %>% 
  column_to_rownames("sample") %>% 
  DataFrame()
window_counts <- sortSeqlevels(window_counts)
seqinfo(window_counts) <- sq
```

Using the estimated fragment length of `r fl` a set of genomic sliding windows were defined using a window size of `r win_size`bp, sliding in increments of `r win_step`bp.
With the exclusion of black-listed regions, all alignments within each window were counted for each `r target`-associated sample, and all relevant input samples
Any windows with fewer than `r length(bfl) - 1` alignments across all samples were discarded, leaving a total of `r comma(nrow(window_counts))` sliding windows, covering the majority of the reference genome.

```{r filtered-counts}
filtered_counts <- dualFilter(
  x = window_counts[, samples$sample],
  bg = window_counts[, samples$input],
  ref = consensus_peaks,
  keep.totals = TRUE,
  q = config$comparisons$filter_q
)
colData(filtered_counts) <- droplevels(colData(filtered_counts))
n_max <- min(5e4, nrow(filtered_counts))
```

```{r tab-filtered-windows}
list(
  `Genomic Windows` = window_counts,
  `Retained Windows` = filtered_counts,
  `Consensus Peaks` = consensus_peaks
) %>% 
  lapply(granges) %>% 
  lapply(
    function(x) {
      tibble(
        N = comma(length(x)),
        `Total Width (kb)` = comma(sum(width(reduce(x))) / 1e3),
        `Median Width (bp)` = median(width(x))
      )
    }
  ) %>% 
  lapply(list) %>% 
  as_tibble() %>% 
  pivot_longer(everything(), names_to = "Dataset") %>% 
  unnest(everything()) %>% 
  pander(
    justify = "lrrr",
    caption = paste(
      "A dual filtering strategy was used based on retaining", 
      percent(config$comparisons$filter_q, 0.1), 
      "of genomic windows overlapping the consensus peaks identified by ", 
      "`macs2 callpeak` on merged samples. This approach combined both ", 
      "1) expression percentiles, and 2) signal strength in relation to the input sample.",
      "The complete set of sliding windows covered the majority of the genome,",
      "whilst those retained after filtering were focussed on strong binding",
      "signal. Consensus peaks were as identified by `macs2 callpeak` in a", 
      "previous step of the workflow.",
      "Importantly, consensus peaks are non-overlapping, whilst the other two",
      "datasets are derived from overlapping sliding windows.",
      "This strategy of filtering the set of initial sliding windows retained",
      percent(
        1 - sum(width(setdiff(consensus_peaks, rowRanges(filtered_counts)))) / sum(width(consensus_peaks))
      ), 
      "of the genomic regions covered by consensus peaks, with", 
      percent(
        sum(width(setdiff(rowRanges(filtered_counts), consensus_peaks))) / sum(width(reduce(granges(filtered_counts)))))
      , 
      "of the retained windows being outside genomic regions covered by consensus peaks.",
      ifelse(
        n_max == 5e4, 
        "For subsequent density and RLE plots, a subsample of 50,000 genomic regions will be used for speed.", 
        ""
      )
    )
  )
```



## Normalisation {.tabset}

```{r qtest, results='asis'}
qtest <- quantro(
  assay(filtered_counts, "logCPM"),
  groupFactor = filtered_counts$treat
)
pander(
  anova(qtest), 
  caption = paste(
    "*Results from qtest suggesting that the two treatment groups are drawn from",
    ifelse(
      qtest@anova$`Pr(>F)`[[1]] < 0.05,
      "different distributions.*",
      "the same distribution.*"
    )
  )
)
```


```{r add-qsmooth}
qs <-qsmooth(
  assay(filtered_counts, "logCPM"), group_factor = filtered_counts$treat
)
assay(filtered_counts, "qsmooth") <- qsmoothData(qs)
```

Smooth-Quantile normalisation was performed, grouping by treatment


### QSmooth Weights

```{r plot-qs-weights, fig.height = 6, fig.cap = "*Quantile-specific weights used by the Smooth-Quantile normalisation. Low weights indicate expression quantiles which appear to be more specific within a group, whilst higher weights indicate similarity between groups.*"}
qsmoothPlotWeights(qs)
```


### Density Plot: Sliding Windows

```{r plot-density-windows, fig.cap = "*Density plot for all windows prior to selection of those more likely to contain true signal.*"}
plotAssayDensities(
  window_counts, trans = "log1p", n_max = n_max, colour = "treat",
  linetype = "target"
) +
  scale_colour_manual(values = treat_cols) + 
  labs(
    x = "log(counts + 1)", y = "Density", colour = "Treat", linetype = "Target"
  )
```

### Density Plot: logCPM

```{r plot-logcpm-densities, fig.cap = "*logCPM distributions for all retained windows prior to smooth quantile normalisation*"}
filtered_counts %>% 
  plotAssayDensities("logCPM", colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_cols[treat_levels]) +
  labs(colour = "Treat")
```

### Density Plot: Normalised

```{r plot-qsmooth-densities, fig.cap = "*SQ-normalised logCPM distributions for all retained windows.*"}
filtered_counts %>% 
  plotAssayDensities("qsmooth", colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_cols[treat_levels]) +
  labs(
    x = "Normalised logCPM", colour = "Treat"
  )
```

### RLE: logCPM

```{r plot-rle-logcpm, fig.height=6, fig.cap = glue("*RLE plot showing logCPM values prior to normalisation. RLE values were calculated within each treatment group to account for the potentially different binding dynamics of {target}.*")}
filtered_counts %>% 
  plotAssayRle(
  "logCPM", fill = "treat", rle_group = "treat", x_col = "label", n_max = n_max
) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_cols[treat_levels]) +
  labs(x = "Sample", fill = "Treat")
```


### RLE: Normalised

```{r plot-rle-normalised, fig.height=6, fig.cap = glue("*RLE plot showing logCPM values after Smooth Quantile normalisation. RLE values were calculated within each treatment group to account for the potentially different binding dynamics of {target}.*")}
filtered_counts %>% 
  plotAssayRle(
  "qsmooth", fill = "treat", rle_group = "treat", x_col = "label", n_max = n_max
) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_cols[treat_levels]) +
  labs(x = "Sample", fill = "Treat")
```


### PCA

```{r plot-pca, fig.height = 5, fig.cap = "*PCA plots for A) logCPM and B) SQ-Normalised logCPM*"}
a <- plotAssayPCA(filtered_counts, "logCPM", colour = "treat", label = "label") +
  scale_colour_manual(values = treat_cols[treat_levels])
b <- plotAssayPCA(filtered_counts, "qsmooth", colour = "treat", label = "label") +
  scale_colour_manual(values = treat_cols[treat_levels]) 
plot_grid(
  a + theme(legend.position = "none"), b + theme(legend.position = "none"), 
  get_legend(b + labs(colour = "Treat")), rel_widths = c(1, 1, 0.2), 
  nrow = 1, labels = c("A", "B")
  )
```


# Differential Binding Analysis

## Primary Analysis {.tabset}

```{r fit-model}
X <- model.matrix(~treat, data = colData(filtered_counts)) %>%
  set_colnames(str_remove(colnames(.), "treat"))
colData(filtered_counts)$design <- X
paired_cors <- block <- NULL
if (config$comparisons$paired) {
  block <- colData(filtered_counts)[[rep_col]]
  set.seed(1e6)
  ind <- sample.int(nrow(filtered_counts), n_max, replace = FALSE)
  paired_cors <- duplicateCorrelation(
    object = assay(filtered_counts, "qsmooth")[ind, ],
    design = X,
    block = block
  )$consensus.correlation
}
fc <- ifelse(is.null(config$comparisons$fc), 1, config$comparisons$fc)
fit <- assay(filtered_counts, "qsmooth") %>%
  lmFit(design = X, block = block, correlation = paired_cors) %>% 
  treat(fc = fc, trend = TRUE, robust = FALSE)
res_cols <- c("logFC", "AveExpr", "t", "P.Value", "fdr")
rowData(filtered_counts) <- rowData(filtered_counts) %>% 
  .[!colnames(.) %in% res_cols] %>% 
  cbind(
    fit %>% 
      topTable(sort.by = "none", number = Inf) %>% 
      DataFrame() %>% 
      setNames(res_cols)
  )
```


After SQ-normalisation of logCPM values, the `limma-trend` method was applied to all retained windows.
A simple linear model was fitted taking `r treat_levels[[1]]` as the baseline and estimating the effects of `r treat_levels[[2]]` on `r target` binding within each sliding window, incorporating a trended prior-variance.
After fitting, hypothesis testing was performed testing:

$$
H_0: -\lambda < \mu < \lambda
$$
against
$$
H_A: |\mu| > \lambda
$$
where $\mu$ represents the true mean change in `r target` binding.
The value $\lambda =$ `r round(log2(fc), 2)` was chosen as this corresponds to a `r percent(fc - 1)` change in detected signal on the log~2~ scale.
This is the `treat` methodology as developed by McCarthy & Smyth, and p-values were obtained for each initial window, before merging adjoining windows.


```{r merged-results}
merged_results <- mergeByCol(
  filtered_counts, col = "AveExpr", merge_within = 2 * win_step
) %>% 
  mutate(
    overlaps_ref = overlapsAny(., consensus_peaks),
    direction = case_when(
      n_up == 0 & n_down == 0 ~ "Unchanged",
      n_up > n_down ~ "Up",
      n_down > n_up ~ "Down",
      n_up == n_down ~ "Ambiguous"
    ) %>% 
      factor(levels = c("Up", "Down", "Ambiguous", "Unchanged")) %>% 
      droplevels()
  ) 
```

After selection of the `r comma(nrow(filtered_counts))` sliding windows (`r win_size`bp), these were merged into `r comma(length(merged_results))` genomic regions with size ranging from `r glue_collapse(range(width(merged_results)), last = " to ")`bp, with the median width being `r median(width(merged_results))`bp.
Representative estimates of differential binding (i.e. logFC) were taken from the sliding window with the *highest average signal* across all samples, within each set of windows to be merged.
Similarly, p-values from the above tests were also selected from the same sliding window as representative of the merged region.
The number of windows showing increased or decreased binding within each merged region were also included, by counting those within each set of windows with p-values lower than the selected window.
FDR-adjustment was performed with `r comma(sum(merged_results$P.Value_fdr < fdr_alpha))` regions (`r percent(mean(merged_results$P.Value_fdr < fdr_alpha), accuracy = 0.1)`) showing significance, based on an FDR-adjusted p-value alone.

### Merged Windows

```{r plot-merged-size, fig.height=7, fig.cap = "*Comparison of signal intensity (logCPM) and merged window size (kb) for windows which overlap a macs2 consensus peak and those which don't. A mall amount of jitter has been added to the y-axis in the lower-left panel.*"}
merged_results %>% 
  mutate(kb = width / 1e3) %>% 
  as_tibble() %>% 
  ggplot(aes(AveExpr, kb)) +
  geom_jitter(
    aes(colour = overlaps_ref), 
    alpha = 0.6, width = 0, height = 0.04
  ) +
  geom_xsideboxplot(
    aes(y = overlaps_ref, fill = overlaps_ref), orientation = "y"
  ) +
  geom_ysideboxplot(
    aes(x = overlaps_ref, fill = overlaps_ref), orientation = "x"
  ) +
  scale_xsidey_discrete() +
  scale_ysidex_discrete() +
  scale_colour_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1") +
  labs(
    x = "logCPM", y = "Merged Window Size (kb)",
    fill = "Macs2 Peak", colour = "Macs2 Peak"
  ) +
  theme(
    axis.title.x = element_text(hjust = 0.45),
    axis.title.y = element_text(hjust = 0.4),
    ggside.panel.scale.x = 0.3,
    ggside.panel.scale.y = 0.25,
    legend.position = c(0.9, 0.9)
  )
```

### Mean-Variance Relationship

```{r plot-mean-var, fig.height = 6, fig.cap = "Mean-variance for all retained windows. Black dots indicate the estimated standard deviation for each window as a function of signal. Red dots are the shrunken estimates after applying limma-trend, whilst the loess curve through the initial estimates is shown in blue."}
tibble(A = fit$Amean, sigma = fit$sigma, s2.post = fit$s2.post) %>% 
  sample_n(n_max) %>%
  ggplot(aes(A, sigma)) +
  geom_point(size = 1, alpha = 0.5) +
  geom_point(aes(y = sqrt(s2.post)), col = "red", size = 1, alpha = 0.7) +
  geom_smooth(se = FALSE, method = "loess") +
  labs(
    x = "logCPM", y = expression(hat(sigma))
  ) +
  theme(axis.title.y = element_text(angle = 0, vjust = 0.5))
```


## Independent Hypothesis Weighting {.tabset}

```{r set-ihw}
ihw_opts <- c("regions", "features", "targets")
ihw_method <- c(
  intersect(str_to_lower(config$comparisons$ihw), ihw_opts), "none"
)
ihw_method <- ihw_method[[1]]
fdr_column <- "P.Value_fdr" # The default should ihw not proceed
## Add status (direction) for the ihw = "none" possibility
merged_results <- merged_results %>% 
  mutate(
    status = case_when(
      !!sym(fdr_column) < fdr_alpha ~ as.character(direction),
      !!sym(fdr_column) >= fdr_alpha ~ "Unchanged"
    ) %>% 
      factor(levels = c(levels(direction), "Unchanged")) %>% 
      droplevels()
  )
```

`r ifelse(ihw_method == "none", "No independent Hypothesis Weighting was specified", "")`

```{r ihw-regions, eval = ihw_method == "regions", echo=FALSE, child = here::here('workflow/modules/ihw_regions.Rmd')}
```

```{r ihw-features, eval = ihw_method == "features", echo=FALSE, child = here::here('workflow/modules/ihw_features.Rmd')}
```

```{r ihw-targets, eval = ihw_method == "targets", echo=FALSE, child = here::here('workflow/modules/ihw_targets.Rmd')}
```

## Mapping Windows

```{r map-to-regions}
merged_results$region <- gene_regions %>% 
  lapply(function(x) overlapsProp(merged_results, x)) %>% 
  as_tibble() %>% 
  mutate(
    range = as.character(merged_results) %>% fct_inorder()
  ) %>% 
  pivot_longer(
    cols = all_of(names(gene_regions)),
    names_to = "region", values_to = "prop"
  ) %>% 
  arrange(desc(prop)) %>% 
  distinct(range, .keep_all = TRUE) %>% 
  arrange(range) %>% 
  mutate(
    region = regions[region] %>% 
      factor(levels = regions) %>% 
      fct_relabel(str_sep_to_title)
  ) %>% 
  pull("region")
if (has_features) {
  merged_results$feature <- external_features %>% 
    c(
      setdiff(GRanges(sq), external_features) %>% 
        mutate(feature = "no_feature")
    ) %>% 
    splitAsList(.$feature) %>% 
    lapply(function(x) overlapsProp(merged_results, x)) %>% 
    as_tibble() %>% 
    mutate(
      range = as.character(merged_results) %>% fct_inorder()
    ) %>% 
    pivot_longer(
      cols = all_of(c("no_feature", unique(external_features$feature))),
      names_to = "feature", values_to = "prop"
    ) %>% 
    arrange(desc(prop)) %>% 
    distinct(range, .keep_all = TRUE) %>% 
    arrange(range) %>% 
    mutate(
      feature = factor(feature, levels = names(colours$features)) %>% 
             fct_relabel(str_sep_to_title)
    ) %>% 
    pull("feature")
}
```

Merged windows were first mapped to the gene-centric region with the largest overlap.
`r ifelse(has_features, "Windows were then mapped to the external features provided in the same manner", "")`.

```{r map-to-genes}
merged_results <- merged_results %>%
  mapByFeature(
    genes = genes_gr, 
    prom = GRangesList(
      ## Add any external features which appear to be promoters
      ifelse(
        "feature" %in% colnames(mcols(external_features)), 
        list(granges(subset(external_features, str_detect(feature, "[Pp]rom")))), 
        list(GRanges())
      )[[1]], 
      granges(gene_regions$promoters)) %>% 
      unlist() %>% 
      reduce(),
    enh = ifelse(
      "feature" %in% colnames(mcols(external_features)), 
      list(granges(subset(external_features, str_detect(feature, "[Ee]nhanc")))), 
      list(GRanges())
    )[[1]],
    gi = hic
  ) 
merged_results$detected <- merged_results %>% 
  mutate(range = as.character(.)) %>% 
  select(range, gene_id) %>% 
  mcols() %>% 
  as_tibble() %>%
  mutate(id = seq_along(range), gene_id = vctrs::vec_proxy(gene_id)) %>% 
  unnest(everything()) %>% 
  dplyr::filter(gene_id %in% rnaseq$gene_id) %>% 
  distinct(id, gene_id) %>% 
  left_join(
    tibble(gene_id = genes_gr$gene_id, gene_name = genes_gr$gene_name)
    ) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  complete(id = seq_along(merged_results)) %>%
  arrange(id) %>% 
  .[["gene_name"]] %>% 
  as("CharacterList") 
```

In addition to statistical analysis, the regions produced by merging windows were mapped to all annotated genes.
Promoters were the union of all regions defined based on transcript-level annotation, and any external features which were defined as promoters.
Enhancers were any regions defined in `r basename(config$external$features)` as enhancers.
`r ifelse(length(hic) > 0, glue("The set of {length(hic)} HiC-interactions were also used to define long-range interactions."), "")`

These features were used to map merged windows to features using the process defined in the function `mapByFeature()`:

1. Ranges *overlapping a promoter* are assigned to genes for that specific promoter
2. Ranges *overlapping an enhancer* are assigned to all genes within 100kb
3. Ranges *overlapping a long-range interaction* are assigned to all genes connected by the interaction
4. Ranges with *no gene assignment from the previous steps* are assigned to all genes within 100kb

Notably, genes are only passed to step 4 if no gene assignment has been made in steps 1, 2 or 3.
For visualisation purposes, only genes which were considered as detected in any provided RNA-Seq data will be shown as the mapping targets.

# Results 

## Summary Plots {.tabset}

```{r labeller}
facet_labeller <- as_labeller(
  c(
    c(
      `TRUE` = "Consensus Peak",
      `FALSE` = "No Consensus Peak"
    ),
    structure(treat_levels, names = treat_levels),
    c(
      Up = glue("Increased {target} Binding"),
      Down = glue("Decreased {target} Binding")
    ),
    c(
      AveExpr = "logCPM", logFC = "logFC"
    )
  )
)
```

```{r make-heatmaps}
profile_width <- 5e3
n_bins <- 100
bwfl <- file.path(bw_path, glue("{treat_levels}_merged_treat_pileup.bw")) %>% 
  BigWigFileList() %>% 
  setNames(treat_levels) 
sig_ranges <- merged_results %>% 
  filter(!!sym(fdr_column) < fdr_alpha) %>% 
  split(f = .$direction) %>% 
  .[vapply(., length, integer(1)) > 0]
sig_profiles <- bplapply(
  sig_ranges, 
  function(x) getProfileData(
    bwfl, x, upstream = profile_width / 2, bins = n_bins
  ),
  BPPARAM = MulticoreParam(length(sig_ranges))
)
profile_heatmaps <- sig_profiles %>% 
  lapply(
    plotProfileHeatmap,
    profileCol = "profile_data", 
    facetY = "overlaps_ref",
    colour = "name",
    linetype = "overlaps_ref",
    xLab = "Distance from Centre (bp)",
    fillLab = "CPM",
    labeller = as_labeller(
      treat_levels %>% 
        setNames(treat_levels) %>% 
        c(
          `TRUE` = "Consensus\nPeak",
          `FALSE` = "No\nConsensus\nPeak"
        )
    )
  ) 
fill_range <- profile_heatmaps %>% 
  lapply(function(x) x$data[,"score"]) %>% 
  unlist() %>%
  range()
sidey_range <- profile_heatmaps %>% 
  lapply(function(x) x$layers[[3]]$data$y) %>% 
  unlist() %>% 
  range()
profile_heatmaps <- profile_heatmaps %>% 
  lapply(function(x) {
    x + 
      scale_fill_viridis_c(
        option = "inferno", direction = -1, limits = fill_range
      ) +
      scale_xsidey_continuous(limits = sidey_range) +
      scale_colour_manual(values = treat_cols[treat_levels]) +
      scale_linetype_manual(values = c("TRUE" = 1, "FALSE" = 2)) +
      labs(
        x = "Distance from Centre (bp)",
        fill = "CPM", linetype = "Consensus\nPeak\nOverlap",
        colour = "Treat"
      ) +
      theme(
        strip.text.y = element_text(angle = 0)
      )
  })
```


### MA Plot

```{r plot-ma, fig.cap = glue("*MA plot showing the status of each window under consideration. The two most extreme regions are labelled by region and any associated genes, whilst the overall pattern of association between signal level (logCPM) and changed signal (logFC) is shown as the blue curve. Windows are plotted in separate panels based on those which overlap a `macs2` consensus peak.*")}
merged_results %>% 
  as_tibble() %>% 
  arrange(range) %>% 
  ggplot(aes(AveExpr, logFC)) +
  geom_point(aes(colour = status), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, bs = "cs")) +
  geom_hline(yintercept = 0) +
  geom_label_repel(
    aes(y = 1.1*logFC, label = annot, colour = status),
    data= . %>%
      dplyr::filter(logFC == max(logFC) | logFC == min(logFC)) %>%
      mutate(
        detected = detected %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 40),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.2),
    size = 3,
    show.legend = FALSE
  ) +
  facet_grid(
    .~overlaps_ref, 
    scales = "free_x", space = "free_x",
    labeller = facet_labeller
  ) +
  scale_colour_manual(
    values = colours$direction %>% 
      .[names(.) != "undetected"] %>% 
      setNames(str_to_title(names(.)))
  ) +
  labs(
    x = "Ave Signal (logCPM)",
    colour = "Status"
  ) 
```


### Volcano Plot

```{r plot-volcano, fig.cap = glue("*Volcano plot showing regions with evidence of differential {target} binding. Regions overlapping a consensus peak are coloured separately to thos which are not. The two most significant regions are labelled along with any genes these regions are mapped to.*")}
merged_results %>% 
  as_tibble() %>% 
  ggplot(aes(logFC, -log10(P.Value))) +
  geom_point(aes(colour = status), alpha = 0.6) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data= . %>%
      arrange(sign(logFC)*log10(P.Value)) %>% 
      dplyr::slice(1:2) %>% 
      mutate(
        detected = detected %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 40),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.2),
    size = 3,
    show.legend = FALSE
  ) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data= . %>%
      arrange(-sign(logFC)*log10(P.Value)) %>% 
      dplyr::slice(1:2) %>% 
      mutate(
        detected = detected %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 40),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.2),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(
    values =  colours$direction %>% 
      .[names(.) != "undetected"] %>% 
      setNames(str_to_title(names(.)))
  ) +
  labs(
    x = "logFC",
    y = expression(paste(-log[10], "p")),
    colour = "Status"
  )
```

`r ifelse("Up" %in% names(profile_heatmaps), "### Heatmaps: Up\n", "")`

```{r plot-up-heatmap, eval = "Up" %in% names(profile_heatmaps), echo = "Up" %in% names(profile_heatmaps), fig.cap = glue("*Heatmap and histogram for all regions considered to show evidence of increased {target} binding in the {treat_levels[[2]]} group, separated by those which did or did not overlap a consensus peak. A total of {comma(length(sig_ranges[['Up']]))} regions were in this group.*"), fig.height = min(16, length(sig_ranges$Up)/1.5e3 + 6)}
profile_heatmaps$Up
```


`r ifelse("Down" %in% names(profile_heatmaps), "### Heatmaps: Down\n", "")`

```{r plot-down-heatmap, eval = "Down" %in% names(profile_heatmaps), echo = "Down" %in% names(profile_heatmaps), fig.cap = glue("*Heatmap and histogram for all regions considered to show evidence of decreased {target} binding in the {treat_levels[[2]]} group, separated by those which did or did not overlap a consensus peak. A total of {comma(length(sig_ranges[['Down']]))} regions were in this group.*"), fig.height = min(16, length(sig_ranges$Down)/1.5e3 + 6)}
profile_heatmaps$Down
```

### Results By Chromosome

```{r plot-res-by-chromosome, fig.cap = "*Results for differential binding separated by chromosome*"}
merged_results %>% 
  select(overlaps_ref, status) %>% 
  as.data.frame() %>% 
  mutate(status = str_remove(as.character(status), " \\+ Ref Peak")) %>% 
  ggplot(aes(seqnames, fill = status, alpha = overlaps_ref)) +
  geom_bar() +
  facet_grid(status~., scales = "free_y") +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  scale_fill_manual(
    values =  colours$direction %>% 
      .[names(.) != "undetected"] %>% 
      setNames(str_to_title(names(.)))
  ) +
  scale_alpha_manual(values = c(0.5, 1)) +
  labs(
    x = "Chromosome", y = "Number of Windows", 
    fill = "Status", alpha = "Macs2 Peak"
  )
```

### Signal By Region

```{r boxplot-regions, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each genomic region.*"}
merged_results %>% 
  select(AveExpr, logFC, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    ),
  ) %>% 
  pivot_longer(cols = c("AveExpr", "logFC")) %>% 
  ggplot(aes(x, value, fill = region)) +
  geom_boxplot() +
  facet_grid(
    name~., scales = "free", labeller = facet_labeller, switch = "y"
  ) +
  scale_fill_manual(
    values = colours$regions %>% 
      setNames(regions[names(.)]) 
  ) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

### Differential Binding By Region

```{r plot-db-regions, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} binding across all genomic regions.*")}
merged_results %>% 
  select(status, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    )
  ) %>% 
  group_by(x, region, status) %>% 
  tally() %>% 
  arrange(region, desc(status)) %>% 
  mutate(y = cumsum(n)) %>% 
  ggplot(
    aes(x, n, fill = status)
  ) +
  geom_col() +
  geom_label(
    aes(y = y - 0.5*n, label = comma(n, 1), colour = status),
    data = . %>% dplyr::filter(n > 0.2*max(y)),
    fill = "white", alpha = 0.8,
    show.legend = FALSE
  ) +
  geom_text(
    aes(y = y1, label = comma(y)),
    data = . %>% 
      dplyr::filter(y == max(y)) %>% 
      ungroup() %>% 
      mutate(y1 = y + 0.03*max(y))
  ) +
  scale_y_continuous(expand = expansion(c(0, 0.5)), labels = comma) +
  scale_fill_manual(
    values = colours$direction %>% 
      setNames(str_to_title(names(.))) %>% 
      .[names(.) != "Undetected"]
  ) +
  scale_colour_manual(
    values = colours$direction %>% 
      setNames(str_to_title(names(.))) %>% 
      .[names(.) != "Undetected"]
  ) +
  labs(x = "Region", y = "Merged Windows", fill = "Status")
```

`r ifelse(has_features, "### Signal By Feature", "")`

```{r boxplot-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each external features.*"}
merged_results %>% 
  select(AveExpr, logFC, feature) %>% 
  as_tibble() %>% 
  pivot_longer(cols = c("AveExpr", "logFC")) %>% 
  ggplot(aes(feature, value, fill = feature)) +
  geom_boxplot() +
  facet_grid(
    name~., scales = "free", labeller = facet_labeller, switch = "y"
  ) +
  scale_fill_manual(
    values = colours$features %>% setNames(str_sep_to_title(names(.)))
  ) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r ifelse(has_features, "### Differential Binding By Feature", "")`

```{r plot-db-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} binding across all external features.*")}
merged_results %>% 
  select(status, feature) %>% 
  as_tibble() %>% 
  group_by(feature, status) %>% 
  tally() %>% 
  arrange(feature, desc(status)) %>% 
  mutate(y = cumsum(n)) %>% 
  ggplot(
    aes(feature, n, fill = status)
  ) +
  geom_col() +
  geom_label(
    aes(y = y - 0.5*n, label = comma(n, 1), colour = status),
    data = . %>% dplyr::filter(n > 0.2*max(y)),
    fill = "white", alpha = 0.8,
    show.legend = FALSE
  ) +
  geom_text(
    aes(y = y1, label = comma(y)),
    data = . %>% 
      dplyr::filter(y == max(y)) %>% 
      ungroup() %>% 
      mutate(y1 = y + 0.03*max(y))
  ) +
  scale_y_continuous(expand = expansion(c(0, 0.5)), labels = comma) +
  scale_fill_manual(
    values = colours$direction %>% 
      setNames(str_to_title(names(.))) %>% 
      .[names(.) != "Undetected"]
  ) +
  scale_colour_manual(
    values = colours$direction %>% 
      setNames(str_to_title(names(.))) %>% 
      .[names(.) != "Undetected"]
  ) +
  labs(x = "Feature", y = "Merged Windows", fill = "Status")
```


## Result Tables {.tabset}

```{r tbl-funs}
up_col <- function(x) {
  rgb(
    colorRamp(c("#ffffff", colours$direction[["up"]]))(x), maxColorValue = 255
  )
}
down_col <- function(x) {
  rgb(
    colorRamp(c("#ffffff", colours$direction[["down"]]))(x), maxColorValue = 255
  )
}
unch_col <- function(x) {
  rgb(
    colorRamp(c("#ffffff", colours$direction[["unchanged"]]))(x), 
    maxColorValue = 255
  )
}
lfc_col <- function(x){
  rgb(
    colorRamp(c(colours$direction[["down"]], "#ffffff", colours$direction[["up"]]))(x), 
    maxColorValue = 255
  )
}
expr_col <- function(x){
  rgb(colorRamp(hcl.colors(9, "TealRose"))(x), maxColorValue = 255)
}
bar_style <- function(width = 1, fill = "#e6e6e6", height = "75%", align = c("left", "right"), color = NULL) {
  align <- match.arg(align)
  if (align == "left") {
    position <- paste0(width * 100, "%")
    image <- sprintf("linear-gradient(90deg, %1$s %2$s, transparent %2$s)", fill, position)
  } else {
    position <- paste0(100 - width * 100, "%")
    image <- sprintf("linear-gradient(90deg, transparent %1$s, %2$s %1$s)", position, fill)
  }
  list(
    backgroundImage = image,
    backgroundSize = paste("100%", height),
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center",
    color = color
  )
}
with_tooltip <- function(value, width = 30) {
  tags$span(title = value, str_trunc(value, width))
}
```


### Overall Results

```{r tab-overall}
df <- merged_results %>% 
  as_tibble() %>% 
  group_by(overlaps_ref, status) %>% 
  summarise(n = dplyr::n(), .groups = "drop_last") %>% 
  mutate(Total = sum(n)) %>% 
  ungroup() %>% 
  complete(status, fill = list(n = 0)) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  mutate(
    overlaps_ref = unlist(facet_labeller(overlaps_ref)) %>% 
      str_replace_na("All Windows"),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  dplyr::rename(`Macs2 Peak` = overlaps_ref) 
cp <- glue(
  "Overall results for changed {target} binding after {treat_levels[[2]]} ",
  "treament, broken down by whether each merged window overlaps a `macs2`-",
  "derived consensus peak."
)
tbl <- df %>%
  reactable(
    columns = list(
      `Macs2 Peak` = colDef(footer = htmltools::tags$b("Total")),
      Up = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- up_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Down = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- down_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Unchanged = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / length(merged_results)#sum(df$Unchanged)
          color <- unch_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      `% Changed` = colDef(
        cell = function(value) percent(value, 0.1),
        style = function(value) bar_style(width = value, fill = "#B3B3B3"),
        align = "left",
        footer = htmltools::tags$b(
          percent(sum(1 - sum(df$Unchanged) / sum(df$Total)), 0.1)
        )
      ),
      Total = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          bar_style(width = value / length(merged_results), fill = "#B3B3B3")
        },
        align = "left",
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

### Summary By Region

```{r tab-res-by-region}
df <- merged_results %>% 
  select(
    overlaps_ref, status, all_of(fdr_column), region
  ) %>% 
  as_tibble() %>% 
  group_by(region, status) %>% 
  tally() %>% 
  complete(status, fill = list(n = 0)) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  ungroup() %>% 
  mutate(
    Total = Up + Down + Unchanged,
    `% Of All Windows` = Total / length(merged_results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(region) %>% 
  dplyr::select(
    Region = region,
    any_of(str_to_title(names(colours$direction))),
    `% Changed`, Total, `% Of All Windows`
  )
cp <- glue(
      "Overall results for changed {target} binding after {treat_levels[[2]]} ",
      "treament, broken down by which genomic region contains the largest ", 
      "overlap with each merged window."
    )
tbl <- df %>%
  reactable(
    columns = list(
      Region = colDef(footer = htmltools::tags$b("Total")),
      Up = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- up_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Down = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- down_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Unchanged = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / length(merged_results)#sum(df$Unchanged)
          color <- unch_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      `% Changed` = colDef(
        cell = function(value) percent(value, 0.1),
        footer = htmltools::tags$b(
          percent(sum(1 - sum(df$Unchanged) / sum(df$Total)), 0.1)
        )
      ),
      Total = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          bar_style(width = value / length(merged_results), fill = "#B3B3B3")
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      `% Of All Windows` = colDef(
        cell = function(value) percent(value, 0.1),
        footer = htmltools::tags$b("100%")
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(has_features, "### Summary By Feature", "")`

```{r tab-res-by-feature, echo = has_features, eval = has_features}
df <- merged_results %>% 
  select(
    overlaps_ref, status, all_of(fdr_column), feature
  ) %>% 
  as_tibble() %>% 
  group_by(feature, status) %>% 
  tally() %>% 
  complete(status, fill = list(n = 0)) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  ungroup() %>% 
  mutate(
    Total = Up + Down + Unchanged,
    `% Of All Windows` = Total / length(merged_results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(feature) %>% 
  dplyr::select(
    Feature = feature,
    any_of(str_to_title(names(colours$direction))),
    `% Changed`, Total, `% Of All Windows`
  )
cp <- glue(
  "Overall results for changed {target} binding after {treat_levels[[2]]} ",
  "treament, broken down by which external feature contains the largest ", 
  "overlap with each merged window."
)
tbl <- df %>%
  reactable(
    columns = list(
      Feature = colDef(footer = htmltools::tags$b("Total")),
      Up = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- up_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Down = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / (length(merged_results) - sum(df$Unchanged))
          color <- down_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      Unchanged = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          normalized <- value / length(merged_results)#sum(df$Unchanged)
          color <- unch_col(normalized)
          list(background = color)
        },
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      `% Changed` = colDef(
        cell = function(value) percent(value, 0.1),
        footer = htmltools::tags$b(
          percent(sum(1 - sum(df$Unchanged) / sum(df$Total)), 0.1)
        )
      ),
      Total = colDef(
        cell = function(value) comma(value, 1),
        style = function(value) {
          bar_style(width = value / length(merged_results), fill = "#B3B3B3")
        },
        align = "left",
        footer = function(values) htmltools::tags$b(comma(sum(values)))
      ),
      `% Of All Windows` = colDef(
        cell = function(value) percent(value, 0.1),
        footer = htmltools::tags$b("100%")
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```


### Most Highly Ranked

```{r tab-highy-ranked}
show_n <- min(200, length(merged_results))
scaling_vals <- list(
  logFC = range(merged_results$logFC),
  AveExpr = range(merged_results$AveExpr),
  Width = max(width(merged_results))
)
cp <- glue(
  "The {show_n} most highly-ranked merged windows by FDR. ",
  "Regions were assigned based on which genomic region showed the largest ",
  "overlap with the merged window. ",
  ifelse(
    has_features, 
    glue("Features are as provided in the file {basename(config$external$features)}"),
    glue("")
  )
)
tbl <- merged_results %>% 
  arrange(!!sym(fdr_column)) %>% 
  dplyr::slice(seq_len(show_n)) %>% 
  select(
    AveExpr, logFC, FDR = !!sym(fdr_column), 
    overlaps_ref, Region = region, any_of("feature"), Genes = detected
  ) %>% 
  as_tibble(rangeAsChar = FALSE) %>% 
  dplyr::rename(
    Chromosome = seqnames, Start = start, End = end, `Width (kb)` = width,
    `Macs2 Peak` = overlaps_ref
  ) %>% 
  rename_all(str_replace_all, "feature", "Feature") %>% 
  dplyr::select(-strand) %>% 
  mutate(Genes = vapply(Genes, paste, character(1), collapse = "; ")) %>% 
  reactable(
    searchable = TRUE,
    columns = list(
      Start = colDef(
        cell = function(value) comma(value, 1)
      ),
      End = colDef(
        cell = function(value) comma(value, 1)
      ),
      `Width (kb)` = colDef(
        cell = function(value) value / 1e3,
        style = function(value) {
          x <- value / scaling_vals$Width
          colour <- expr_col(x)
          list(background = colour)
        }
      ),
      AveExpr = colDef(
        cell = function(value) round(value, 2),
        style = function(value) {
          x <- (value - min(scaling_vals$AveExpr)) / diff(scaling_vals$AveExpr)
          colour = expr_col(x)
          list(background = colour)
        }
      ),
      logFC = colDef(
        cell = function(value) round(value, 2),
        style = function(value) {
          x <- (value - min(scaling_vals$logFC)) / diff(scaling_vals$logFC)
          colour <- lfc_col(x)
          list(background = colour)
        }
      ),
      FDR = colDef(
        cell = function(value) sprintf("%.2e", value)
      ),
      `Macs2 Peak` = colDef(
        cell = function(value) ifelse(value, "\u2714", "\u2716"),
        style = function(value) {
          color <- ifelse(value, "#008000", "#e00000")
          list(color = color)
        }
      ),
      Region = colDef(
        cell = function(value) str_replace(value, " \\(", "\n(")
      ),
      Genes = colDef(
        cell = function(value) with_tooltip(value)
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```


## Inspection of Top-Ranked Regions {.tabset}

```{r reset-bwfl}
results_grl <- merged_results %>% 
  mutate(group = str_remove(status, " \\+ Ref Peak")) %>% 
  split(f = .$group) %>% 
  lapply(granges) %>% 
  GRangesList()
feat_gr <- c(feat_gr, mutate(granges(consensus_peaks), feature = "Peak"))
feat_col <- rmd_config$colours$features %>% 
  c(list(Peak = "#B3B3B3")) 
bwfl <- file.path(bw_path, glue("{samples$sample}_treat_pileup.bw")) %>% 
  BigWigFileList() %>% 
  setNames(samples$label)
```

```{r makeCaption}
makeCaption <- function(
  .gr, .genes = genes_gr, .features = feat_gr, .target = target, 
  .trt = treat_levels[[2]]
  ) {
  nearest_gene <- .gr %>% 
    granges() %>% 
    join_nearest(.genes, distance= TRUE) %>% 
    select(gene_name, distance) 
  mapped_genes <- .gr$gene_name[[1]] %>% 
    str_replace_na() %>% 
    str_subset("^NA$", negate = TRUE) %>% 
    collapseGenes(format = "")
  feat_ol <- subsetByOverlaps(.features, .gr) %>% 
    as_tibble() %>% 
    subset(feature != "Peak") %>% 
    distinct(feature)
  wd <- width(.gr)
  dir <- case_when(
    .gr$direction == "Up" ~ "increased",
    .gr$direction == "Down" ~ "decreased",
    .gr$direction == "Unchanged" ~ "unchanged"
  )
  cp <- c(
    glue(
      "*The {wd}bp region showing {dir} {.target} binding in response to ", 
      "{.trt} treatment (FDR = {sprintf('%.2e', gr$fdr_ihw)}). ",
      "Features include any possible overlaps with Promoters, Enhancers, ",
      "Super-Enhancers or Macs2 Peaks (shown in grey). ",
      "Narrow bars directly above the coverage tracks indicate differential ",
      "binding status for each retained region in the above analysis."
    ),
    ifelse(
      gr$overlaps_ref,
      paste(
        "A consensus peak overlapping this region was identified by",
        "`macs2 callpeak` when using merged samples."
      ),
      "No consensus peak was identified using `macs2 callpeak`."
    ),
    ifelse(
      nearest_gene$distance == 0, 
      glue("The gene {nearest_gene$gene_name} directly overlaps the range."), 
      glue("{nearest_gene$gene_name} is {round(nearest_gene$distance/1e3, 1)} kb away.")
    ),
    ifelse(
      length(mapped_genes) > 0,
      paste0(
        "Using a more complete mapping strategy, the genes mapped to this region were ",
        mapped_genes, "."),
      ""
    ),
    ifelse(
      length(feat_ol$feature) == 0,
      "There is no direct overlap with any defined regulatory features.*",
      case_when(
        feat_ol$feature == "Enhancer" ~ 
          "This region directly overlaps an Enhancer.*",
        feat_ol$feature == "SE" ~ 
          "This region directly overlaps a Super-Enhancer.*",
        feat_ol$feature == "Promoter" ~ 
          "This region directly overlaps a Promoter.*"
      )
    )
  )
  cp <- paste(cp, collapse = " ")
  gsub(" +", " ", cp)
}
```

### Most Highly Ranked Increase

```{r gr_lowest_up_p}
gr <- merged_results %>% 
  filter(logFC > 0) %>% 
  filter(P.Value == min(P.Value))
```

```{r plot_gr_lowest_up_p, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Most Highly Ranked Decrease

```{r gr_lowest_down_p}
gr <- merged_results %>% 
  filter(logFC < 0) %>% 
  filter(P.Value == min(P.Value))
```

```{r plot_gr_lowest_down_p, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Changed Region With Highest Signal

```{r gr_highest_signal}
gr <- merged_results %>% 
  filter(fdr_ihw < fdr_alpha) %>% 
  filter(AveExpr == max(AveExpr))
```

`r ifelse(length(gr) == 0, "No region was considered as significantly changed", "")`

```{r plot_gr_highest_signal, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Most Extreme Increase

```{r gr_largest_up}
gr <- merged_results %>% 
  filter(fdr_ihw < fdr_alpha) %>% 
  filter(logFC == max(logFC))
```

`r ifelse(length(gr) == 0, "No region was considered as significantly changed", "")`

```{r plot_gr_largest_up, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Most Extreme Decrease

```{r gr_largest_down}
gr <- merged_results %>% 
  filter(fdr_ihw < fdr_alpha) %>% 
  filter(logFC == min(logFC))
```

`r ifelse(length(gr) == 0, "No region was considered as significantly changed", "")`

```{r plot_gr_largest_down, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Weakest Signal (No Consensus Peak)

```{r gr_weakest_nonref}
gr <- merged_results %>% 
  filter(fdr_ihw < fdr_alpha & !overlaps_ref) %>% 
  filter(AveExpr == min(AveExpr))
```

`r ifelse(length(gr) == 0, "No region was considered as significantly changed without any consensus peak overlap", "")`

```{r plot_gr_weakest_nonref, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

### Strongest Signal (No Consensus Peak)

```{r gr_strongest_nonref}
gr <- merged_results %>% 
  filter(fdr_ihw < fdr_alpha & !overlaps_ref) %>% 
  filter(AveExpr == max(AveExpr))
```

`r ifelse(length(gr) == 0, "No region was considered as significantly changed without any consensus peak overlap", "")`

```{r plot_gr_strongest_nonref, eval = length(gr) > 0, echo = length(gr) > 0, fig.cap = makeCaption(gr)}
y_max <-  bwfl %>% 
  lapply(import.bw, which = resize(gr, width = 10*width(gr), fix = "center")) %>%
  GRangesList() %>%
  unlist() %>%
  as_tibble() %>% 
  pull(score) %>% 
  max()
plotHFGC(
  gr, 
  features = split(feat_gr, f = feat_gr$feature),
  genes = trans_models,
  coverage = bwfl, 
  annotation = results_grl, annotcol = rmd_config$colours$direction,
  coverage_type = "l", 
  linecol = setNames(treat_cols[as.character(samples$treat)], samples$label),
  featurecol = feat_col,
  genecol = rmd_config$colours$direction,
  cytobands = bands_df, 
  zoom = 10, fontsize = 10, rotation.title = 90,
  legend = FALSE, covsize = 1, ylim = c(0, y_max)
)
```

# Data Export

```{r data-export, results='hide'}
all_out <- list(
  results = file.path(
    out_path, 
    glue("{treat_levels[[1]]}_{treat_levels[[2]]}_differential_binding.rds")
  ),
  windows  = file.path(
    out_path,
    glue("{treat_levels[[1]]}_{treat_levels[[2]]}_filtered_windows.rds")
  ),
  up_regions = file.path(
    out_path, glue("{treat_levels[[1]]}_{treat_levels[[2]]}_up.bed")
  ),
  down_regions = file.path(
    out_path, glue("{treat_levels[[1]]}_{treat_levels[[2]]}_down.bed")
  )
)
write_rds(merged_results, all_out$results, compress = "gz")
write_rds(filtered_counts, all_out$windows, compress = "gz")
file.create(all_out$up_regions)
if (length(sig_ranges$Up) > 0) 
  export.bed(granges(sig_ranges$Up), all_out$up_regions)
file.create(all_out$down_regions)
if (length(sig_ranges$Down) > 0) 
  export.bed(granges(sig_ranges$Down), all_out$down_regions)
```

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, paste0(basename(here::here()), ".+")))`

<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
