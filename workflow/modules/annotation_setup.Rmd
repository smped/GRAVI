---
title: "Annotation Setup"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
editor_options:
  chunk_output_type: console
---

```{r set-knitr-opts, echo=FALSE, child = '../workflow/modules/setup_chunk.Rmd'}
```

```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(plyranges)
library(yaml)
library(UpSetR)
library(BiocParallel)
library(scico)
library(Rsamtools)
```

```{r remotes, results='hide'}
## Deal with github packages
# BiocManager::install("steveped/extraChIPs", ask = FALSE)

stopifnot(library(extraChIPs, logical.return = TRUE))
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
register(MulticoreParam(8))
```

```{r load_funs}
source(here::here("workflow", "scripts", "autoload.R"))
```


```{r config}
config <- read_yaml(here::here("config", "config.yml"))
macs2_path <- here::here(config$paths$macs2)
bw_path <- here::here(config$paths$bigwig)
```

```{r treat_levels}
treat_levels <- config$comparisons$contrasts %>% 
  unlist() %>% 
  unique()
samples <- here::here(config$samples$file) %>%
  read_tsv() %>% 
  mutate(
    treat = factor(treat, levels = unique(c(treat_levels, treat))),
    target = as.factor(target)
  )
treat_levels <- levels(samples$treat)
```

```{r set_colours}
col_config <- here::here("config", "rmarkdown.yml") %>%
  read_yaml() %>% 
  .[["colours"]]
## qc_colours need to have `Pass` and `Fail`
missing_qc_cols <- setdiff(c("Pass", "Fail"), names(col_config$qc))
if ("Pass" %in% missing_qc_cols) col_config$qc$Pass <- "#0571B0" # Blue
if ("Fail" %in% missing_qc_cols) col_config$qc$Fail <- "#CA0020" # Red
col_config$qc <- col_config$qc[c("Pass", "Fail")]

## The colours specified as treat_colours should contain all treat_levels + Input
## If Input is missing, set to #33333380 ('grey20' + alpha = 50)
## This should be a standard chunk for all workflows
missing_treat_cols <- setdiff(
  c("Input", treat_levels), names(col_config$treat)
)
if (length(missing_treat_cols) > 0) {
  if ("Input" %in% missing_treat_cols) 
    col_config$treat$Input <- "#33333380"
  ## Automatically sample from the viridis palette if no colour is assigned
  col_config$treat[setdiff(missing_treat_cols, "Input")] <- hcl.colors(
    length(setdiff(missing_treat_cols, "Input"))
  )
}
```

```{r annotation-path}
annotation_path <- here::here("output", "annotations")
if (!dir.exists(annotation_path)) dir.create(annotation_path, recursive = TRUE)
all_out <- list(
  gtf  = file.path(annotation_path, "all_gr.rds"),
  transcript_models = file.path(annotation_path, "trans_models.rds"),
  tss = file.path(annotation_path, "tss.rds"),
  max_coverage = file.path(bw_path, "max_coverage.tsv")
)
```


# Genome Annotations

Before analysing any datasets, annotations for the genome and transcriptome need to be defined.

## Genome Description

```{r sq}
sq <- samples %>% 
  mutate(
    path = here::here(config$paths$bam, target, glue("{sample}.bam"))
  ) %>% 
  .[["path"]] %>% 
  BamFileList() %>% 
  seqinfo() %>% 
  sortSeqlevels() %>% 
  as.data.frame() %>% 
  mutate(
    isCircular = FALSE,
    genome = config$genome$build
  ) %>% 
  as("Seqinfo")
write_rds(sq, file.path(annotation_path, "seqinfo.rds"))
sq %>% 
  as.data.frame() %>% 
  rownames_to_column("seqnames") %>% 
  dplyr::select(seqnames, seqlengths) %>% 
  write_tsv(
    here::here(annotation_path, "chrom.sizes"), col_names = FALSE
  )
```

As the foundation for all annotation objects, the description of the underlying genome is required as a `Seqinfo` object.
For this analysis, both the mitochondrial genome and scaffolds were excluded, giving only the autosomes and sex chromosomes.
This `Seqinfo` will is added to all objects requiring information about the underlying genome, such as a `GenomicRanges` object.

```{r blacklist}
blacklist <- file.path(annotation_path, "blacklist.bed.gz") %>%
  import.bed(seqinfo = sq) %>%
  sort()
```

# Gene and Transcript Annotations

```{r load-gtf}
gtf <- glue(
  "{annotation_path}/",
  "gencode.v", config$genome$gencode, "lift", 
  str_extract(config$genome$build, '[0-9]+$'),
  ".annotation.gtf.gz"
  )
```

```{r all-gr}
reqd_cols <- c(
  "type",
  "gene_id", "gene_type", "gene_name",
  "transcript_id", "transcript_type", "transcript_name",
  "exon_id"
)
all_gr <- gtf %>%
  import.gff(
    which = GRanges(sq),
    feature.type = c("gene", "transcript", "exon")
  ) %>%
  select(all_of(reqd_cols)) %>%
  mutate(
    gene_id = str_remove_all(gene_id, "\\..+$"),
    transcript_id = str_remove_all(transcript_id, "\\..+$"),
    exon_id = str_remove_all(exon_id, "\\..+$"),
  ) %>%
  sort() %>%
  subset(seqnames %in% seqlevels(sq)) %>% 
  keepSeqlevels(seqlevels(sq)) %>% 
  split(f = .$type)
seqinfo(all_gr) <- sq
write_rds(all_gr, all_out$gtf, compress = "gz")
```


- The complete set of genes, transcripts and exons was loaded from the supplied `gtf`, excluding mitochondrial features.
- The previously generated `Seqinfo` was also placed as the foundation of this annotation object, ensuring this propagates through all subsequent objects
- Version numbers were removed from all gene, transcript and exon identifiers for convenience, with the minimal set of columns (`r pander(colnames(mcols(all_gr$gene)))`) retained.
- This master set of annotations was exported as an `rds` file for simple import into subsequent steps of the analysis

In total this object contained annotations for `r comma(length(all_gr$gene))` genes, `r comma(length(all_gr$transcript))` transcripts and `r comma(length(all_gr$exon))` exons.

## Transcript Models


```{r trans-models}
trans_models <- all_gr$exon %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  group_by(transcript_id) %>% 
  mutate(exon = paste0(transcript_id, "_", seq_along(transcript_id))) %>% 
  makeGRangesFromDataFrame(keep.extra.columns = TRUE) %>% 
  mutate(feature = as.character(type)) %>%  
  select(type, gene = gene_id, exon, transcript = transcript_id, symbol = gene_name) %>% 
  sort() %>% 
  setNames(.$transcript) %>% 
  set_genome_info(
    genome = genome(sq),
    seqnames = seqlevels(sq),
    seqlengths = seqlengths(sq),
    is_circular = isCircular(sq)
  )
write_rds(trans_models, all_out$transcript_models, compress = "gz")
```

Visualisation using the Bioconductor package `Gviz` requires specific structures for gene and transcript models to be displayed and these were formed once, so they too could be simply imported during all visualisation stages.

# Regulatory Features

## TSS Regions

```{r external-data}
rnaseq <- tibble(gene_id = character())
if (!is.null(config$external$rnaseq))
  rnaseq <- autoload(
    here::here(config$external$rnaseq)
  )
stopifnot("gene_id" %in% colnames(rnaseq))
h3k27ac <- GRanges(seqinfo = sq)
if (!is.null(config$external$H3K27ac))
  ## Will be overwritten in the next step if specified as a target
  h3k27ac <- import.bed(
    here::here(config$external$H3K27ac),
    which = GRanges(sq),
    seqinfo = sq
  )
if ("H3K27ac" %in% samples$target) {
  treats <- samples %>%
    dplyr::filter(grepl("H3K27ac", target)) %>%
    pull("treat") %>%
    unique()
  h3k27ac <- file.path(
    macs2_path, "H3K27ac", glue("{treats}_merged_peaks.narrowPeak")
  ) %>%
    importPeaks(seqinfo = sq, type = "narrow", blacklist = blacklist)
  if (is(h3k27ac, "GRangesList")) {
    h3k27ac <- h3k27ac %>%
      unlist() %>%
      GenomicRanges::reduce()
  }
}
h3k4me3 <- GRanges(seqinfo = sq)
if (!is.null(config$external$H3K4me3)) {
  h3k4me3 <- import.bed(
    here::here(config$external$H3K4me3),
    which = GRanges(sq),
    seqinfo = sq
  )
  stopifnot(is(h3k4me3, "GRanges"))
}
```

```{r define-tss}
tss <- all_gr$transcript %>%
  promoters(upstream = 1500, downstream = 500) %>%
  select(transcript_type, transcript_id, gene_id, gene_name) %>%
  mutate(
    detected = gene_id %in% rnaseq$gene_id,
    H3K27ac = overlapsAny(., h3k27ac),
    H3K4me3 = overlapsAny(., h3k4me3),
    blacklisted = overlapsAny(., blacklist),
    no_information = !detected & !H3K27ac & !H3K4me3 & !blacklisted
  ) %>%
  sort()
write_rds(tss, all_out$tss, compress = "gz")
```

Annotation-derived transcription start sites (TSS) were simply defined as the regions +500/-1500nt of a transcript.
Of the `r comma(length(tss))` regions:

- `r comma(sum(tss$blacklisted))` annotation-derived TSS overlapped blacklisted regions and no ChIP target information will be incorporated for these regions
`r ifelse(any(tss$detected), glue("- {comma(sum(tss$detected))} came from genes considered as detected"), "")`
`r ifelse(any(tss$H3K27ac), glue("- {comma(sum(tss$H3K27ac))} overlap an H3K27ac peak"), "")`
`r ifelse(any(tss$H3K4me3), glue("- {comma(sum(tss$H3K4me3))} overlap an H3K4me3 peak"), "")`
- For the remaining `r comma(length(subset(tss, no_information)))` annotation-derived TSS, no additional information was available beyond their presence in the reference

```{r plot-tss, fig.width=8, fig.height=5, fig.cap = glue("*Status of the {comma(length(tss))} annotation-derived TSS regions, compared to any H3K27ac, H3K4me3 and gene expression data contained in this analysis. Transcript types representing fewer than 1% of the total were combined into the 'Other' category.*")}
.fixRNACase <- function(x) {
  x <- str_to_lower(x)
  str_replace_all(x, "rna$", "RNA")
}
tss %>% 
  mcols() %>% 
  as_tibble() %>% 
  dplyr::filter(!blacklisted) %>% 
  mutate(`No Histone Information` = !H3K27ac & !H3K4me3) %>% 
  pivot_longer(cols = c(H3K27ac, H3K4me3, `No Histone Information`)) %>% 
  dplyr::filter(value) %>% 
  group_by(transcript_id, transcript_type, detected) %>% 
  summarise(name = paste(sort(unique(name)), collapse = " + "), .groups = "drop") %>% 
  mutate(
    transcript_type = fct_lump_prop(transcript_type, 0.01) %>% 
      fct_infreq() %>% 
      fct_relabel(str_replace_all, pattern= "_", replacement = " ") %>% 
      fct_relabel(str_to_title) %>% 
      fct_relabel(str_replace_all, pattern = "(.+)rna", replacement = .fixRNACase) %>% 
      fct_rev(),
    name = fct_infreq(name)
  ) %>%
  ggplot(aes(fct_rev(name), fill = transcript_type)) + 
  geom_bar() + 
  facet_grid(
    detected~., scales = "free_y", space = "free", 
    labeller = as_labeller(c("TRUE" = "Detected", "FALSE"= "Not Detected"))
  ) +
  coord_flip() + 
  labs(x = "Status", y = "Total", fill = "Transcript Type") +
  scale_fill_scico_d(palette = "tokyo", direction = -1) +
  scale_y_continuous(expand = expansion(c(0, 0.05)))
```



<!--- Insert H3K27Ac child document here --->
```{r add-h3k27ac, child= if (length(h3k27ac) > 0) '../workflow/modules/features_from_h3k27ac.Rmd'}
```

# BigWig Coverage

In addition to the external data, the maximum coverage detected for each bigwig file was calculated.
This may be used to scale any coverage plots to be strictly on the range [0, 100] relative to the region of highest coverage.
The coverage range for the *merged samples only* is calculated below.

```{r get-max-coverage}
gr <- sq %>%
  GRanges() %>%
  setdiff(blacklist)
bwfl <- file.path(
  bw_path,
  samples %>%
    distinct(target, treat) %>%
    unite(path, c(target, treat), sep = .Platform$file.sep) %>%
    pull(path) %>%
    paste0("_merged_treat_pileup.bw")
) %>%
  BigWigFileList() %>%
  setNames(
    samples %>%
      distinct(target, treat) %>%
      unite(path, c(target, treat), sep = .Platform$file.sep) %>%
      pull(path) %>%
      paste0("_merged")
  )
max_coverage <- names(bwfl) %>%
  bplapply(
    function(x) {
      peaks <- importPeaks(
        paste0(here::here("data", "macs2", x), "_peaks.narrowPeak")
      )[[1]]
      if (length(peaks) == 0) peaks <- gr
      cov <- import.bw(bwfl[[x]], which = peaks)
      max(cov$score)
    }
  ) %>%
  setNames(names(bwfl)) %>% 
  unlist() %>% 
  enframe() %>%
  separate(
    name, into = c("target", "treat"), extra = "drop"
  )
write_tsv(max_coverage, all_out$max_coverage)
```

```{r plot-max-coverage, fig.height=5, fig.cap = "*Maximum observed coverage for each treatment and target, based on the BigWig files as generated by `macs2 callpeak`*"}
max_coverage %>%
  ggplot(aes(treat, value, fill = treat)) +
  geom_col(position = "dodge") +
  facet_grid(.~target, scale = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_cols) +
  labs(
    x = "Treatment",
    y = "Maximum Coverage (CPM)",
    fill = "Treatment"
  )
```

# Data Export

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, paste0(basename(here::here()), ".+")))`


<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
