---
title: "Annotation Setup"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
editor_options:
  chunk_output_type: console
---

```{r set-knitr-opts, echo=FALSE, child = '../workflow/modules/setup_chunk.Rmd'}
```

```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(plyranges)
library(yaml)
library(Rsamtools)
library(parallel)
library(BiocParallel)
```

```{r remotes, results='hide'}
## Deal with github packages
# BiocManager::install("steveped/extraChIPs", ask = FALSE)

stopifnot(library(extraChIPs, logical.return = TRUE))
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
n_cores <- max(detectCores() - 2, 2)
```

```{r extra-funs}
source(
  here::here("workflow", "scripts", "custom_functions.R")
)
```


```{r config}
config <- read_yaml(here::here("config", "config.yml"))
col_config <- here::here("config", "rmarkdown.yml") %>%
  read_yaml() %>% 
  .[["colours"]]
```

```{r treat_levels}
treat_levels <- config$comparisons$contrasts %>% 
  unlist() %>% 
  unique()
samples <- here::here(config$samples$file) %>%
  read_tsv() %>% 
  mutate(
    treat = factor(treat, levels = unique(c(treat_levels, treat))),
    target = as.factor(target)
  )
treat_levels <- levels(samples$treat)
```

```{r annotation-path}
annotation_path <- here::here("output", "annotations")
if (!dir.exists(annotation_path)) dir.create(annotation_path, recursive = TRUE)
all_out <- list(
  chrom_sizes = file.path(annotation_path, "chrom.sizes"),
  colours  = file.path(annotation_path, "colours.rds"),
  env = here::here("output", "envs", "annotation_setup.RData"),
  gene_regions = file.path(annotation_path, "gene_regions.rds"),
  gtf  = file.path(annotation_path, "all_gr.rds"),
  seqinfo = file.path(annotation_path, "seqinfo.rds"),
  transcript_models = file.path(annotation_path, "trans_models.rds"),
  tss = file.path(annotation_path, "tss.rds")
)
```

# Genome Annotations

Before analysing any datasets, annotations for the genome and transcriptome need to be defined.

## Genome Description

```{r sq}
sq <- samples %>% 
  mutate(
    path = here::here(config$paths$bam, target, glue("{sample}.bam"))
  ) %>% 
  .[["path"]] %>% 
  BamFileList() %>% 
  seqinfo() %>% 
  sortSeqlevels() %>% 
  as.data.frame() %>% 
  .[rownames(.) %in% paste0("chr", c(1:22, "X", "Y")),] %>%  # This covers mouse & rat
  mutate(
    isCircular = FALSE,
    genome = config$genome$build
  ) %>% 
  as("Seqinfo")
write_rds(sq, all_out$seqinfo)
sq %>% 
  as_tibble() %>% 
  dplyr::select(seqnames, seqlengths) %>% 
  write_tsv(all_out$chrom_sizes, col_names = FALSE)
```

As the foundation for all annotation objects, the description of the underlying genome is required as a `Seqinfo` object.
For this analysis, both the mitochondrial genome and scaffolds were excluded, giving only the autosomes and the X/Y chromosomes.
This `Seqinfo` object is added to all subsequent objects requiring information about the underlying genome, such as a `GenomicRanges` object.

## Blacklisted Regions {.tabset}

```{r blacklist}
blacklist <- file.path(annotation_path, "blacklist.bed.gz") %>%
  import.bed(seqinfo = sq) %>%
  sort()
```

### Summary

```{r tab-blacklist}
blacklist %>% 
  group_by(name) %>% 
  summarise(
    n = n(),
    p = percent(sum(width)/ sum(seqlengths(sq))),
    kb = sum(width) / 1e3,
    min = min(width) / 1e3,
    median = median(width) / 1e3,
    max = max(width) / 1e3
  ) %>% 
  as_tibble() %>% 
  dplyr::rename_all(str_to_title) %>% 
  dplyr::rename(
    Type = Name, 
    `Nbr Regions` = N,
    `% Genome` = P, 
    `Total (kb)` = Kb,
    `Min (kb)` = Min,
    `Median (kb)` = Median,
    `Max (kb)` = Max
  ) %>% 
  pander(
    caption = glue(
      "*Summary of genomic regions excluded in the blacklist. ",
      "The default set of blacklisted regions was used, as obtained from ",
      "https://github.com/Boyle-Lab/Blacklist (ENCODE)*"
    ),
    justify = "lrrrrrr"
  )
```

### Breakdown

```{r plot-blacklist, fig.height = 7, fig.cap = "*Breakdown of blacklisted regions by chromosome*"}
blacklist %>% 
  as_tibble(rangeAsChar = FALSE) %>%
  group_by(seqnames) %>% 
  summarise(blacklisted = sum(width)) %>% 
  left_join(as_tibble(sq), by = "seqnames") %>% 
  mutate(
    whitelisted = seqlengths - blacklisted,
    seqnames = factor(seqnames, levels = seqlevels(sq))
  ) %>% 
  pivot_longer(
    ends_with("listed"), names_to = "category", values_to = "bp"
  ) %>% 
  ggplot(aes(fct_rev(seqnames), bp/1e6, fill = fct_rev(category))) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(expand = expansion(c(0, 0.05))) +
  scale_fill_manual(
    values = c(rgb(0.1, 0.3, 0.9), rgb(0.9, 0.2, 0.1))
  ) +
  labs(
    x = "Chromosome", y = "Length (Mb)", fill = "Status"
  )
```


# Gene and Transcript Annotations

## Basic Annotations

```{r load-gtf}
gtf <- glue(
  "{annotation_path}/",
  "gencode.v", config$genome$gencode, "lift", 
  str_extract(config$genome$build, '[0-9]+$'),
  ".annotation.gtf.gz"
  )
## This will set the import to fail using the `all_of()` step below
reqd_cols <- c(
  "type",
  "gene_id", "gene_type", "gene_name",
  "transcript_id", "transcript_type", "transcript_name",
  "exon_id"
)
if (!file.exists(all_out$gtf)) {
  all_gr <- gtf %>%
    import.gff(
      which = GRanges(sq),
      feature.type = c("gene", "transcript", "exon")
    ) %>%
    select(all_of(reqd_cols)) %>%
    mutate(
      gene_id = str_remove_all(gene_id, "\\..+$"),
      transcript_id = str_remove_all(transcript_id, "\\..+$"),
      exon_id = str_remove_all(exon_id, "\\..+$"),
    ) %>%
    sort() %>%
    subset(seqnames %in% seqlevels(sq)) %>% 
    keepSeqlevels(seqlevels(sq)) %>% 
    splitAsList(f = .$type)
  seqinfo(all_gr) <- sq
  write_rds(all_gr, all_out$gtf, compress = "gz")
} else {
  all_gr <- read_rds(all_out$gtf)
}
```

- The complete set of genes, transcripts and exons was loaded from the supplied `gtf`, excluding mitochondrial features.
- The previously generated `Seqinfo` was also placed as the foundation of this annotation object, ensuring this propagates through all subsequent objects
- Version numbers were removed from all gene, transcript and exon identifiers for convenience, with the minimal set of columns (`r pander(colnames(mcols(all_gr$gene)))`) retained.
- This master set of annotations was exported as an `rds` file for simple import into subsequent steps of the analysis

In total this object contained annotations for `r comma(length(all_gr$gene))` genes, `r comma(length(all_gr$transcript))` transcripts and `r comma(length(all_gr$exon))` exons.

```{r trans-models}
if (!file.exists(all_out$transcript_models)) {
  trans_models <- all_gr$exon %>% 
    as_tibble(rangeAsChar = FALSE) %>% 
    group_by(transcript_id) %>% 
    mutate(exon = paste0(transcript_id, "_", seq_along(transcript_id))) %>% 
    makeGRangesFromDataFrame(keep.extra.columns = TRUE) %>% 
    mutate(feature = as.character(type)) %>%  
    select(type, gene = gene_id, exon, transcript = transcript_id, symbol = gene_name) %>% 
    sort() %>% 
    setNames(.$transcript) %>% 
    set_genome_info(
      genome = genome(sq),
      seqnames = seqlevels(sq),
      seqlengths = seqlengths(sq),
      is_circular = isCircular(sq)
    )
  write_rds(trans_models, all_out$transcript_models, compress = "gz")
} else {
  trans_models <- read_rds(all_out$transcript_models)  
}
```

Visualisation using the Bioconductor package `Gviz` also requires a specific `GRanges` structure for gene and transcript models to be displayed.
This object was formed here, so they too could be simply imported during all visualisation stages.

## Gene-Centric Regions {.tabset}

```{r load-rna}
## This defines the RNA-Seq data as an empty tibble with the column gene_id
## If no data is provided, this will equate to no genes being considered as 
## detected.
## If RNA-seq data is provided, transcript ids will be used to determine
## detection, defaulting to gene ids if the transcript id is not provided in
## the RNA-Seq data
rna_path <- here::here(config$external$rnaseq)
rnaseq <- tibble(gene_id = character())
if (!is.null(rna_path)) {
  stopifnot(file.exists(rna_path))
  if (str_detect(rna_path, "tsv$")) rnaseq <- read_tsv(rna_path)
  if (str_detect(rna_path, "csv$")) rnaseq <- read_csv(rna_path)
  if (!"gene_id" %in% colnames(rnaseq)) stop("Supplied RNA-Seq data must contain the column 'gene_id'")
}
tx_col <- intersect(c("tx_id", "transcript_id"), colnames(rnaseq))
rna_gr_col <- ifelse(length(tx_col) > 0, "transcript_id", "gene_id")
rna_col <- c(tx_col, "gene_id")[[1]]
```


```{r gene-regions}
## Setup the features as a hierarchy, where higher-level features take precedence
## Features can be merged within a category if they overlap
## 1. Promoters (+/-2kb)
## 2. Upstream promoter (2-5kb, but not overlapping another)
## 3. Introns
## 4. Exons (other gene body)
tss <- all_gr$transcript %>% 
  resize(width = 1) %>% 
  mutate(detected = !!sym(rna_gr_col) %in% rnaseq[[rna_col]]) %>% 
  reduceMC() %>% 
  mutate(
    region = "TSS",
    detected = vapply(detected, any, logical(1))
  ) %>% 
  select(region, everything(), -type)
write_rds(tss, all_out$tss, compress = "gz")
prom <- list(up = 1500, down = 500, distal = 5e3)
if (!file.exists(all_out$gene_regions)) {
  gene_regions <- list(
    promoters = all_gr$transcript %>% 
      promoters(
        upstream = prom$up, downstream = prom$down
      ) %>% 
      mutate(detected = !!sym(rna_gr_col) %in% rnaseq[[rna_col]]) %>% 
      reduceMC(ignore.strand = TRUE) %>% 
      mutate(
        region = glue("Promoter (+{prom$up}/-{prom$down}bp)"),
        detected = vapply(detected, any, logical(1))
      ) %>% 
      select(region, everything(), -type)
  )
  gene_regions$upstream <- all_gr$transcript %>% 
    promoters(upstream = prom$distal, downstream = 0)  %>% 
    mutate(detected = !!sym(rna_gr_col) %in% rnaseq[[rna_col]]) %>% 
    setdiffMC(gene_regions$promoters, ignore.strand = TRUE) %>% 
    reduceMC() %>% 
    mutate(
      region = glue("Upstream Promoter (<{prom$distal/1e3}kb)"),
      detected = vapply(detected, any, logical(1))
    ) %>% 
    select(region, everything(), -type)
  ## Some of these will possibly extend into other genes.
  ## The only real solution is to cut any sections from the upstream ranges
  ## which overlap other genes, whilst retaining those ranges which are internal
  ## to the gene-of-origin. The only viable way to do that is to manually exclude 
  ## the gene-of-origin then take the setdiff. This will take an hour or two
  gene_regions$upstream <- gene_regions$upstream %>%
    split(f = seq_along(.)) %>%
    bplapply(
      function(x) {
        gr <- subset(all_gr$gene, !gene_id %in% unlist(x$gene_id))
        setdiffMC(x, gr, ignore.strand = TRUE)
      }
    ) %>% 
    GRangesList() %>% 
    unlist() %>% 
    setNames(c())
  gene_regions$exons <- all_gr$exon %>% 
    mutate(detected = !!sym(rna_gr_col) %in% rnaseq[[rna_col]]) %>% 
    unstrand() %>% 
    reduceMC() %>% 
    setdiffMC(
      lapply(gene_regions[c("promoters", "upstream")], granges) %>% 
        GRangesList() %>% 
        unlist
    ) %>% 
    mutate(
      region = "Exon",
      detected = vapply(detected, any, logical(1))
    ) %>% 
    select(region, everything(), -type)
  gene_regions$introns <- all_gr$gene %>% 
    ## Here, we can only revert to gene-level detection
    mutate(
      detected = gene_id %in% unlist(subset(gene_regions$promoters, detected)$gene_id)
    ) %>% 
    unstrand() %>% 
    setdiffMC(
      lapply(gene_regions[c("promoters", "upstream", "exons")], granges) %>% 
        GRangesList() %>% 
        unlist()
    ) %>% 
    reduceMC() %>% 
    mutate(
      region = "Intron",
      detected = vapply(detected, any, logical(1))
    ) %>% 
    select(region, everything(), -type)
  gene_regions$distal <- sq %>% 
    GRanges() %>% 
    setdiff(
      suppressWarnings(
        all_gr$gene %>% 
          resize(width  = width(.) + 2e4, fix = 'center') %>% 
          trim() %>% 
          unstrand()
      ) 
    ) %>% 
    mutate(
      region = "Intergenic (>10kb)",
      detected = FALSE
    )
  gene_regions$proximal <- setdiff(
    GRanges(sq),
    lapply(gene_regions, granges) %>% 
      GRangesList() %>% 
      unlist()
  ) %>% 
    join_nearest(all_gr$gene) %>% 
    mutate(
      region = "Intergenic (<10kb)",
      ## Here, we can only revert to gene-level detection
      detected = gene_id %in% unlist(subset(gene_regions$promoters, detected)$gene_id)
    ) %>% 
    select(region, everything(), -type)
  ## Remove any columns which are just NA
  gene_regions <- gene_regions %>% 
    lapply(
      function(x) {
        keep <- vapply(
          mcols(x),
          function(y) {
            if (!is(y, "list_OR_List")) {
              if (all(is.na(y))) return(FALSE)
            }
            return(TRUE)
          },
          logical(1)
        )
        mcols(x) <- mcols(x)[keep]
        x
      }
    )
  ## Change the order of the two intragenic features for easier setting of 
  ## factor-levels
  o <- c(
    "promoters", "upstream", "exons", "introns", "proximal",  "distal"
  )
  gene_regions <- gene_regions[o]
  write_rds(gene_regions, all_out$gene_regions, compress = "gz")
} else {
  gene_regions <- read_rds(all_out$gene_regions)
}
regions <- vapply(gene_regions, function(x){unique(x$region)}, character(1))
region_cols <- col_config$regions
region_levels <- names(gene_regions)
missing_region_col <- setdiff(region_levels, names(region_cols))
if (length(missing_region_col) > 0) {
  n <- length(missing_region_col)
  feat_col[missing_feat_col] <- hcl.colors(
    length(gene_regions) - 1, rev = TRUE, alpha = 0.8
  )[seq_len(n)]
}
col_config$regions <- as.list(region_cols)
```

Using the provided GTF, **unique** gene and transcript-centric features were defined as:

1. Promoters
2. Upstream 
3. Exons
4. Introns
5. Intergenic regions within 10kb of a gene
6. Intergenic regions >10kb from any defined genes

TSS regions were defined as a separate object given each TSS has single-base width.
With the exception of TSS and Promoters, these features were non-overlapping and defined in a hierarchical, unstranded manner.

- *TSS* regions were the individual start sites for each transcript. Given that many transcripts can originate from the same TSS, this is somewhat smaller than the number of actual transcripts defined in the GTF
- *Promoters* were first defined for all individual transcripts as the region `r glue("+{prom$up}/-{prom$down}")`bp around each TSS.
Overlapping regions were merged to create a single promoter region for all transcripts within that genomic region.
- *Upstream promoters* were then defined as the region extending `r glue(prom$distal/1e3)`kb upstream from a TSS, but excluding any region already defined as a promoter through the previous merging step.
Any ranges within these which overlapped other genes were removed.
- *Exons* and *Introns* were considered to be any exon or intron, not previously included in one of the above regions.
- *Intergenic* regions were defined as those within 10kb (excluding upstream promoters) or those >10kb from any gene

```{r tab-regions}
gene_regions %>% 
  lapply(
    function(x){
      tibble(
        n = length(x),
        width = sum(width(x)), 
        region = unique(x$region)
      )
    }
  ) %>%
  bind_rows() %>% 
  mutate(
    width = width / 1e6,
    mn = round(1e3*width/n, 1),
    region = fct_inorder(region),
    `% Genome` = percent(width / sum(width), 0.1),
    ## Convert to characters for printing
    width = sprintf("%.1f", width),
    mn = sprintf("%.1f", mn)
  ) %>% 
  rename_all(str_to_title) %>% 
  dplyr::select(
    Region, N, `Total Width (Mb)` = Width,
    `Average Width (Kb)` = Mn, `% Genome`
  ) %>% 
  pander(
    justify = "lrrrr",
    caption = "*Summary of unique gene-centric regions defined above*"
  )
```

### Summary

```{r pie-gene-regions, fig.height=8, fig.width=8, fig.cap = "*Summary of gene-cetric regions using the above workflow and the supplied GTF. Percentages represent the amount of the genome allocated to each region. Blacklisted regions were not considered for this step of the annotation.*"}
gene_regions %>% 
  lapply(select, region) %>% 
  GRangesList() %>% 
  unlist() %>% 
  mutate(region = factor(region, levels = regions)) %>% 
  plotPie(
    fill = "region", scale_by = "width", show_total = FALSE, 
    category_size = 3.5
  ) +
  scale_fill_manual(
    values = region_cols %>% 
      unlist() %>% 
      setNames(regions[names(.)]) 
  ) +
  theme(legend.position = "none")
```

### Example

```{r example-id}
id <- sort(all_gr$gene$gene_id)[[1]]
```


```{r plot-example, fig.height=7, fig.cap = paste("*12kb region surrounding", collapseGenes(subset(all_gr$gene, gene_id == id)$gene_name), "showing all annotated regions.*")}
gr <- subset(all_gr$gene, gene_id == id) %>% 
  resize(width = width(.) + 2.4e4, fix = 'center') %>% 
  unstrand()
ft <- gene_regions %>% 
  lapply(subsetByOverlaps, gr) %>% 
  lapply(select, region) %>% 
  lapply(intersectMC, gr) %>% 
  GRangesList() %>% 
  unlist() %>% 
  setNames(c()) %>% 
  subset(region != "TSS") %>% 
  sort()
df <- list(
  all_gr$transcript %>% 
    subsetByOverlaps(gr) %>% 
    as_tibble(rangeAsChar = FALSE),
  all_gr$exon %>% 
    subsetByOverlaps(gr) %>% 
    as_tibble(rangeAsChar = FALSE) 
) %>% 
  bind_rows() %>% 
  mutate(
    transcript_name = as.factor(transcript_name)
  )
df %>% 
  ggplot(aes(x = start, y = as.integer(transcript_name))) +
  geom_rect(
    aes(
      xmin = start, xmax = end,
      ymin =  0, ymax =  Inf,
      fill = region
    ),
    data = ft %>%
      as.data.frame() %>% 
      mutate(region = fct_inorder(region) ),
    inherit.aes = FALSE,
    alpha = 0.7
  ) +
  geom_segment(
    aes(
      x = start, xend = end, 
      y = as.integer(transcript_name),
      yend = as.integer(transcript_name)
    ),
    data = . %>% 
      dplyr::filter(type == "transcript")
  ) +
  geom_segment(
    aes(
      x = mid, xend = mid_offset, 
      y = as.integer(transcript_name),
      yend = as.integer(transcript_name)
    ),
    data = all_gr$transcript %>% 
      subsetByOverlaps(gr) %>% 
      select(transcript_name) %>% 
      setdiffMC(all_gr$exon) %>%
      as.data.frame() %>% 
      mutate(transcript_name = vctrs::vec_proxy(transcript_name)) %>% 
      unnest(transcript_name) %>% 
      dplyr::filter(width > 600) %>% 
      mutate(
        mid = end - 0.5*width,
        mid_offset = ifelse(strand == "+", mid + 50, mid - 50),
        transcript_name = factor(transcript_name, levels = levels(df$transcript_name))
      ),
    arrow = arrow(angle = 40, length = unit(0.015, "npc"))
  ) +
  geom_rect(
    aes(
      xmin = start, xmax = end, 
      ymin = as.integer(transcript_name) - 0.2, 
      ymax = as.integer(transcript_name) + 0.2
    ),
    data = . %>% 
      dplyr::filter(type == "exon"),
    fill = "blue", colour = "blue"
  ) +
  coord_cartesian(xlim = c(start(gr), end(gr))) +
  scale_x_continuous(
    labels = comma, expand = expansion(c(0, 0))
  ) +
  scale_y_continuous(
    breaks = seq_along(levels(df$transcript_name)),
    labels = levels(df$transcript_name),
    expand = expansion(c(-0.05, 0.05))
  ) +
  scale_fill_manual(
    values = region_cols %>% 
      unlist() %>% 
      setNames(regions[names(.)]) %>% 
      .[setdiff(names(.), "TSS")]
  ) + 
  labs(
    x = as.character(seqnames(gr)), y = "Transcript", fill = "Feature"
  ) +
  theme(
    panel.grid = element_blank()
  )
```


# External Features

```{r external-features}
feat_path <- here::here(config$external$features)
external_features <- list(features = c())
if (!is.null(feat_path)) {
  stopifnot(file.exists(feat_path))
  external_features <- suppressWarnings(
    import.gff(feat_path, genome = sq)
  )
  mcols(external_features) <- cbind(
    mcols(external_features),
    gene_regions %>% 
      lapply(function(x) propOverlap(external_features, x)) %>% 
      as("DataFrame"),
    gene_regions %>% 
      lapply(
        function(x) propOverlap(external_features, subset(x, detected))
      ) %>% 
      as("DataFrame") %>% 
      setNames(paste0(names(.), "_detected"))
  )
  keep_cols <- !vapply(
    mcols(external_features), function(x) all(is.na(x)), logical(1)
  )
  mcols(external_features) <- mcols(external_features)[keep_cols]
}
```

```{r feat-col}
feat_col <- col_config$features
feat_levels <- unique(external_features$feature)
missing_feat_col <- setdiff(feat_levels, names(feat_col))
if (length(missing_feat_col) > 0) {
  n <- length(missing_feat_col)
  feat_col[missing_feat_col] <- hcl.colors(max(9, n), "Spectral")[seq_len(n)]
}
col_config$features <- feat_col
```


`r ifelse(is.null(external_features), "No external features were supplied.", "External features were compared to the gene-centric annotations.")`

```{r plot-feature-by-region, fig.height = 7, eval = !is.null(external_features), echo = !is.null(external_features), fig.cap = glue("*The proportion of the ranges provided as external features in the file {basename(config$external$feature)}, and which overlap the gene-centric regions defined above Regions associated with detected genes are shown as solid colours, whilst those with no information are shown as semi-transparent colours.*")}
suppressWarnings(
  external_features %>% 
    mutate(w = width) %>% 
    mcols() %>% 
    as_tibble() %>% 
    pivot_longer(
      cols = c(all_of(names(regions)), ends_with("detected")),
      names_to = "region", values_to = "prop"
    ) %>% 
    group_by(feature, region) %>% 
    summarise(ol = sum(prop*w/1e6), .groups = "drop") %>% 
    mutate(
      detected = str_detect(region, "detected"),
      region = str_remove_all(region, "_detected")
    ) %>% 
    pivot_wider(names_from = "detected", values_from = ol) %>% 
    mutate(`FALSE` = `FALSE` - `TRUE`) %>% 
    pivot_longer(
      cols = all_of(c("TRUE", "FALSE")),
      names_to = "detected",
      values_to = "ol"
    ) %>% 
    left_join(
      external_features %>%
        group_by(feature) %>% 
        summarise(w = sum(width/1e6)) %>%
        as_tibble(),
      by = "feature"
    ) %>% 
    mutate(
      p = ol / w,
      Feature = factor(feature, levels = names(feat_col)) %>% 
        fct_relabel(str_sep_to_title),
      region = factor(regions[region], levels = regions)
    ) %>% 
    ggplot(
      aes(fct_rev(region), p, fill = feature, alpha = detected)
    ) +
    geom_col(colour = "grey80") +
    geom_label(
      aes(label = percent(p, accuracy = 1)),
      data = . %>% 
        group_by(region, feature, Feature) %>% 
        summarise(p = sum(p), .groups = "drop"),
      alpha = 0.5,
      nudge_y = 0.03
    ) +
    coord_flip() +
    facet_grid(Feature~., scales = "free_y", space = "free") +
    scale_y_continuous(labels = percent, expand = expansion(c(0, 0.05))) +
    scale_alpha_discrete(range = c(0.4, 1)) +
    scale_fill_manual(values = feat_col) +
    labs(x = "", y = "") +
    theme(legend.position = "none")
)
```



```{r tab-features, eval = !is.null(external_features), echo = !is.null(external_features)}
external_features %>% 
  group_by(feature) %>% 
  summarise(
    N = n(),
    Width = sum(width/1e3),
    med = round(median(width/1e3), 1),
    range = glue("[{round(min(width/1e3), 1)}, {round(max(width/1e3), 1)}]")
  ) %>% 
  as_tibble() %>% 
  mutate(
    feature = factor(feature, levels = names(feat_col)) %>%
      fct_relabel(str_sep_to_title)
  ) %>%
  arrange(feature) %>%
  dplyr::rename(
    Feature = feature,
    `Total Width (kb)` = Width,
    `Median Width (kb)` = med,
    `Width Range (kb)` = range
  ) %>% 
  pander(
    justify = "lrrrr",
    caption = glue(
      "*Summary of external features provided in the file ", 
      "{basename(config$external$feature)}. All peaks and windows will be ", 
      "compared to these throughout the workflow*"
    )
  )
```


# Colour Schemes {.tabset}

```{r set_colours}

## qc_colours need to have `Pass` and `Fail`
missing_qc_cols <- setdiff(c("pass", "fail"), names(col_config$qc))
if ("pass" %in% missing_qc_cols) col_config$qc$pass <- "#0571B0" # Blue
if ("fail" %in% missing_qc_cols) col_config$qc$fail <- "#CA0020" # Red
col_config$qc <- col_config$qc[c("pass", "fail")]

## The colours specified as treat_colours should contain all treat_levels + Input
## If Input is missing, set to #33333380 ('grey20' + alpha = 50)
## This should be a standard chunk for all workflows
missing_treat_cols <- setdiff(
  c("Input", treat_levels), names(col_config$treat)
)
if (length(missing_treat_cols) > 0) {
  if ("Input" %in% missing_treat_cols) 
    col_config$treat$Input <- "#33333380"
  ## Automatically sample from the viridis palette if no colour is assigned
  col_config$treat[setdiff(missing_treat_cols, "Input")] <- hcl.colors(
    length(setdiff(missing_treat_cols, "Input"))
  )
}

## Direction colours always need up, down, unchanged & undetected
missing_dir_cols <- setdiff(
  c("up", "down", "unchanged", "undetected"), names(col_config$direction)
)
if (length(missing_dir_cols) > 0){
  def_dir_cols <- c(
    up = "#CA0020", down = "#0571B0", 
    unchanged = "#7F7F7F", undetected = "#E5E5E5"
  )
  col_config$direction[missing_dir_cols] <- def_dir_cols[missing_dir_cols]
}
write_rds(col_config, all_out$colours)
```


Colours were checked where provided and any missing colours were automatically assigned.
These colour schemes are shown below and will be propagated through all steps of the workflow.
To change any colours, simply add them to `config/rmarkdown.yml`.

## QC

```{r plot-qc, fig.height=3, fig.width=2 + length(col_config$qc)}
col_config$qc %>% 
  .plotScheme(xlab = "QC Category") 
```

## Treatment Groups

```{r plot-treat, fig.height=3, fig.width=2 + length(col_config$treat)}
col_config$treat %>% 
  .plotScheme(xlab = "Treatment")
```

## Regions

```{r plot-regions, fig.height=3, fig.width=2 + length(col_config$regions)}
col_config$regions %>% 
  .plotScheme(xlab = "Regions")
```


## Features

```{r plot-feat, fig.height=3, fig.width=2 + length(col_config$features)}
feat_col %>% 
  .plotScheme(xlab = "Feature")
```

## Direction

```{r plot-dir, fig.height=3, fig.width=2 + length(col_config$direction)}
col_config$direction %>% 
  .plotScheme(xlab = "Direction")
```

# Data Export

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, paste0(basename(here::here()), ".+")))`

```{r save-renv}
if (!dir.exists(dirname(all_out$env))) dir.create(dirname(all_out$env))
save.image(all_out$env)
```


<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
