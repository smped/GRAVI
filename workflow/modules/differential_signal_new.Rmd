This is a rewrite of the previous differential signal module.
Required input should be the sets of counts which can be produced by running
a standalone R script. These counts will be used as input for the DSA section.
Sliding window counts should also be filtered using `dualFilter()` as part of
this script.

Permitted DSA methods are:

1. Fixed-Width Windows
    + All edgeR normalisation & either QL or LT
2. Sliding Windows
    + All edgeR normalisation & either QL or LT
    + SQ Normalisation & LT

The basic approach will be:

1. Load counts
2. Perform a quantro test
    + Failed tests will only permit "none" (QL/LT) or SQ (FW-LT) normalisation
    + Passed tests will permit all normalisation methods
3. Perform DSA

```{r set-params, eval = FALSE, echo = FALSE}
params <- list(
  threads = 4,
  target = "H3K27ac", 
  treat_levels = c("E2", "E2DHT"), 
  windows = "sliding",
  window_size = 180,
  method = "lt",
  norm = "sq",
  pair_col = NULL,
  fdr_alpha = 0.05,
  fc = 1.2,
  ihw = "none"
)
```

Supplied parameters for this analysis include:

`r pander::pander(params)`

```{r get_params, echo = FALSE, eval=TRUE}
threads <- as.numeric(params$threads)
target <- params$target
treat_levels <- params$treat_levels
win_type <- match.arg(params$windows, c("fixed-width", "sliding"))
win_size <- as.numeric(params$window_size)
method <- match.arg(params$method, c("qlf", "lt"))
norm <- match.arg(
  params$norm, c("sq", eval(formals(edgeR::calcNormFactors.DGEList)$method))
)
pair_col <- params$pair_col ## This may need revision of earlier modules
fdr_alpha <- as.numeric(params$fdr_alpha)
fc <- as.numeric(params$fc)
ihw_method <- match.arg(
  params$ihw, c("regions", "features", "targets", "none")
)
if (win_type == "fixed-width" & norm == "sq") stop(
  "Smooth Quantile normalisation not permitted on fixed-width windows."
)
```

```{r packages}
library(tidyverse)
library(glue)
library(pander)
library(extraChIPs)
library(yaml)
library(GenomicInteractions)
library(quantro)
library(qsmooth)
library(edgeR)
library(patchwork)
library(plyranges)
library(reactable)
library(scales)
library(htmltools)
library(rtracklayer)
library(ggrepel)
library(rlang)
library(parallel)
# library(BiocParallel)
# library(GenomeInfoDb)
# library(Rsamtools)
# library(ngsReports)
# library(magrittr)
# library(statmod)
# library(IHW)
# library(ggside)
# library(msigdbr)
# library(goseq)
# library(tidygraph)
# library(ggraph)
# library(metap)
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
)
# register(MulticoreParam(workers = threads))
source(here::here("workflow", "scripts", "custom_functions.R"))
source(here::here("workflow", "scripts", "table_funs.R"))
```

```{r set-params}
extra_params <- read_yaml(here::here("config", "params.yml"))
config <- read_yaml(here::here("config", "config.yml"))
macs2_path <- here::here("output", "macs2", target)
samples <- file.path(macs2_path, glue("{target}_qc_samples.tsv")) %>% 
  read_tsv() %>% 
  dplyr::filter(treat %in% treat_levels, qc == "pass") %>% 
  mutate(treat = factor(treat, levels = treat_levels)) %>% 
  droplevels()
stopifnot(length(levels(samples$treat)) == 2)
annotation_path <- here::here("output", "annotations")
stopifnot(dir.exists(annotation_path))
out_path <- here::here("output", "differential_signal", target)
if (!dir.exists(out_path)) dir.create(out_path, recursive = TRUE)
```


```{r load-annotations}
sq <- file.path(annotation_path, "seqinfo.rds") %>% read_rds()
exclude_gr <- here::here(
  annotation_path, glue("{unique(samples$input)}_greylist.bed")
) %>% 
  c(here::here(config$external$blacklist)) %>% 
  importPeaks(type = "bed", seqinfo = sq) %>% 
  unlist() %>% 
  GenomicRanges::reduce()

gtf_gene <- read_rds(file.path(annotation_path, "gtf_gene.rds"))
id2gene <- structure(gtf_gene$gene_name, names = gtf_gene$gene_id)

external_features <- GRanges(seqinfo = sq)
if (!is.null(config$external$features)) {
  external_features <- suppressWarnings(
    import.gff(here::here(config$external$features), genome = sq)
  )
  keep_cols <- !vapply(
    mcols(external_features), function(x) all(is.na(x)), logical(1)
  )
  mcols(external_features) <- mcols(external_features)[keep_cols]
}
has_features <- length(external_features) > 0

gene_regions <- file.path(annotation_path, "gene_regions.rds") %>% 
  read_rds()
regions <- vapply(gene_regions, function(x) unique(x$region), character(1))

rna_path <- here::here(config$external$rnaseq)
rnaseq <- tibble(gene_id = character())
if (length(rna_path) > 0) {
  stopifnot(file.exists(rna_path))
  if (str_detect(rna_path, "tsv$")) rnaseq <- read_tsv(rna_path)
  if (str_detect(rna_path, "csv$")) rnaseq <- read_csv(rna_path)
  if (!"gene_id" %in% colnames(rnaseq)) stop("Supplied RNA-Seq data must contain the column 'gene_id'")
  gtf_gene <- subset(gtf_gene, gene_id %in% rnaseq$gene_id)
  rna_lfc_col <- colnames(rnaseq)[str_detect(str_to_lower(colnames(rnaseq)), "logfc")][1]
  rna_fdr_col <- colnames(rnaseq)[str_detect(str_to_lower(colnames(rnaseq)), "fdr|adjp")][1]
}
has_rnaseq <- as.logical(nrow(rnaseq))
## Does this need tidying?
tx_col <- intersect(c("tx_id", "transcript_id"), colnames(rnaseq))
rna_gr_col <- ifelse(length(tx_col) > 0, "transcript_id", "gene_id")
rna_col <- c(tx_col, "gene_id")[[1]]
```

```{r set-graphics}
colours <- read_rds(file.path(annotation_path, "colours.rds")) %>% 
  lapply(unlist)
region_colours <- setNames(colours$regions, regions[names(colours$regions)])
if (has_features)
  feature_colours <- setNames(
    colours$features, str_sep_to_title(names(colours$features))
  )
direction_colours <- colours$direction %>% 
  setNames(str_to_title(names(.))) %>% 
  .[names(.) %in% c("Increased", "Decreased", "Unchanged", "Ambiguous")]
treat_colours <- colours$treat[treat_levels]
fig_dev <- knitr::opts_chunk$get("dev")
fig_type <- fig_dev[[1]]
if (is.null(fig_type)) stop("Couldn't detect figure type")
fig_fun <- match.fun(fig_type)
if (fig_type %in% c("bmp", "jpeg", "png", "tiff")) {
  ## These figure types require dpi & resetting to be inches
  formals(fig_fun)$units <- "in"
  formals(fig_fun)$res <- 300
}
```


```{r load-hic}
hic <- GInteractions()
hic_path <- here::here(config$external$hic)
if (length(hic_path) > 0)
  if (file.exists(hic_path)) {
    has_hic <- TRUE
    hic <- makeGenomicInteractionsFromFile(hic_path, type = "bedpe")
    reg_combs <- expand.grid(regions, regions) %>% 
      as.matrix() %>% 
      apply(
        MARGIN = 1, 
        function(x) {
          x <- sort(factor(x, levels = regions))
          paste(as.character(x), collapse = " - ")
        }
      ) %>% 
      unique()
    hic$regions <- anchors(hic) %>% 
      vapply(
        bestOverlap,
        y = GRangesList(lapply(gene_regions, granges)),
        character(length(hic))
      ) %>% 
      apply(MARGIN = 2, function(x) regions[x]) %>% 
      apply(
        MARGIN = 1, 
        function(x) {
          x <- sort(factor(x, levels = regions))
          paste(as.character(x), collapse = " - ")
        }
      ) %>% 
      factor(levels = reg_combs) %>%
      fct_relabel(
        str_replace_all,
        pattern = "Promoter \\([0-9kbp/\\+-]+\\)", replacement = "Promoter"
      )
    if (has_features) {
      feat_combs <- expand.grid(names(feature_colours), names(feature_colours)) %>% 
        as.matrix() %>% 
        apply(
          MARGIN = 1, 
          function(x) {
            x <- sort(factor(x, levels = names(feature_colours)))
            paste(as.character(x), collapse = " - ")
          }
        ) %>% 
        unique()
      hic$features <- vapply(
        anchors(hic),
        function(x) bestOverlap(
          x, external_features, var = "feature", missing = "no_feature"
        ),
        character(length(hic))
      )  %>% 
        apply(
          MARGIN = 1, 
          function(x) {
            x <- sort(factor(x, levels = names(feature_colours)))
            paste(as.character(x), collapse = " - ")
          }
        ) %>% 
        factor(levels = feat_combs) %>%
        fct_relabel(str_sep_to_title, pattern = "_")
    }
  }
stopifnot(is(hic, "GInteractions"))
seqlevels(hic) <- seqlevels(sq)
seqinfo(hic) <- sq
hic <- hic[!overlapsAny(hic, exclude_gr)]
has_hic <- as.logical(length(hic))
```


```{r define-outputs}
comp <- glue("{target}_{treat_levels[[1]]}_{treat_levels[[2]]}")
all_out <- list(
  results = file.path(out_path, glue("{comp}-differential_signal.rds")),
  csv = file.path(out_path, glue("{comp}-differential_signal.csv.gz")),
  up_regions = file.path(out_path, glue("{comp}-up.bed")),
  down_regions = file.path(out_path, glue("{comp}-down.bed")),
  de_genes = file.path(out_path, glue("{comp}-DE_genes.csv")),
  enrichment = file.path(out_path, glue("{comp}-enrichment.csv")),
  rna_enrichment = file.path(out_path, glue("{comp}-rnaseq_enrichment.csv")),
  renv = here::here("output/envs", glue("{comp}-differential_signal.RData"))
)
## Initialise outputs from RNA-Seq
cmn_diff <- cmn_up <- cmn_down <- tibble(leadingEdge = list())
fig_path <- here::here("docs", "assets", comp)
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE)
```

```{r method-descriptions, echo = FALSE, eval = FALSE}
norm_ref <- case_when(
  norm == "sq" ~ "normalised using Smooth-Quantile normalisation [@HicksSQN2017]",
  norm %in% c("TMM", "TMMwsp") ~ paste("with", norm, "normalisation [@Robinson2010-qp]", collapse = " "),
  norm == "RLE" ~ "with RLE normalisation [@Anders2010-sd].",
  norm == "upperquartile" ~ "with upperquartile normalisation",
  TRUE ~ "with only library-size normalisation"
)
desc_windows <- c(
  sliding = glue(
    "During counting, sliding windows of {win_size}bp were used with a step-size
    defined to ensure each position is covered by at least 3 windows (e.g. 
    {ceiling(win_size/3)}bp). After performing the analysis on the set of 
    sliding windows, final results will be obtained by merging nearby windows 
    using the harmonic-mean p-value [@Wilson2019-ln]. Any windows within 
    {floor(1 + win_size * 2 / 3)}bp of each other are considered as 'nearby' 
    windows suitable for merging."
  ),
  fixed = glue(
    "During counting all ranges were set to be {win_size}bp and centred based on
    the estimated peaks centres determined by macs2. For downstream reporting of 
    results, the original range called as a 'peak' by macs2 is reported.
    "
  )
)[[params$windows]] %>% 
  str_replace_all("\\n", " ") %>% 
  str_replace_all(" +", " ")
desc_method <- c(
  qlf = glue(
    "Quasi-Likelihood Generalised Linear Models [@LunSmythGLMQL2017] on counts {norm_ref}."
  ),
  lt = glue("Limma-Trend [@LawVoom2014] on logCPM values {norm_ref}.")
)[method]
desc_ihw <- list(
  regions = "the previously annotated genomic regions",
  features = "the provided external features",
  targets = "the presence/absence of any other ChIP targets under consideration in any condition",
  none = c()
)[[ihw_method]]
desc_treat <- ifelse(
  fc == 1,
  "The Null Hypothesis (H~0~) is the conventional H~0~ testing for zero against non-zero (i.e. H~A~) change",
  glue(
    "The Null Hypothesis (H~0~) is a range-based hypothesis testing for log fold-change beyond the range &#177;{round(log2(fc), 3)}"
  )
)
```


## Outline

This step of the GRAVI workflow uses a `r win_type` window approach to differential signal with windows of `r win_size`bp.
Counts for all windows were prepared across all `r target` samples as a stand-alone process, with the samples retained in this analysis being those with counts from `r collapseGenes(treat_levels, last = " or ", format = "")`.
This process has produced counts for `r comma(nrow(counts))` ranges.

`r desc_windows`

Differential signal analysis will be performed using `r unname(desc_method)`.
`r desc_treat`
Ranges with an FDR < `r fdr_alpha` will be considered as significant.
`r if (paired_samples) "Samples were denoted as being paired"`

`r glue("Independent Hypothesis Weighting (IHW) [@IgnatiadisIHW2016] is additionally used to improve the power of the results. Under this strategy, p-values are partitioned based on {desc_ihw}, which is considered here to be a statistically independent variable.")`

The workflow depends heavily on the functions implemented in the Bioconductor package [extraChIPs](https://bioconductor.org/packages/release/bioc/html/extraChIPs.html)

<!-- ### Enrichment Analysis -->

<!-- Beyond the simple analysis of differential signal, peaks are mapped to genes and enrichment testing is performed on the following: -->

<!-- 1. Genes mapped to any range with detected `r target` are compared to all genes not mapped to any range -->
<!-- 2. Genes mapped to *all ranges with differential signal* are compared to genes mapped to ranges with no difference in signal -->
<!-- 3. Genes mapped to ranges with *increasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->
<!-- 4. Genes mapped to ranges with *decreasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->

<!-- Enrichment testing is performed using `goseq` [@YoungGoseq2010] with no term accounting for sampling bias (i.e. the Hypergeometric Distribution), *except when comparing genes mapped to any window.* -->
<!-- For this case **only**, gene width is used to capture any sampling bias and Wallenius' Non-Central Hypergeometric Distribution is used. -->
<!-- As RNA-seq data `r ifelse(has_rnaseq, "was", "was not")` provided, the genes considered for enrichment analysis are the `r comma(length(unique(gtf_gene$gene_id)))` `r ifelse(has_rnaseq, "genes considered as detected in the RNA-Seq data", "annotated genes")`. -->

<!-- `r if (has_rnaseq) "### Incorporation with RNA-Seq"` -->

<!-- `r if (has_rnaseq) "Any association between differentially expressed genes and differential signal regions will be assessed using Gene Set Enrichment Analysis [@SubramanianGsea2005], as implemented in the fgsea package [@KorotkevichFgsea2019]. The sets of genes associated with changed signal will be subset by regions and any provided external features, and these novel gene-sets will be used to test for enrichment within the RNA-Seq results. ChIP-seq derived gene-sets will be tested for differential expression using genes ranked directionally and by significance alone. A combined meta-analytic approach using Wilkinson's method will also be used to integration of results from enrichment testing in each standalone dataset."` -->

## Differential Signal Analysis

```{r load-counts}
counts <- read_rds(here::here("data", "counts", glue("{target}_counts.rds")))
counts <- counts[, colData(counts)$treat %in% treat_levels]
stopifnot(ncol(counts) == nrow(samples))
assay_name <- c(qlf = "counts", lt = "logCPM")[method]
n_max <- min(5e5, nrow(counts))
```

### Normalisation Checks

```{r qtest}
qtest <- quantro(assay(counts, "counts"), counts$treat, B = 1e3)
quantro_p <- c(
  perm = quantroPvalPerm(qtest),
  anova = anova(qtest)[["Pr(>F)"]][[1]]
)
desc_quantro <- case_when(
  any(quantro_p < 0.05) & norm == "sq" ~ "These results indicate that the data across treatments is drawn from different distributions and SQ-normalisation may improve the results",
  any(quantro_p < 0.05) & norm != "none" ~ paste(
    "These results indicate that the data across treatments is drawn from different distributions and **", norm, "normalisation will be inappropriate**. *The normalisation method has been reset to library-size.*", collapse = ""
  ),
  TRUE ~ paste(
    "All results from the quantro test support the choice of", 
    ifelse(norm == "none", "library-size", norm), 
    "normalisation.", collapse = " "
  )
)
if (any(quantro_p < 0.05) & norm != "sq") norm <- "none" 
```


Prior to performing analysis, un-normalised logCPM values were tested for equality of distribution using the `quantro` test [@HicksQuantro2015].
Results testing for equality of distribution gave a p-value of `r round(quantro_p[["perm"]], 3)`, and tests for an equality of medians between group returned a p-value of `r round(quantro_p[["anova"]], 3)`.
`r desc_quantro`


```{r normalise-logcpm}
if (norm == "sq") {
  assay_name <- "qsmooth"
  qs <- qsmooth(assay(counts, "logCPM"), group_factor = counts$treat)
  assay(counts, assay_name) <- qsmoothData(qs)
} else {
  dge <- calcNormFactors(counts, method = norm)
  dge$samples$lib.size <- counts$totals
  lcpm <- cpm(dge, log = TRUE) 
  rownames(lcpm) <- NULL
  assay(counts, "logCPM") <- lcpm
}
```

`r if (norm != "sq") "For easier visualisation, the normalised assay *logCPM* was added to the counts object"`
`r if (norm == "sq") glue("The assay {assay_name} was then added to the counts object")`

### Data Inspection {.tabset}

`r if (norm == "sq") "#### QSmooth Weights"` 

```{r plot-sq-weights, eval = norm == "sq", echo = norm == "sq", fig.height = 6, fig.cap = "*Quantile-specific weights used by the Smooth-Quantile normalisation. Low weights indicate signal quantiles which appear to be more specific within a group, whilst higher weights indicate similarity between groups.*"}
qsmoothPlotWeights(
  qs, xLab = "Quantiles", yLab = "Weights", mainLab = "QSmooth Weights"
)
```


#### Densities

```{r plot-qsmooth-densities, eval = norm == "sq", echo = norm == "sq", fig.height = 6, fig.cap = "*Distributions for all analysed windows A) showing logCPM values, and B) qsmooth-normalised logCPM values.*"}
a <- counts %>%
  plotAssayDensities("logCPM", colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_colours) +
  labs(colour = "Treat")
b <- counts %>% 
  plotAssayDensities("qsmooth", colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_colours) +
  labs(colour = "Treat")
a + b + plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
```


```{r plot-logcpm-densities, eval = norm != "sq", echo = norm != "sq", fig.height = 6, fig.cap = "*Distributions for all analysed windows A) showing log1p-transformed raw counts, and B) normalised logCPM values. Whilst the scales on the x-axis will not be comparable, the shapes of the distributions will be.*"}
a <- counts %>%
  plotAssayDensities("counts", colour = "treat", n_max = n_max, trans = "log1p") +
  scale_colour_manual(values = treat_colours) +
  labs(colour = "Treat")
b <- counts %>% 
  plotAssayDensities("logCPM", colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_colours) +
  labs(
    x = "Normalised logCPM", colour = "Treat"
  )
a + b + plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
```

#### RLE

```{r plot-qsmooth-rle, eval = norm == "sq", echo = norm == "sq", fig.height = 6, fig.cap = glue("*RLE plot showing logCPM values before and after SQ normalisation. RLE values were calculated within each treatment group to account for the potentially different signal dynamics of {target}.*")}
a <- counts %>% 
  plotAssayRle(
  "logCPM", fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_colours) +
  labs(x = "Sample", fill = "Treat")
b <- counts %>% 
  plotAssayRle(
  "qsmooth", fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_colours) +
  labs(x = "Sample", fill = "Treat")
a + b + plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
```



```{r plot-rle, eval = norm != "sq", echo = norm != "sq", dev = 'png', fig.height=6, fig.cap = glue("*RLE plot showing logCPM values. RLE values were calculated within each treatment group to account for the potentially different signal dynamics of {target}.*")}
counts %>% 
  plotAssayRle(
  "logCPM", fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_colours) +
  labs(x = "Sample", fill = "Treat")
```


#### PCA

```{r plot-qsmooth-pca, eval = norm == "sq", echo = norm == "sq", fig.height = 5, fig.cap = "*PCA plots for logCPM values A) before and B) after SQ normalisation*"}
a <- plotAssayPCA(
  counts, "logCPM", colour = "treat", label = "label", 
  show_points = FALSE
) +
  scale_colour_manual(values = treat_colours) +
  guides(colour = "none") +
  ggtitle("Pre-Normalisation")
b <- plotAssayPCA(
  counts, "qsmooth", colour = "treat", label = "label",
  show_points = FALSE
) +
  scale_colour_manual(values = treat_colours) +
  guides(colour = "none") +
  ggtitle("Post-Normalisation")
a + b + plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
```

```{r plot-pca, eval = norm != "sq", echo = norm != "sq", fig.height = 5, fig.cap = "*PCA plots for logCPM values *"}
plotAssayPCA(
  counts, "logCPM", colour = "treat", label = "label", 
  show_points = FALSE
) +
  scale_colour_manual(values = treat_colours) +
  guides(colour = "none")
```



### Model Fitting

```{r fit}
fm <- as.formula(
  ifelse(is.null(pair_col), "~treat", paste("~", pair_col, "+treat"))
)
X <- model.matrix(fm, data = colData(counts)) 
colnames(X) <- str_remove_all(colnames(X), "treat")
colData(counts)$design <- X
paired_cors <- block <- txt <- NULL
if (!is.null(pair_col) & method == "lt") {
  ## These will be passed to fitAssayDiff. This is turn passes these to
  ## lmFit, although when method is qlf they will be passed to glmQLFit.
  ## As they are not parameters for that modelling approach, they will be 
  ## ignored
  block <- colData(counts)[[pair_col]]
  set.seed(1e6)
  ind <- sample.int(nrow(counts), n_max, replace = FALSE)
  paired_cors <- duplicateCorrelation(
    object = assay(counts, assay_name)[ind, ],
    design = X,
    block = block
  )$consensus.correlation # This will be ignore in ... if block = NULL
  txt <- glue(
    "During model fitting, data were nested within {{pair_col}} as a potential source of correlation. ",
    "The estimated correlation within replicate samples was $\\hat{\\rho} = {{round(paired_cors, 3)}}$",
    .open = "{{", .close = "}}"
  )
}
fit <- fitAssayDiff(
  counts, assay = assay_name, design = X, coef = treat_levels[[2]],
  method = method, norm = ifelse(norm == "sq", "none", norm), 
  fc = fc, block = block, correlation = paired_cors
) 
pcols <- c("PValue", "p_mu0")
if (win_type == "sliding") {
  results <- mergeByHMP(
    fit, pval = pcols, merge_within = floor(1 + 2 * win_size / 3),
    hm_pre = ""
  ) %>%
    plyranges::select(
      starts_with("n_"), keyval_range, starts_with("log"), any_of(pcols),
      FDR = PValue_fdr
    ) %>% 
    addDiffStatus(alpha = fdr_alpha)
} else {
  results <- rowRanges(fit) %>% addDiffStatus(alpha = fdr_alpha)
}
n_sig <- sum(results$FDR < fdr_alpha)
```

`r txt`

# MODIFY IHW MODULES FIRST (using full data)

### Independent Hypothesis Weighting {.tabset}

`r ifelse(ihw_method == "none", "No independent Hypothesis Weighting was specified", "")`

```{r ihw, eval = ihw_method != "none", echo = TRUE, child = here::here(glue("workflow/modules/ihw_{ihw_method}.Rmd"))}
```


### Mapping Windows To Genes

```{r map-to-regions}
results$region <- bestOverlap(results, unlist(gene_regions), var = "region") %>% 
  factor(levels = regions)
feat_prom <- GRanges()
feat_enh <- GRanges()
if (has_features) {
  results <- results %>% 
    mutate(
      feature = bestOverlap(
        ., external_features, "feature", missing = "no_feature"
      ) %>% 
        factor(levels = names(colours$features)) %>% 
        fct_relabel(str_sep_to_title)
    )
  if ("feature" %in% colnames(mcols(external_features))) {
    feat_prom <- external_features %>%
      subset(str_detect(feature, "[Pp]rom")) %>%
      granges()
    feat_enh <- external_features %>%
      subset(str_detect(feature, "[Ee]nhanc")) %>%
      granges()
  }
}
results <- results %>%
  mapByFeature(
    genes = gtf_gene, 
    prom = reduce(c(feat_prom, granges(gene_regions$promoter))),
    enh = feat_enh,
    gi = hic, 
    gr2gene = extra_params$mapping$gr2gene,
    prom2gene = extra_params$mapping$prom2gene,
    enh2gene = extra_params$mapping$enh2gene,
    gi2gene = extra_params$mapping$gi2gene
  )
```

In addition to statistical analysis, all ranges were first mapped to the gene-centric region with the largest overlap.
`r ifelse(has_features, "Ranges were then mapped to the external features provided in the same manner", "")`, followed by mapping to all annotated genes.

During mapping to genes, promoters were defined as the union of all potential promoter regions defined earlier, and any external features which were detected as promoters using string matching in the `feature` column.
`r ifelse(has_features, glue("Enhancers were any regions defined in {basename(config$external$features)} as enhancers."), glue(""))`
`r ifelse(length(hic) > 0, glue("A set of {comma(length(hic))} HiC-interactions was also included to enable the use of long-range interactions during the mappig process."), "")`

These features were used to map ranges to features using the process defined in the function `extraChIPs::mapByFeature()`:

1. Ranges *overlapping a promoter* are assigned to genes `r ifelse(extra_params$mapping$prom2gene == 0, "directly overlapping", paste("within", extra_params$mapping$prom2gene, "bp of"))` that specific promoter
2. Ranges *overlapping an enhancer* are assigned to all genes `r ifelse(extra_params$mapping$enh2gene == 0, "directly overlapping", paste("within", round(extra_params$mapping$enh2gene/1e3, 1), "kb of"))` the enhancer
3. Ranges *overlapping a long-range interaction* are assigned to all genes `r ifelse(extra_params$mapping$gi2gene == 0, "directly overlapping", paste("within", round(extra_params$mapping$gi2gene/1e3, 1), "kb of"))` either end of the interaction
4. Ranges with *no gene assignment from the previous steps* are assigned to all overlapping genes, or the nearest gene within `r round(extra_params$mapping$gr2gene/1e3, 1)`kb

Notably, genes are only passed to step 4 if no gene assignment has been made in steps 1, 2 or 3.
For visualisation purposes, only genes which were considered as detected in any provided RNA-Seq data will be shown as the mapping targets.

## Results 


### Result Tables {.tabset}

```{r tbl-setup}
n_unch <- sum(results$status == "Unchanged")
n_windows <- length(results)
tbl_cols <- list(
  Region = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Feature = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Up = colDef(
    cell = function(value) comma(value, 1),
    style = function(value) {
      normalized <- value / (n_windows - n_unch)
      color <- up_col(normalized)
      list(background = color)
    },
    footer = function(values) htmltools::tags$b(comma(sum(values)))
  ),
  Down = colDef(
    cell = function(value) comma(value, 1),
    style = function(value) {
      normalized <- value / (n_windows - n_unch)
      color <- down_col(normalized)
      list(background = color)
    },
    footer = function(values) htmltools::tags$b(comma(sum(values)))
  ),
  Ambiguous = colDef(
    cell = function(value) comma(value, 1),
    style = function(value) {
      normalized <- value / (n_windows - n_unch)
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = function(values) htmltools::tags$b(comma(sum(values)))
  ),
  Unchanged = colDef(
    cell = function(value) comma(value, 1),
    style = function(value) {
      normalized <- value / n_windows
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = function(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Changed` = colDef(
    cell = function(value) percent(value, 0.1),
    style = function(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    align = "right",
    footer = htmltools::tags$b(
      percent(sum(1 - n_unch / n_windows), 0.1)
    )
  ),
  Total = colDef(
    cell = function(value) comma(value, 1),
    style = function(value) {
      bar_style(width = value / n_windows, fill = "#B3B3B3", align = "right")
    },
    align = "right",
    footer = function(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Of All Windows` = colDef(
    style = function(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = colFormat(digits = 2, percent = TRUE)
  )
)
```


#### Overall Results

```{r tab-overall}
tbl <- results %>% 
  mutate(w = width) %>% 
  as_tibble() %>% 
  summarise(
    n = dplyr::n(), 
    width = median(w),
    logCPM = median(logCPM),
    .by = all_of("status")
  ) %>% 
  mutate(`%` = n / sum(n)) %>% 
  dplyr::select(status, n, `%`, everything()) %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      status = colDef(
        name = "Status", maxWidth = 150,
        footer = htmltools::tags$b("Overall")
      ),
      n = colDef(
        name = "Nbr of Windows", maxWidth = 150, format = colFormat(separators = TRUE),
        footer = htmltools::tags$b(comma(length(results)))
      ),
      width = colDef(
        name = "Median Width (bp)", format = colFormat(digits = 1),
        footer = htmltools::tags$b(round(median(width(results)), 1)),
        maxWidth = 200
      ),
      `%` = colDef(
        name = "% Total Windows", format = colFormat(percent = TRUE, digits = 1),
        style = function(value) bar_style(width = value, align = "right"),
        maxWidth = 150
      ),
      logCPM = colDef(
        name = "Median Signal (logCPM)",
        format = colFormat(digits = 3),
        maxWidth = 200,
        footer = htmltools::tags$b(
          round(median(results$logCPM), 3)
        )
      )
    )
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison."
  )
)
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```


#### Summary By Region

```{r tab-res-by-region}
df <- results %>% 
  select(status, FDR, region) %>% 
  as_tibble() %>% 
  group_by(region, status) %>% 
  summarise(n = dplyr::n(), .groups = "drop") %>% 
  complete(region, status, fill = list(n = 0)) %>% 
  group_by(region) %>% 
  mutate(Total = sum(n)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    `% Of All Windows` = Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(region) %>% 
  dplyr::select(
    Region = region,
    any_of(names(direction_colours)),
    `% Changed`, Total, `% Of All Windows`
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which genomic region contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = function(values) htmltools::tags$b(comma(sum(values)))
    ),
    fullWidth = TRUE
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(has_features, "#### Summary By Feature", "")`

```{r tab-res-by-feature, echo = has_features, eval = has_features}
df <- results %>% 
  select(status, FDR, feature) %>% 
  as_tibble() %>% 
  group_by(feature, status) %>% 
  tally() %>% 
  ungroup() %>% 
  complete(feature, status, fill = list(n = 0)) %>% 
  mutate(Total = sum(n), .by = all_of("feature")) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    `% Of All Windows` = Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(feature) %>% 
  dplyr::select(
    Feature = feature,
    any_of(names(direction_colours)),
    `% Changed`, Total, `% Of All Windows`
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which external feature contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = function(values) htmltools::tags$b(comma(sum(values)))
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```


#### Most Highly Ranked

```{r tab-highly-ranked}
show_n <- min(200, length(results))
scaling_vals <- list(
  logFC = c(-1, 1)*max(abs(results$logFC)),
  logCPM = range(results$logCPM),
  Width = max(width(results))
)
cp <- htmltools::em(
  glue(
    "The {show_n} most highly-ranked ranges by FDR, with {comma(n_sig)}", 
    " showing evidence of changed {target} signal. ",
    "Regions were assigned based on which genomic region showed the largest ",
    "overlap with the range being analysed. ",
    ifelse(
      has_features, 
      glue("Features are as provided in the file {basename(config$external$features)}. "),
      glue("")
    ),
    "For ranges mapped to large numbers of genes, hovering a mouse over the ", 
    "cell will reveal the full set of genes. ",
    ifelse(
      has_rnaseq,
      "Only genes considered as detected in the RNA-Seq data are included. ",
      ""
    )
  )
)
fs <- 12
tbl <- results %>%
  mutate(w = width) %>% 
  arrange(FDR) %>% 
  plyranges::slice(seq_len(show_n)) %>% 
  plyranges::select(
    w, starts_with("log"), FDR, 
    Region = region, any_of("feature"), Genes = gene_name
  ) %>% 
  as_tibble() %>% 
  dplyr::rename(Range = range, `Width (bp)` = w) %>% 
  rename_with(\(x) str_replace_all(x, "feature", "Feature")) %>% 
  mutate(Genes = vapply(Genes, paste, character(1), collapse = "; ")) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 20, 50, show_n), defaultPageSize = 10,
    borderless  = TRUE,
    columns = list(
      Range = colDef(
        minWidth = 10 * fs,
        cell = function(value) {
          str_replace_all(value, ":", ": ")
        }
      ),
      `Width (bp)` = colDef(
        style = function(value) {
          x <- value / scaling_vals$Width
          colour <- expr_col(x)
          list(
            background = colour, 
            borderRight = "1px solid rgba(0, 0, 0, 0.1)"
          )
        },
        maxWidth = 5 * fs
      ),
      logCPM = colDef(
        cell = function(value) round(value, 2),
        style = function(value) {
          x <- (value - min(scaling_vals$logCPM)) / diff(scaling_vals$logCPM)
          colour = expr_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      logFC = colDef(
        cell = function(value) round(value, 2),
        style = function(value) {
          x <- (value - min(scaling_vals$logFC)) / diff(scaling_vals$logFC)
          colour <- lfc_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      FDR = colDef(
        cell = function(value) {
          fmt <- ifelse(value < 0.01, "%.2e", "%.3f")
          sprintf(fmt, value)
        },
        style = function(value) {
          text_colour <- ifelse(value < fdr_alpha, "black", direction_colours[["Unchanged"]])
          list(color = text_colour, borderRight = "1px solid rgba(0, 0, 0, 0.1)")
        },
        maxWidth = 5.5 * fs
      ),
      Region = colDef(maxWidth = 150),
      Genes = colDef(
        cell = function(value) with_tooltip(value, width = ifelse(has_features, 30, 60)),
        minWidth = 11 * fs
      )
    ),
    theme = reactableTheme(style = list(fontSize = fs))
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```



### Summary Plots {.tabset}

```{r make-heatmaps}
profile_width <- ifelse(target == "H3K27ac", 1e4, 5e3)
n_bins <- 100
bwfl <- file.path(
    macs2_path, glue("{target}_{treat_levels}_merged_treat_pileup.bw")
  ) %>% 
  BigWigFileList() %>% 
  setNames(treat_levels) 
sig_ranges <- results %>% 
  filter(FDR < fdr_alpha) %>%
  splitAsList(f = .$status) %>% 
  .[vapply(., length, integer(1)) > 0] 
if (win_type == "sliding") {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "keyval_range")
} else {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "centred_peak")
}
sig_profiles <- lapply(sig_ranges, function(x) NULL)
heat_max <- 1e4
for (i in names(sig_profiles)) {
  ## Restrict to 20,000. Plots work poorly above this number.
  ## Randomly sample
  set.seed(threads)
  temp_gr <- granges(sig_ranges[[i]])
  n <- length(temp_gr)
  if (n > heat_max) temp_gr <- temp_gr[sort(sample.int(n, heat_max))]
  sig_profiles[[i]] <- getProfileData(
    bwfl, temp_gr, upstream = profile_width / 2, bins = n_bins,
    BPPARAM = bpparam()
  )
  rm(temp_gr)
}
profile_heatmaps <- list()
if (length(sig_profiles) > 0) {
  profile_heatmaps <- sig_profiles %>% 
    parallel::mclapply(
      plotProfileHeatmap,
      profileCol = "profile_data", 
      colour = "name",
      xLab = "Distance from Centre (kb)",
      fillLab = "logCPM",
      labelFunX = comma_format(accuracy = 0.1, scale = 1e-3),
      mc.cores = max(1, length(sig_profiles))
    ) 
  fill_range <- profile_heatmaps %>% 
    lapply(function(x) x$data[,"score"]) %>% 
    unlist() %>%
    range()
  sidey_range <- profile_heatmaps %>% 
    lapply(function(x) x$layers[[3]]$data$y) %>% 
    unlist() %>% 
    range()
  profile_heatmaps <- profile_heatmaps %>% 
    lapply(
      function(x) {
        suppressWarnings(
          x + 
            scale_fill_gradientn(colours = colours$heatmaps, limits = fill_range) +
            scale_xsidey_continuous(limits = sidey_range) +
            scale_colour_manual(values = treat_colours) +
            labs(
              x = "Distance from Centre (kb)",
              fill = "logCPM", 
              colour = "Treat"
            ) +
            theme(
              strip.text.y = element_text(angle = 0)
            )
        )
      }
    )
}
```


#### MA Plot

```{r plot-ma, fig.cap = glue("*MA plot showing the status of each range under consideration. The two most extreme regions are labelled by region and any associated genes, whilst the overall pattern of association between signal level (logCPM) and changed signal (logFC) is shown as the blue curve.*")}
if (!"Ambiguous" %in% levels(results$status)) 
  direction_colours <- direction_colours[names(direction_colours) != "Ambiguous"]
results %>% 
  as_tibble() %>%
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, bs = "cs")) +
  geom_hline(yintercept = 0) +
  geom_label_repel(
    aes(y = logFC, label = annot, colour = status),
    data = . %>%
      dplyr::filter(FDR < fdr_alpha) %>% 
      arrange(desc(abs(logFC))) %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(
    x = "Ave Signal (logCPM)", colour = "Status"
  ) 
```


#### Volcano Plot

```{r plot-volcano, fig.cap = glue("*Volcano plot showing regions with evidence of differential {target} signal. The most significant regions are labelled along with any genes these regions are mapped to.*")}
results %>% 
  as_tibble() %>% 
  ggplot(aes(logFC, -log10(PValue))) +
  geom_point(aes(colour = status), alpha = 0.6) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data = . %>%
      arrange(PValue) %>%
      dplyr::filter(FDR < fdr_alpha) %>% 
      droplevels() %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(
    x = "logFC",
    y = expression(paste(-log[10], "p")),
    colour = "Status"
  )
```



```{r plot-all-profile-heatmaps, echo = FALSE}
htmltools::tagList(
  mclapply(
    seq_along(profile_heatmaps),
    function(i) {
      ## Export the image
      nm <- str_to_lower(names(profile_heatmaps)[[i]])
      img_out <- file.path(
        fig_path,
        glue("{nm}_profile_heatmap.{fig_type}")
      )
      n_ranges <- length(profile_heatmaps[[i]])
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = min(
          3.5 + knitr::opts_current$get("fig.height") * n_ranges / 1.5e3, 
          10
        )
      )
      print(profile_heatmaps[[i]])
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(
        glue(
          "
        {n_ranges} ranges were defined as showing {nm} signal. Heatmaps were 
        restricted to a maximum of {comma(heat_max)} ranges. Values shown are 
        log2 CPM taking the SPMR-based bigwig files produced by macs callpeak.
        "
        )
      )
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(
            glue("Profile Heatmaps: {str_to_title(nm)} Signal")
          ),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


#### Results By Chromosome

```{r plot-res-by-chromosome, fig.cap = "*Results for differential signal separated by chromosome. Results are scaled by chromosome length and shown as windows / Mb, although the distributions of windows will be unevenly spaced.*"}
results %>% 
  select(status) %>% 
  as_tibble(rangeAsChar = FALSE) %>% 
  mutate(
    merge_status = fct_collapse(
      status,
      `Ambiguous/Unchanged` = intersect(c("Ambiguous", "Unchanged"), levels(status))
    )
  ) %>% 
  group_by(seqnames, merge_status) %>% 
  summarise(n = dplyr::n(), .groups = "drop") %>% 
  left_join(as_tibble(sq)) %>%
  mutate(
    p = 1e6 * n / seqlengths,
    seqnames = fct(seqnames, levels = seqlevels(sq))
  ) %>% 
  ggplot(aes(seqnames, y = p, fill = merge_status)) +
  geom_col() +
  facet_grid(merge_status~., scales = "free_y") +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  scale_fill_manual(values =  direction_colours) +
  labs(x = "Chromosome", y = "Windows / Mb", fill = "Status")
```

#### Signal By Region

```{r boxplot-regions, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each genomic region.*"}
results %>% 
  select(logCPM, logFC, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    ),
  ) %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(x, value, fill = region)) +
  geom_boxplot() +
  facet_grid(rows = vars(name), scales = "free", switch = "y") +
  scale_fill_manual(values = region_colours) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r if (n_sig > 0) "#### Differential Signal By Region"`

```{r plot-db-regions, eval = n_sig > 0, echo = n_sig > 0, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all genomic regions.*")}
results %>% 
  dplyr::filter(FDR < fdr_alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Region = region) %>% 
  droplevels() %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Region", min_p = 0.02,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = region_colours
  )
```

`r ifelse(has_features, "#### Signal By Feature", "")`

```{r boxplot-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each external features.*"}
results %>% 
  select(logCPM, logFC, feature) %>% 
  as_tibble() %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(feature, value, fill = feature)) +
  geom_boxplot() +
  facet_grid(
    name~., scales = "free", labeller = facet_labeller, switch = "y"
  ) +
  scale_fill_manual(values = feature_colours) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r ifelse(has_features, "#### Differential Signal By Feature", "")`

```{r plot-db-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all external features.*")}
results %>% 
  dplyr::filter(FDR < fdr_alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Feature = feature) %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Feature", min_p = 0.01,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = feature_colours
  )
```


### Inspection of Top-Ranked Regions {.tabset}

```{r get-cmn-plot-objects}
cb <- config$genome$build %>% 
  str_to_lower() %>% 
  paste0(".cytobands") 
data(list = cb)
bands_df <- get(cb)
stopifnot(
  colnames(bands_df) == c("chrom", "chromStart", "chromEnd", "name", "gieStain")
)
trans_models <- file.path(annotation_path, "trans_models.rds") %>% 
  read_rds() 
```


```{r grl-to-plot}
## Define a GRL with the key ranges.
## Then we can step through it & make all of the requisite plots
grl_to_plot <- GRangesList(
  
  top_inc_by_fdr = results %>% 
    filter(logFC > 0, FDR < fdr_alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_inc_by_lfc = filter(results, logFC == max(logFC)),
  
  top_dec_by_fdr = results %>% 
    filter(logFC < 0, FDR < fdr_alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_dec_by_lfc = filter(results, logFC == min(logFC))
  
) %>% 
  unlist() %>% 
  .[!duplicated(.)] %>%
  splitAsList(names(.)) %>% 
  lapply(setNames, c()) %>% 
  lapply(function(x) x[1]) %>%
  GRangesList()
```


```{r prepare-plot-objects}
## The coverage
bwfl <- list2(
  "{target}" := file.path(
    macs2_path, glue("{target}_{treat_levels}_merged_treat_pileup.bw")
  ) %>% 
    BigWigFileList() %>% 
    setNames(treat_levels)
)
line_col <- list2("{target}" := treat_colours)
## Coverage annotations
annot <- results %>% 
  splitAsList(.$status) %>% 
  .[vapply(., length, integer(1)) > 0] %>% 
  endoapply(granges) %>% 
  list() %>% 
  setNames(target)
## Coverage y-limits
ind <- counts %>% 
  assay("counts") %>% 
  apply(MARGIN = 2, which.max) %>%
  unique()
max_ranges <- rowRanges(counts[ind])
y_lim <- bwfl[[target]] %>%
  lapply(import.bw, which = max_ranges) %>%
  lapply(function(x) c(0, max(x$score))) %>% 
  unlist() %>% 
  range() %>% 
  list() %>% 
  setNames(target)

## The features track
feat_gr <- gene_regions %>% 
  lapply(granges) %>% 
  GRangesList()
feat_col_hfgc <- colours$regions
if (has_features) {
  feat_gr <- list(Regions = feat_gr)
  feat_gr$Features <- splitAsList(external_features, external_features$feature)
  feat_col_hfgc <- list(
    Regions = unlist(colours$regions),
    Features = unlist(colours$features)
  )
}

## The genes track
hfgc_genes <- trans_models
gene_col <- "grey"
if (has_rnaseq) {
  if (!is.na(rna_lfc_col) & !is.na(rna_fdr_col)) {
    hfgc_genes <- trans_models %>% 
      mutate(
        status = case_when(
          !gene %in% rnaseq$gene_id ~ "Undetected",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) > 0, !!sym(rna_fdr_col) < fdr_alpha
          )$gene_id ~ "Up",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) < 0, !!sym(rna_fdr_col) < fdr_alpha
          )$gene_id ~ "Down",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_fdr_col) >= fdr_alpha
          )$gene_id ~ "Unchanged",
        )
      ) %>% 
      splitAsList(.$status) %>% 
      lapply(select, -status) %>% 
      GRangesList()
    gene_col <- colours$direction %>% 
      setNames(str_to_title(names(.)))
  }
}

## External Coverage (Optional)
if (!is.null(config$external$coverage)) {
  ext_cov_path <- config$external$coverage %>% 
    lapply(unlist) %>% 
    lapply(function(x) setNames(here::here(x), names(x)))
  bwfl <- c(
    bwfl[target],
    lapply(ext_cov_path, function(x) BigWigFileList(x) %>% setNames(names(x)))
  )
  line_col <- c(
    line_col[target],
    ext_cov_path %>% 
      lapply(
        function(x) {
          missing <- setdiff(names(x), names(colours$treat))
          cmn <- intersect(names(x), names(colours$treat))
          col <- setNames(character(length(names(x))), names(x))
          if (length(cmn) > 0) col[cmn] <- colours$treat[cmn]
          if (length(missing) > 0) 
            col[missing] <- hcl.colors(
              max(5, length(missing)), "Zissou 1")[seq_along(missing)]
          col
        }
      )
  )
  
  y_ranges <- grl_to_plot %>% 
    unlist() %>% 
    granges() %>% 
    resize(w = 10 * width(.), fix = 'center')
  
  y_lim <- c(
    y_lim[target],
    bwfl[names(bwfl) != target] %>% 
      lapply(
        function(x) {
          GRangesList(lapply(x, import.bw, which = y_ranges)) %>% 
            unlist() %>% 
            filter(score == max(score)) %>% 
            mcols() %>% 
            .[["score"]] %>% 
            c(0) %>% 
            range()
        }
      )
  )
  
}
```



```{r plot-all-top-ranges}
makeCaption <- function(.gr) {
  if (is.null(.gr)) return(NULL)
  dir <- str_to_lower(.gr$status)
  reg <- case_when(
    str_detect(.gr$region, "Inter") ~ paste("an", .gr$region, "region"),
    str_detect(.gr$region, "Upstream") ~ paste("an", .gr$region),
    str_detect(.gr$region, "(Ex|Intr)on") ~ paste("an", .gr$region),
    str_detect(.gr$region, "^Prom") ~ paste("a", .gr$region)
  )
  feat <- c()
  if (has_features) feat <- case_when(
    str_detect(.gr$feature, "^[AEIOU]") ~ paste("an", .gr$feature),
    !str_detect(.gr$feature, "^[AEIOU]") ~ paste("a", .gr$feature)
  )
  gn <- unlist(.gr$gene_name)
  fdr <- .gr$FDR
  fdr <- ifelse(
    fdr < 0.001, sprintf('%.2e', fdr), sprintf('%.3f', fdr)
  )
  cp <- c(
    glue(
      "*The {width(.gr)}bp region showing {dir} {target} signal in response to ", 
      "{treat_levels[[2]]} treatment (FDR = {fdr}). ",
      "The range mostly overlapped with {reg}, with all ",
      "defined regions shown as a contiguous bar in the upper panel. ",
      ifelse(
        has_features,
        glue(
          "Using the features supplied in {basename(config$external$features)}, ",
          "this mostly overlapped {feat}, shown as a separate block ",
          "with the gene-centric regions. "
        ),
        glue("")
      ),
    ),
    ifelse(
      .gr$overlaps_ref,
      paste(
        "A union peak overlapping this region was identified by",
        "`macs2 callpeak` when using merged samples."
      ),
      "No union peak was identified using `macs2 callpeak`."
    ),
    ifelse(
      length(gn) > 0,
      paste0(
        "Using the above mapping strategy, this range is likely to regulate ",
        collapseGenes(gn, format = ""), "."
      ),
      "No genes were able to be assigned to this region."
    ),
    paste(
      "For each sample, the y-axis limits represent the values from the window", 
      "with the highest signal.*"
    )
  )
  paste(cp, collapse = " ")
}
htmltools::tagList(
  mclapply(
    seq_along(grl_to_plot),
    function(i) {
      ## Export the image
      nm <- str_to_lower(names(grl_to_plot)[[i]])
      tag <- nm %>% 
        str_replace_all("_", " ") %>%
        str_to_title() %>% 
        str_replace_all("(Dec|Inc)", "\\1reased Range (") %>% 
        str_replace_all("Fdr", "FDR") %>% 
        str_replace_all("Lfc", "logFC") %>% 
        str_replace_all("\\( (.+)$", "(\\1)")
      img_out <- file.path(fig_path, glue("{nm}.{fig_type}"))
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = knitr::opts_current$get("fig.height")
      )
      plotHFGC(
        grl_to_plot[[i]],
        hic = hic,
        features = feat_gr,featcol = feat_col_hfgc, featsize = 1 + has_features,
        genes = hfgc_genes, genecol = gene_col,
        coverage = bwfl, linecol = line_col,
        annotation = annot, 
        annotcol = direction_colours,
        cytobands = bands_df,
        zoom = 10,
        max = 8e3,
        ylim = y_lim,
        col.title = "black", background.title = "white", showAxis = FALSE,
        rotation.title = 90
      )
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(makeCaption(grl_to_plot[[i]]))
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(tag),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


# RESUME FROM HERE

## Enrichment Testing 

```{r msigdb}
min_gs_size <- extra_params$enrichment$min_size
if (is.null(min_gs_size) | is.na(min_gs_size)) min_gs_size <- 0
max_gs_size <- extra_params$enrichment$max_size
if (is.null(max_gs_size) | is.na(max_gs_size)) max_gs_size <- Inf
min_sig <- extra_params$enrichment$min_sig
if (is.null(min_sig) | is.na(min_sig)) min_sig <- 1
msigdb <- msigdbr(species = "Homo sapiens") %>% 
  dplyr::filter(
    gs_cat %in% unlist(extra_params$enrichment$msigdb$gs_cat) |
      gs_subcat %in% unlist(extra_params$enrichment$msigdb$gs_subcat),
    str_detect(ensembl_gene, "^E")
  ) %>% 
  dplyr::rename(gene_id = ensembl_gene, gene_name = gene_symbol) %>% # For easier integration 
  dplyr::select(-starts_with("human"), -contains("entrez")) %>% 
  dplyr::filter(gene_id %in% gtf_gene$gene_id) %>% 
  mutate(gs_url = str_extract(gs_url, "^[^|]+")) %>% 
  group_by(gs_name) %>% 
  mutate(n = dplyr::n()) %>% 
  ungroup() %>% 
  dplyr::filter(n >= min_gs_size, n < max_gs_size) 
gs_by_gsid <- msigdb %>% 
  split(.$gs_name) %>% 
  lapply(pull, "gene_id") %>% 
  lapply(unique)
gs_by_geneid <- msigdb %>% 
  split(.$gene_id) %>% 
  lapply(pull, "gs_name") %>% 
  lapply(unique)
gs_url <- msigdb %>% 
  distinct(gs_name, gs_url) %>%
  mutate(
    gs_url = ifelse(
      gs_url == "", "
      http://www.gsea-msigdb.org/gsea/msigdb/collections.jsp",
      gs_url
    )
  ) %>% 
  with(setNames(gs_url, gs_name))

min_network_size <- extra_params$networks$min_size
if (is.null(min_network_size) | is.na(min_network_size))
  min_network_size <- 2

max_network_size <- extra_params$networks$max_size
if (is.null(max_network_size) | is.na(max_network_size))
  max_network_size <- Inf

max_network_dist <- extra_params$networks$max_distance
if (is.null(max_network_dist) | is.na(max_network_dist))
  max_network_dist <- 1

net_layout <- extra_params$networks$layout
enrich_alpha <- extra_params$enrichment$alpha
adj_method <- match.arg(extra_params$enrichment$adj, p.adjust.methods)
adj_desc <- case_when(
  p.adjust.methods %in% c("fdr", "BH") ~ "the Benjamini-Hochberg FDR",
  p.adjust.methods %in% c("BY") ~ "the Benjamini-Yekutieli FDR",
  p.adjust.methods %in% c("bonferroni") ~ "the Bonferroni",
  p.adjust.methods %in% c("holm") ~ "Holm's",
  p.adjust.methods %in% c("hommel") ~ "Hommel's",
  p.adjust.methods %in% c("hochberg") ~ "Hochberg's",
  p.adjust.methods %in% c("none") ~ "no"
) %>% 
  setNames(p.adjust.methods)
mapped_ids <- results %>%
  as_tibble() %>% 
  dplyr::select(status, gene_id) %>%
  unnest(gene_id) %>%
  group_by(gene_id) %>%
  summarise(
    up = any(status == "Up"), 
    down = any(status == "Down"), 
    n_peaks = dplyr::n(),
    .groups = "drop"
  )
```

As an initial exploration, the retained windows were compared to pre-defined gene-sets.
These were taken from the `MSigDB` database and the gene-sets used for enrichment testing were restricted to only include those with between `r min_gs_size` and `r max_gs_size` genes.

```{r tbl-msigdb}
msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name) %>%
  group_by(gs_cat, gs_subcat) %>% 
  summarise(`Gene Sets` = dplyr::n(),.groups = "drop") %>% 
  dplyr::rename(Category = gs_cat, `Sub-Category` = gs_subcat) %>% 
  mutate(
    Description = case_when(
      Category == "H" ~ "Hallmark Gene-Sets",
      Category == "C1" ~ "Positional Gene Sets",
      Category == "C2" ~ str_replace_all(`Sub-Category`, "CP:(.+)", "Curated Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "TFT") ~ str_replace_all(`Sub-Category`, "TFT:(.+)", "Transcription Factor Target Prediction Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "MIR") ~ str_replace_all(`Sub-Category`, "MIR:(.+)", "microRNA Target Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "CGN") ~ "Cancer Gene Neighbourhoods",
      str_detect(`Sub-Category`, "CM") ~ "Cancer Modules",
      str_detect(`Sub-Category`, "GO:BP") ~ "Gene Ontology: Bological Process",
      str_detect(`Sub-Category`, "GO:MF") ~ "Gene Ontology: Molecular Function",
      str_detect(`Sub-Category`, "GO:CC") ~ "Gene Ontology: Cellular Component",
      str_detect(`Sub-Category`, "HPO") ~ "Human Phenotype Ontology",
      Category == "C6" ~ "Oncogenic Signature Gene Sets",
      `Sub-Category` == "IMMUNESIGDB" ~ "ImmuneSigDB Gene Sets",
      `Sub-Category` == "VAX" ~ "Vaccine Response Gene Sets",
      Category == "C8" ~ "Cell Type Signature Gene Sets"
    ),
    Category = factor(Category, levels = c("H", paste0("C", 1:8)))
  ) %>% 
  droplevels() %>% 
  arrange(Category) %>% 
  pander(
    justify = "llrl", 
    caption = "*Summary of Gene-Sets used for Enrichment Testing*"
  )
```

Retained windows were tested for enrichment of these gene-sets using:

1. Any window mapped to a gene from these gene-sets
2. Any window with evidence of differential signal mapped to a gene from these gene-sets

In the first case, mapped genes were tested for enrichment against all annotated genes, or all detected genes if RNA-Seq data was provided.
In the second case, i.e. Differential Signal Windows, the control set of genes were those mapped to a window (i.e. those test set from step 1).
All adjusted p-values below are calculated using `r adj_desc[[adj_method]]` adjustment.
After adjustment, any enriched gene-sets with fewer than `r min_sig` mapped genes were excluded as being uninformative.

If `r min_network_size` or more gene-sets were considered to be enriched, a network plot will be produced for that specific analysis, with network sizes capped at `r max_network_size`.
The distances between gene-sets were calculated using the overlap coefficient (OC).
Gene-sets with a large overlap will thus be given small distances and in the case of a complete overlap ($OC = 1$) the only most highly ranked gene-set was retained.
Gene-set (i.e. node) pairs with a distance > `r max_network_dist` will not have edges drawn between them and edge width also corresponds to the distance between nodes with closely related nodes having thicker edges.
All network plots were generated using the `r net_layout` layout algorithm.

### Windows With Detected `r target` {.tabset}


```{r goseq-mapped, fig.show='hide'}
pwf_mapped <- gtf_gene %>% 
  mutate(w = width(.)) %>% 
  as_tibble() %>% 
  dplyr::select(gene_id, w) %>% 
  arrange(desc(w)) %>% 
  distinct(gene_id, .keep_all = TRUE) %>% 
  mutate(mapped = gene_id %in% unlist(results$gene_id)) %>% 
  with(
    nullp(
      structure(mapped, names = gene_id),
      genome = config$genome$build,
      bias.data = log10(w),
      plot.fit = TRUE
    )
  )
goseq_mapped <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(pwf_mapped$DEgenes) > 0) {
  goseq_mapped <- goseq(
    pwf_mapped, config$genome$build, gene2cat = gs_by_geneid
  ) %>% 
    dplyr::rename(gs_name = category, pval = over_represented_pvalue) %>% 
    dplyr::select(-starts_with("under")) %>% 
    as_tibble() %>% 
    arrange(pval) %>% 
    dplyr::filter(numDEInCat > 0) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_mapped <- sum(goseq_mapped$adj_p < enrich_alpha) > 0
tg_mapped <- make_tbl_graph(
  goseq_mapped, 
  gs = gs_by_gsid %>% 
    lapply(intersect, rownames(subset(pwf_mapped, DEgenes))) %>% 
    .[vapply(., length, integer(1)) > 0]
)
plot_network_mapped <- length(tg_mapped) >= min_network_size
```

`r ifelse(!any_goseq_mapped, "No enrichment was found amongst genes mapped to any window", "#### Results Table")`


```{r tbl-goseq-mapped, eval = any_goseq_mapped, echo = any_goseq_mapped}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_mapped$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the merged windows with detectable {target} 
        signal. Genes mapped to a merged window were compared to those not 
        mapped to any merged windows. Gene width was used to capture any 
        gene-level sampling bias.
        "
      )
    )
  )
)
tbl <- goseq_mapped %>%
  dplyr::filter(adj_p < enrich_alpha) %>% 
  left_join(
    dplyr::select(msigdb, gs_name, gene_name, gene_id, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  dplyr::filter(gene_id %in% unlist(results$gene_id)) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  mutate(
    gene_name = vapply(gene_name, paste, character(1), collapse = "; "),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, 
    p = pval, adj_p, 
    `Mapped Genes` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = function(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          str_replace_all(value, "_", " ")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = function(value) with_tooltip(value, width = 100)
      ),
      numDEInCat = colDef(name = "Total Mapped", maxWidth = 80),
      numInCat = colDef(
        name = "Gene Set Size",
        maxWidth = 80,
        cell = function(value) comma(value, 1)
      ),
      "%" = colDef(
        name = "% Mapped",
        cell = function(value) percent(value, 0.1),
        maxWidth = 80
      ),
      p = colDef(
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 80
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 80
      ),
      "Mapped Genes" = colDef(
        cell = function(value) with_tooltip(value, width = 100),
        minWidth = 150
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(plot_network_mapped, "#### Network Plot", "")`

```{r plot-network-mapped, eval = plot_network_mapped, echo = plot_network_mapped, fig.cap=glue("*Network plot showing gene-sets enriched amongst the overall set of sites with detectable signal for {target}.*")}
tg_mapped %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_mapped) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha= "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```


### Windows With Differential `r target` Signal {.tabset}

```{r goseq-diff, fig.show='hide'}
pwf_diff <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = up|down) 
goseq_diff <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(df$diff) > 0) {
  goseq_diff <- dplyr::select(df, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_diff <- sum(goseq_diff$adj_p < enrich_alpha) > 0
tg_diff <- make_tbl_graph(
  goseq_diff, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(df, diff)$gene_id) %>%
    .[vapply(., length, integer(1)) > 0]
)
plot_network_diff <- length(tg_diff) >= min_network_size
```


`r ifelse(!any_goseq_diff, "No enrichment was found amongst genes mapped to sites showing any differential signal", "#### Results Table")`


```{r tbl-goseq-diff, eval = any_goseq_diff, echo = any_goseq_diff}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_diff$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of changed 
        {target} signal. Genes mapped to a differential signal window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_diff %>%
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  )%>% 
  mutate(
    gene_name = vapply(
      DEgenes, 
      function(x) paste(id2gene[x], collapse = "; "),
      character(1)
    ),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to DB Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = function(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          str_replace_all(value, "_", " ")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = function(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% DB",
        maxWidth = 80,
        cell = function(value) percent(value, 0.1)
      ),
      numDEInCat = colDef(name = "Total Mapped To DB", maxWidth = 80),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = function(value) comma(value, 1)
      ),
      p = colDef(
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to DB Windows" = colDef(
        cell = function(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(plot_network_diff, "#### Network Plot", "")`

```{r plot-network-diff, eval = plot_network_diff, echo = plot_network_diff, fig.cap=glue("*Network plot showing gene-sets enriched amongst those differential signal for {target}.*")}
tg_diff %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
    geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_diff) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha= "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```

### Windows With Increased `r target` Signal {.tabset}

```{r goseq-up, fig.show='hide'}
pwf_up <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = up)
goseq_up <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(df$diff) > 0) {
  goseq_up <- dplyr::select(df, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_up <- sum(goseq_up$adj_p < enrich_alpha) > 0
tg_up <- make_tbl_graph(
  goseq_up, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(df, diff)$gene_id) %>%
    .[vapply(., length, integer(1)) > 0]
)
plot_network_up <- length(tg_up) >= min_network_size
```


`r ifelse(!any_goseq_up, glue("No enrichment was found amongst genes mapped to sites showing increased {target} signal"), "#### Results Table")`


```{r tbl-goseq-up, eval = any_goseq_up, echo = any_goseq_up}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_up$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of increased 
        {target} signal. Genes mapped to an increasing window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_up %>%
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  )%>% 
  mutate(
    gene_name = vapply(
      DEgenes, 
      function(x) paste(id2gene[x], collapse = "; "),
      character(1)
    ),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to Increasing Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = function(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          str_replace_all(value, "_", " ")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = function(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% Gained",
        cell = function(value) percent(value, 0.1),
        maxWidth = 80
      ),
      numDEInCat = colDef(name = "Mapped to Increasing Windows", maxWidth = 80),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = function(value) comma(value, 1)
      ),
      p = colDef(
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to Increasing Windows" = colDef(
        cell = function(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(plot_network_up, "#### Network Plot", "")`

```{r plot-network-up, eval = plot_network_up, echo = plot_network_up, fig.cap=glue("*Network plot showing  gene-sets enriched amongst those showing increased signal for {target}.*")}
tg_up %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_up) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha= "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```


### Windows With Decreased `r target` Signal {.tabset}

```{r goseq-down, fig.show='hide'}
pwf_down <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = down)
goseq_down <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(df$diff) > 0) {
  goseq_down <- dplyr::select(df, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_down <- sum(goseq_down$adj_p < enrich_alpha) > 0
tg_down <- make_tbl_graph(
  goseq_down, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(df, diff)$gene_id) %>%
    .[vapply(., length, integer(1)) > 0]
)
plot_network_down <- length(tg_down) >= min_network_size
```


`r ifelse(!any_goseq_down, glue("No enrichment was found amongst genes mapped to sites showing decreased {target} signal"), "#### Results Table")`


```{r tbl-goseq-down, eval = any_goseq_down, echo = any_goseq_down}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_down$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of decreased 
        {target} signal. Genes mapped to a decreasing window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_down %>% 
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  mutate(
    gene_name = vapply(
      DEgenes, 
      function(x) paste(id2gene[x], collapse = "; "),
      character(1)
    ),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to Decreasing Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = function(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          str_replace_all(value, "_", " ")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = function(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% Decreased",
        cell = function(value) percent(value, 0.1),
        maxWidth = 80
      ),
      numDEInCat = colDef(name = "Mapped to Decreasing Windows", maxWidth = 90),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = function(value) comma(value, 1)
      ),
      p = colDef(
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = function(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to Decreasing Windows" = colDef(
        cell = function(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

`r ifelse(plot_network_down, "#### Network Plot", "")`

```{r plot-network-down, eval = plot_network_down, echo = plot_network_down, fig.cap=glue("*Network plot showing gene-sets enriched amongst those showing decreased signal for {target}.*")}
tg_down %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
    geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_down) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```



```{r add-rna, eval = has_rnaseq, child = here::here('workflow/modules/rnaseq_differential.Rmd')}
```


## Data Export

```{r export-diff-by-gene}
results %>% 
  as_tibble() %>%
  unnest(all_of("gene_id")) %>%
  mutate(gene_name = id2gene[gene_id]) %>% 
  dplyr::select(
    gene_id, gene_name, range, logCPM, logFC, PValue, FDR, 
    status, any_of(c("region", "feature")), macs2_peak = overlaps_ref,
  ) %>% 
  mutate(
    distance_to_gene = distance(
      GRanges(range),
      setNames(gtf_gene, gtf_gene$gene_id)[gene_id]
    )
  ) %>% 
  write_csv(
    gzfile(all_out$csv)
  )
```


```{r data-export, results='hide'}
write_rds(results, all_out$results, compress = "gz")
file.create(all_out$de_genes)
if (has_rnaseq) write_csv(de_genes_db_regions, all_out$de_genes)

file.create(all_out$up_regions)
if (sum(results$status == "Up") > 0) {
  results %>% 
    filter(status == "Up") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}

file.create(all_out$down_regions)
if (sum(results$status == "Down") > 0) {
  results %>% 
    filter(status == "Down") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}
## Enrichment results need a bit of tweaking to match the tables
list2(
  `All Differentially Bound` = goseq_diff,
  "All Increased {target}" := goseq_up,
  "All Decreased {target}" := goseq_down
) %>% 
  bind_rows(.id = 'group') %>% 
  dplyr::filter(adj_p < enrich_alpha) %>% 
  left_join(
    dplyr::select(msigdb, gs_name, gene_name, gene_id, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  dplyr::filter(
    gene_id %in% unlist(subset(results, status != "Unchanged")$gene_id)
  ) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  mutate(
    gene_name = vapply(gene_name, paste, character(1), collapse = ": "),
    `%` = numDEInCat / numInCat,
  ) %>% 
  dplyr::select(
    group,
    `Gene Set` = gs_name, Description = gs_description, URL = gs_url,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to DB Windows` = gene_name
  ) %>% 
  write_csv(all_out$enrichment)
list2(
  `All Differentially Bound` = cmn_diff,
  "All Increased {target}" := cmn_up,
  "All Decreased {target}" := cmn_down
) %>% 
  bind_rows(.id = "group") %>% 
  mutate(
    genes = vapply(leadingEdge, paste, character(1), collapse = "; "),
    leadingEdge = vapply(leadingEdge, paste, character(1), collapse = "; "),
  ) %>% 
  write_csv(all_out$rna_enrichment)
## Save key memory on the HDD
gc()
save.image(all_out$renv)
```

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, "output.+"))`

## References

<div id="refs"></div>
<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">

```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```

</div>
