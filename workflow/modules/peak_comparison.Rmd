---
title: "Comparison of Targets"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
---

```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```


```{r packages}
library(tidyverse)
library(yaml)
library(glue)
library(metap)
library(extraChIPs)
library(rGREAT)
library(msigdbr)
library(plyranges)
library(reactable)
library(htmltools)
library(magrittr)
library(tidygraph)
library(ggraph)
library(regioneR)
library(scales)
library(pander)
library(parallel)
library(patchwork)
library(regioneReloaded)
library(motifTestR)
library(universalmotif)
library(corrplot)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
panderOptions("big.mark", ",")
source(here::here("workflow/scripts/custom_functions.R"))
source(here::here("workflow/scripts/table_funs.R"))
config <- here::here("config", "config.yml") %>% read_yaml()
all_paths <- here::here("config", "json", "all_paths.json") %>% 
    jsonlite::fromJSON() %>% 
    lapply(here::here)
threads <- detectCores() - 1
ucsc <- get_ucsc(config$genome$build)
bs_pkg <- glue("BSgenome.{ucsc$sp}.UCSC.{ucsc$build}")
library(bs_pkg, character.only = TRUE)
```

```{r target-config}
all_params <-  here::here("config", "params.yml") %>% read_yaml() 
region_params <- all_params$gene_regions
enrich_params <- all_params$enrichment
network_params <- all_params$networks
msigdb_params <- all_params$msigdb
motif_params <- here::here("config", "json", "motif_analysis_param.json") %>%
  jsonlite::fromJSON() %>%
  pluck("shared")
figure_params <- here::here("config", "rmarkdown.yml") %>%
  read_yaml() %>% 
  pluck("knitr_opts")
fw <- figure_params$fig.width
fh <- figure_params$fig.height
targets <- here::here(config$samples) %>% 
  read_tsv() %>% 
  pull("target") %>% 
  unique()
samples <- file.path(all_paths$macs2, "{targets}", "{targets}_qc_samples.tsv") %>% 
  glue() %>% 
  lapply(read_tsv) %>% 
  bind_rows() %>% 
  dplyr::filter(qc == "pass") %>% 
  dplyr::select(-all_of("qc")) 
targets <- unique(samples$target)
n_targets <- length(targets)
```

```{r annotations}
sq <- file.path(all_paths$annotation, "seqinfo.rds") %>% 
  read_rds()
gtf_gene <- read_rds(file.path(all_paths$annotation, "gtf_gene.rds"))
id2gene <- setNames(gtf_gene$gene_name, gtf_gene$gene_id)
tss <- read_rds(file.path(all_paths$annotation, "tss.rds"))
## Gene Regions
gene_regions <- read_rds(file.path(all_paths$annotation, "gene_regions.rds"))
regions <- map_chr(gene_regions, \(x) unique(x$region)[[1]])
## External features
external_features <- read_rds(file.path(all_paths$annotation, "features.rds"))
has_features <- length(external_features) > 0
## Combine features & regions for testing
all_regions <- c(gene_regions, external_features) %>% 
  endoapply(granges)
all_regions_labs <- c(
  map_chr(gene_regions, \(x) x$region[[1]]),
  map_chr(external_features, \(x) x$feature[[1]])
)
colours <- file.path(all_paths$annotation, "colours.rds") %>% 
  read_rds()
region_colours <- c(colours$regions, colours$features) %>%
  setNames(
    case_when(
      names(.) %in% names(regions) ~ regions[names(.)],
      TRUE ~ names(.)
    )
  )
target_colours <- RColorBrewer::brewer.pal(n_targets , "Set1") %>% 
  setNames(targets) %>% 
  c(Shared = "black")
## For regioneR analysis
heat_col <- c(
  rev(RColorBrewer::brewer.pal(9, "PuBuGn")),
  RColorBrewer::brewer.pal(9, "YlOrRd")
)
```



## Introduction

After performing individual analyses on the provided targets, this analysis performs a comparison of the regions with detected signal across all targets.
Comparisons were performed in a treatment-agnostic manner, using the sets of consensus peaks defined across all conditions, making this approach an analysis of the larger universe of regulation and pathways present within the cell type of interest,


## Peak Comparisons {.tabset}

```{r load-peaks}
consensus_peaks <- all_paths$peaks %>% 
  file.path("{targets}", "{targets}_consensus_peaks.bed.gz") %>% 
  glue() %>% 
  importPeaks(seqinfo = sq, type = "bed") %>% 
  setNames(str_remove(names(.), "_consensus.+"))
## NB: for n = 2, this will be the union peaks
shared_peaks <- file.path(all_paths$peaks, "shared", "shared_consensus_peaks.bed.gz") %>% 
  importPeaks(seqinfo = sq, type = "bed") %>% 
  setNames(str_remove(names(.), "_consensus.+")) %>% 
  unlist() %>% 
  unname() %>% 
  granges()
```

Consensus peaks from all targets (`r pander(targets)`) were loaded, and a set of common regions found.
Given that `r n_targets` were included in the dataset, the common regions were defined as the `r comma(length(shared_peaks))` overlapping regions across all targets, but where signal was detected in at least `r n_targets - 1` targets.
This ensures any individual targets with broader peaks do not lead to unrealistically broad common regions.

### Overlapping Regions

```{r plot-overlaps, fig.width = ifelse(n_targets > 2, fh, fw), fig.cap = glue("*Taking the combined overlap between any targets as the set of regions, the number of regions with each target overlapping these regions is shown below*")}
plotType <- ifelse(n_targets > 2, "upset", "venn")
plotOverlaps(
  consensus_peaks, type = plotType, set_col = target_colours, exp_sets = 0.3
)
```

### Peak Widths

```{r boxplot-widths, fig.cap = glue("*Peak widths within each target showing the total number of peaks within each target*")}
consensus_peaks %>% 
  lapply(width) %>% 
  lapply(enframe, name = NULL, value = "width") %>% 
  bind_rows(.id = "target") %>%
  ggplot(aes(target, width, fill = target)) +
  geom_boxplot() +
  geom_label(
    aes(label = label),
    data = . %>% 
      summarise(n = dplyr::n(), width = min(width), .by = target) %>% 
      mutate(label = comma(n), width = min(width)),
    fill = "white", alpha = 0.7
  ) +
  scale_fill_manual(values = target_colours) +
  scale_y_log10(labels = comma, name = "Peak Width") +
  labs(x = "Target", fill = "Target")
```

### Distance to TSS 

```{r plot-shared-dist-to-tss-hist, fig.height = 0.75 * fh, fig.cap = glue("*Distances from the centre of each set of consensus peaks to the nearest transcription start-site shown as A) a histogram, and B) as a cumulative distribution. The vertical dashed line indicates the range considered to be a promoter during annotation preparation. Shared peaks were removed from each set of consensus peaks to highlight any potential differences, and so that each peak is only included in one category.")}
df <- consensus_peaks %>% 
  endoapply(filter_by_non_overlaps, shared_peaks) %>% 
  c(GRangesList(Shared = shared_peaks)) %>% 
  endoapply(granges) %>% 
  lapply(
    \(x){
      join_nearest(x, mutate(tss, tss = start)) %>% 
        mutate(d = start + width/2 - tss) %>% 
        as_tibble()     
    }
  ) %>% 
  bind_rows(.id = "target") %>% 
  arrange(abs(d)) %>% 
  mutate(
    q = seq_along(d) / dplyr::n(), .by = all_of("target")
  )
A <- df %>% 
  ggplot(aes(d / 1e3, colour = target)) +
  geom_density() +
  coord_cartesian(xlim = c(-50, 50)) +
  scale_colour_manual(values = target_colours) +
  labs(
    x = "Distance To Nearest TSS (kb)",
    y = "Density"
  ) + 
  theme(legend.position = "none")
B <- df %>% 
  ggplot(aes(abs(d) / 1e3, q, colour = target)) +
  geom_line() +
  geom_vline(
    xintercept = max(unlist(region_params$promoters)) / 1e3, 
    linetype = 2, colour = "grey40"
  ) +
  coord_cartesian(xlim = c(0, 50)) +
  labs(
    x = "Absolute Distance to Nearest TSS (kb)",
    y = "Percentile", colour = "Target"
  ) +
  scale_colour_manual(values = target_colours) +
  scale_y_continuous(labels = percent, breaks = seq(0, 1, by = 0.2)) +
  scale_x_continuous(breaks = seq(0, 100, by = 20))
A + B + plot_annotation(tag_levels = "A")
```



## GREAT Enrichment 

```{r setup-great}
ext_tss <- gtf_gene %>% 
  select(gene_id) %>% 
  extendTSS(
    genome = ucsc$build, gene_id_type = 'ENSEMBL', 
    basal_upstream = region_params$promoters$upstream,
    basal_downstream = region_params$promoters$downstream
  ) 
ext_tss_ol <- subsetByOverlaps(ext_tss, shared_peaks)
msigdb <- msigdbr(msigdb_params$species) %>% 
  dplyr::filter(
    gs_cat %in% msigdb_params$gs_cat | gs_subcat %in% msigdb_params$gs_subcat,
    ensembl_gene %in% ext_tss$gene_id
  )
gs_list <- msigdb %>% 
  split(.$gs_name) %>% 
  lapply(pull, ensembl_gene) %>% 
  .[map_int(., length) <= enrich_params$max_size] %>% 
  .[map_int(., length) >= enrich_params$min_size] 
gs_url <- msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name, gs_url, gs_exact_source) %>%
  mutate(
    gs_url = case_when(
      gs_subcat == "CP:REACTOME" ~ str_remove_all(gs_url, "\\|.+"),
      gs_subcat == "CP:KEGG" ~ paste0("https://www.genome.jp/pathway/", gs_exact_source),
      gs_subcat == "CP:WIKIPATHWAYS" ~ paste0(
        "https://www.wikipathways.org/pathways/", gs_exact_source, ".html"
      ),
      gs_url == "" ~ "http://www.gsea-msigdb.org/gsea/msigdb/collections.jsp",
      TRUE ~ gs_url
    ) %>% 
      setNames(gs_name)
  ) %>% 
  pull(gs_url)
great_res <- great(
  set_genome_info(shared_peaks, genome = ucsc$build), 
  gene_sets = gs_list, 
  extended_tss = set_genome_info(ext_tss, genome = ucsc$build), 
  min_gene_set_size = enrich_params$min_size, 
  cores = threads
)
great_df <- getEnrichmentTable(great_res) %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  arrange(p_value_hyper) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, enrich_params$adj),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great <- sum(great_df$p_adjust_hyper < enrich_params$alpha)
```


In keeping with the analysis of each individual set of peaks, the `r comma(length(shared_peaks))` regions where all targets were detectable were analysed using `rGREAT` [@Gu2023-rp] and identical parameterisation.
This gives clear insight into which pathways are likely to be regulated by all targets *acting in concert*, with `r n_great` gene-sets being considered as enriched within these shared regions.

As analysis using `rGREAT` determines enrichment in comparison to a set of background regions, two analyses were performed.
The first uses the *entire genome* as the background ranges, whilst the second strategy uses the union of all ranges with detected signal in *any target* as the background.
The latter approach effectively zooms in on the gene-sets specifically regulated by all targets acting in concert, out of the larger group of gene-sets regulated by *any* of the targets.
The results will often be highly comparable, but can sometimes reveal interesting insights as to the underlying biology.


### Genomic Background {.tabset}

```{r great-genome-bg}
great_res_genomic <- great(
  set_genome_info(shared_peaks, genome = ucsc$build), 
  gene_sets = gs_list, 
  extended_tss = set_genome_info(ext_tss, genome = ucsc$build), 
  min_gene_set_size = enrich_params$min_size, 
  cores = threads
)
great_df_genomic <- getEnrichmentTable(great_res_genomic) %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  arrange(p_value_hyper) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, enrich_params$adj),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great_genomic <- sum(great_df_genomic$p_adjust_hyper < enrich_params$alpha)
```


`r if (n_great_genomic > 0) "#### GREAT Results Table"`

```{r tbl-great-res-genomic, eval = n_great_genomic > 0, echo = n_great_genomic > 0}
tbl <- great_df_genomic %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>% 
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-all_of(c("p_value_hyper", "gene_id"))) %>% 
  dplyr::select(id, fold_enrichment_hyper, p_adjust_hyper, everything()) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE,
    columns = list(
      id = colDef(
        name = "Gene Set", minWidth = 180,
        cell = function(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          str_replace_all(value, "_", " ")
        ),
        html = TRUE
      ),
      genome_fraction = colDef(show = FALSE),
      observed_region_hits = colDef(show = FALSE),
      fold_enrichment_hyper = colDef(
        name = "Fold Enrichment", format = colFormat(digits = 3),
        minWidth = 110, filterMethod = js_greater
      ),
      p_adjust_hyper = colDef(
        name = glue("P<sub>adj</sub> ({enrich_params$adj})"),
        html = TRUE, maxWidth = 110,
        cell = \(value) sprint_pval(value),
        filterMethod = js_less
      ),
      mean_tss_dist = colDef(
        "Mean TSS Distance (kb)", 
        cell = \(value) round(value / 1e3, 2), filterMethod = js_greater
      ),
      observed_gene_hits = colDef(
        "Gene Hits", maxWidth = 100, filterMethod = js_greater
      ),
      gene_set_size = colDef(
        "Gene Set Size", maxWidth = 100, filterMethod = js_greater
      ),
      genes_with_hits = colDef(
        name = "Genes",
        cell = \(value) with_tooltip(value, width = 60),
        minWidth = 200
      )
    ),
    details =  function(index){
      htmltools::div(
        htmltools::tags$pre(
          str_wrap(
            paste(capture.output(great_df_genomic$genes_with_hits[index]), collapse = "\n"),
            width = 120
          )
        )
      )
    },
    elementId = "great-genomic-res-table"
  )
cp <- htmltools::em(
  glue(
    "Gene-set enrichment results for regions showing consistently detectable ", 
    "signal for all of ", glue_collapse(targets, sep = ", ", last = " and "),
    " that were considered significantly enriched when using rGREAT. ", 
    "Backround regions to determine relative enrichment were taken as the entire genome. ",
    comma(n_great_genomic), 
    " gene-sets were considered as enriched relative to background. ",
    "In the case of large numbers of significant gene-sets, results are limited to the 100 most highly ranked. ",
    "The genes listed are those associated with the set of shared regions, ",
    "with the gene-set size reflecting the number associated with the background regions."
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('great-genomic-res-table', 'shared_great_genomic_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('great-genomic-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('great-genomic-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_great_genomic >= network_params$min_size) "#### Enrichment Network"`

```{r great-network-genomic, echo = n_great_genomic >= network_params$min_size, eval = n_great_genomic >= network_params$min_size, fig.cap = glue("*The {n_great_genomic} most highly ranked gene sets from rGREAT analysis when using the entire genome as the background. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with all targets detected. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {network_params$max_size} gene sets*")}
tg_great_genomic <- great_df_genomic %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>%
  make_tbl_graph(
    gs = great_df[["gene_id"]], 
    alpha = enrich_params$alpha, p_col = "p_adjust_hyper", gs_col = "id", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = network_params$max_size
  )
if (length(tg_great_genomic) >= network_params$min_size) {
  tg_great_genomic %>% 
    mutate(
      ## The lowest p-value obtainable from pbinom is 1e-16
      p_value_hyper = ifelse(p_value_hyper > 0, p_value_hyper, 1e-16),
      prop = observed_gene_hits / gene_set_size 
    ) %>% 
    ggraph(layout = network_params$layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p_value_hyper), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, 
      max.overlaps = max(10, round(length(tg_great_genomic) / 4, 0)),
      bg.color = "white", bg.r = 0.1, 
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```

`r if (n_great_genomic > 0) "#### TSS Distribution"`

```{r plot-top-great-genomic, eval = n_great_genomic > 0, echo = n_great_genomic > 0, fig.height = 0.75 * fw, fig.cap = glue("*The distribution of shared regions around the TSS for the most highly ranked gene-set ({top_id})*")}
top_id <- great_df_genomic$id[1]
plotRegionGeneAssociations(great_res_genomic, top_id, which = 2:3)
```

### Targets Background


```{r great-targets-bg}
bg <- consensus_peaks %>% 
  unlist() %>% 
  reduce() %>% 
  set_genome_info(genome = ucsc$build)
great_res_targets <- great(
  set_genome_info(shared_peaks, genome = ucsc$build), 
  gene_sets = gs_list, 
  background = bg,
  extended_tss = set_genome_info(ext_tss, genome = ucsc$build), 
  min_gene_set_size = enrich_params$min_size, 
  cores = threads
)
great_df_targets <- getEnrichmentTable(great_res_targets) %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  arrange(p_value_hyper) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, enrich_params$adj),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great_targets <- sum(great_df_targets$p_adjust_hyper < enrich_params$alpha)
```


`r if (n_great_targets > 0) "#### GREAT Results Table"`

```{r tbl-great-res-targets, eval = n_great_targets > 0 , echo = n_great_targets > 0}
tbl <- great_df_targets %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>% 
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-all_of(c("p_value_hyper", "gene_id"))) %>% 
  dplyr::select(id, fold_enrichment_hyper, p_adjust_hyper, everything()) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE,
    columns = list(
      id = colDef(
        name = "Gene Set",
        cell = \(value) str_replace_all(value, "_", " "),
        minWidth = 180
      ),
      genome_fraction = colDef(show = FALSE),
      observed_region_hits = colDef(show = FALSE),
      fold_enrichment_hyper = colDef(
        name = "Fold Enrichment", format = colFormat(digits = 3),
        minWidth = 110, filterMethod = js_greater
      ),
      p_adjust_hyper = colDef(
        name = glue("P<sub>adj</sub> ({enrich_params$adj})"),
        html = TRUE, filterMethod = js_less,
        cell = \(value) sprint_pval(value),
        maxWidth = 110
      ),
      mean_tss_dist = colDef(
        "Mean TSS Distance (kb)", 
        cell = \(value) round(value / 1e3, 2), filterMethod = js_greater
      ),
      observed_gene_hits = colDef(
        "Gene Hits", maxWidth = 100, filterMethod = js_greater
      ),
      gene_set_size = colDef(
        "Gene Set Size", maxWidth = 100, filterMethod = js_greater
      ),
      genes_with_hits = colDef(
        name = "Genes",
        cell = \(value) with_tooltip(value, width = 60),
        minWidth = 200
      )
    ),
    details =  function(index){
      htmltools::div(
        htmltools::tags$pre(
          str_wrap(
            paste(capture.output(great_df_genomic$genes_with_hits[index]), collapse = "\n"),
            width = 120
          )
        )
      )
    },
    elementId = 'great-targets-res-table'
  )
cp <- htmltools::em(
  glue(
    "Gene-set enrichment results for regions showing consistently detectable ", 
    "signal for all of ", glue_collapse(targets, sep = ", ", last = " and "),
    " that were considered significantly enriched when using rGREAT. ", 
    "Backround regions to determine relative enrichment were taken as the entire genome. ",
    comma(n_great_targets), 
    " gene-sets were considered as enriched relative to background. ",
    "In the case of large numbers of significant gene-sets, results are limited to the 100 most highly ranked. ",
    "The genes listed are those associated with the set of shared regions, ",
    "with the gene-set size reflecting the number associated with the background regions."
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('great-targets-res-table', 'shared_great_targets_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('great-targets-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('great-targets-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_great_targets >= network_params$min_size) "#### Enrichment Network"`

```{r great-network-targets, echo = n_great_targets >= network_params$min_size, eval = n_great_targets >= network_params$min_size, fig.cap = glue("*The {n_great_targets} most highly ranked gene sets from rGREAT analysis when using the combined peaks as the background. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with all targets detected. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {network_params$max_size} gene sets*")}
tg_great_targets <- great_df_targets %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>%
  make_tbl_graph(
    gs = great_df[["gene_id"]], 
    alpha = enrich_params$alpha, p_col = "p_adjust_hyper", gs_col = "id", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = network_params$max_size
  )
if (length(tg_great_targets) >= network_params$min_size) {
  tg_great_targets %>% 
    mutate(
      ## The lowest p-value obtainable from pbinom is 1e-16
      p_value_hyper = ifelse(p_value_hyper > 0, p_value_hyper, 1e-16),
      prop = observed_gene_hits / gene_set_size 
    ) %>% 
    ggraph(layout = network_params$layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p_value_hyper), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, 
      max.overlaps = max(10, round(length(tg_great_targets) / 4, 0)),
      bg.color = "white", bg.r = 0.1, 
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```

## Regioner Analysis

### Region Comparisons {.tabset}

```{r load-regioner}
localz_regions <- here::here(
  all_paths$peaks, "{targets}", "{targets}_regions_localz.rds"
) %>% 
  glue() %>%
  c(here::here(all_paths$peaks, "shared", "shared_regions_localz.rds")) %>% 
  setNames(c(targets, "shared")) %>% 
  lapply(read_rds)
localz_df <- localz_regions %>%
  lapply(slot, "multiLocalZscores") %>% 
  lapply(pluck, "resumeTab") %>% 
  bind_rows(.id = "target") %>% 
  as_tibble() %>% 
  dplyr::rename(region = name) %>% 
  mutate(
    p_value = 1 - pchisq(norm_zscore^2, 1),
    adj.p_value = p.adjust(p_value, enrich_params$adj),
    region = case_when(
      region %in% names(regions) ~ regions[region],
      TRUE ~ region
    ) %>% 
      factor(names(region_colours)),
    enrichment = log2(n_overlaps / mean_perm_test),
    target_peaks = c(
      map_int(consensus_peaks, length), shared = length(shared_peaks)
    )[target],
    prop = n_overlaps / target_peaks
  ) %>% 
  dplyr::select(
    target, region, target_peaks, n_overlaps, prop, Z = norm_zscore, enrichment,
    ends_with("p_value"), ends_with("perm_test")
  )
shifted_z <- localz_regions %>% 
  lapply(slot, "multiLocalZscores") %>% 
  lapply(
    \(x) {
      tbl <- as_tibble(x$shifed_ZSs)
      tbl$shift <- x$shifts
      tbl
    }
  ) %>% 
  bind_rows(.id = "target") %>% 
  pivot_longer(
    cols = all_of(names(all_regions)), names_to = "region", values_to = "Z"
  ) %>% 
  mutate(
    region = case_when(
      region %in% names(regions) ~ regions[region],
      TRUE ~ region
    ) %>% 
      factor(names(region_colours)),
    n = c(map_int(consensus_peaks, length), shared = length(shared_peaks))[target],
    Z = Z / sqrt(n),
    target = factor(target, levels = c("shared", targets))
  ) 
```

The package `regionerReloaded` [@Malinverni2023-ee] was again used to compare the peaks sharing signal from all targets against the same set of genomic regions and features as analysed earlier.
The following analysis includes the *shared-target peaks* as well as each target's set of peaks, as analysed in the individual summaries.
This provides an excellent frame of reference for comparison between targets, and th nature of the shared-target peaks in this context.

#### Combined Heatmap

```{r zscore-heatmap, fig.cap = glue("*Normalised Z-scores showing the effect of shifting  peaks for all targets and the set of shared peaks, within a $\\pm$ {slot(localz_regions[[1]], 'parameters')$window / 1e3}kb window around the existing peaks.*")}
shifted_z %>% 
  ggplot(aes(shift, fct_rev(region), fill = Z)) +
  geom_raster() +
  facet_grid(cols = vars(target)) +
  scale_x_continuous(
    expand = rep_len(0, 4), labels = \(x) x / 1e3, name = "Shift (kb)"
  ) +
  scale_y_discrete(expand = rep_len(0, 4), name = NULL) +
  scale_fill_gradientn(
    colours = heat_col,
    limits = c(-1.05, 1.05) * max(abs(shifted_z$Z))
  )
```

#### Results Table

```{r tbl-localz-regions}
tbl <- localz_df %>% 
  arrange(p_value) %>% 
  dplyr::select(-sd_perm_test, -p_value) %>% 
  dplyr::select(target, region, target_peaks, mean_perm_test, everything()) %>% 
  reactable(
    filterable = TRUE, showPageSizeOptions = TRUE,
    columns = list(
      target = colDef("Target"),
      region = colDef("Region", minWidth = 120),
      target_peaks = colDef(
        "N Peaks", format = comma_col, maxWidth = 80, filterMethod = js_greater
      ),
      mean_perm_test = colDef(
        "Expected", format = comma_col, filterMethod = js_greater
      ),
      n_overlaps = colDef(
        "Observed", format = comma_col, maxWidth = 85,
        filterMethod = js_greater
      ),
      prop = colDef(
        "% Peaks", format = percent_col, maxWidth = 80, 
        filterMethod = js_greater
      ),
      Z = colDef(
        format = colFormat(digits = 2), maxWidth = 80,
        style = \(value) list(color = ifelse(value > 0, "black", "red")),
        filterMethod = js_greater
      ),
      enrichment = colDef(
        "log<sub>2</sub> Enrichment", format = colFormat(digits = 2),
        html = TRUE, 
        style = \(value) list(color = ifelse(value > 0, "black", "red")),
        filterMethod = js_greater
      ),
      adj.p_value = colDef(
        glue("p<sub>{enrich_params$adj}</sub>"), html = TRUE,
        cell = \(value) sprint_pval(value), maxWidth = 80,
        style = \(value) list(
          color = ifelse(
            value < enrich_params$alpha, "black", colours$direction$unchanged
          )
        ),
        filterMethod = js_less
      )
    ),
    columnGroups = list(
      colGroup("Overlaps", columns = c("mean_perm_test", "n_overlaps", "prop"))
    ),
    elementId = "localz-res-table"
  )
cp <- htmltools::em(
  glue(
    "
    Results for association between the all peaks and the pre-defined 
    genomic regions{ifelse(has_features, ', including the supplied external features.', '.')}.
    Expected overlaps are those obtained through random resampling of the genome
    to match the consensus peaks. Enrichment is given taking log2 of 
    the ratio between observed and expected overlapping peaks.
    "
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('localz-res-table', 'shared_localz_res.csv')"
    )
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('localz-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

### Comparison Between Peaks {.tabset}

```{r load-localz-peaks}
mlz_list <- here::here(all_paths$peaks, "shared", "shared_targets_localz.rds") %>% 
  read_rds
dist_df <- mlz_list %>% 
  lapply(
    function(x) {
      mlz <- slot(x, "multiLocalZscores")
      tbl <- as_tibble(mlz$shifed_ZSs)
      tbl$shift <- mlz$shifts
      tbl
    }
  ) %>% 
  bind_rows(.id = "Query") %>% 
  pivot_longer(
    cols = all_of(names(consensus_peaks)), names_to = "Target", values_to = "Z"
  ) %>% 
  dplyr::filter(!is.na(Z)) %>% 
  mutate(
    Z = Z / sqrt(map_int(consensus_peaks, length)[Query]),
    Target = factor(Target, levels = names(consensus_peaks)) %>% fct_rev(),
    Query = factor(Query, levels = names(consensus_peaks)) %>% fct_rev()
  )
pairwise_df <- mlz_list %>% 
  lapply(slot, "multiLocalZscores") %>% 
  lapply(pluck, "resumeTab") %>% 
  bind_rows(.id = "Query") %>% 
  dplyr::rename(Target = name) %>% 
  mutate(
    n_regionA = map_int(consensus_peaks, length)[Query],
    n_regionB = map_int(consensus_peaks, length)[Target],
    prop = n_overlaps / map_int(consensus_peaks, length)[Query],
    enrichment = log2(n_overlaps / mean_perm_test),
    p_value = 1 - pchisq(norm_zscore^2, 1),
    adj.p_value = p.adjust(p_value, enrich_params$adj)
  ) 
```

The set of peaks derived from each target was also compared to each other to check for any relationship between their locations on the genome.
Shifted Z-Scores indicate proximity and fine-grained relative binding patterns, with additional Z-scores derived from any enrichment of direct overlaps above the expected values used to determine the statistical significance of these overlaps compared to random expectations.

#### Shifted Z-Scores

```{r plot-shiftedz, fig.cap = glue("*Distributions of shifted Z-scores for each target relative to other targets. Narrow peaks indicate close proximity of overlaps, whilst dips around zero indicate very close by not overlapping signal, as may be observed with histone marks and associated transcription factors.*")}
dist_df %>% 
  arrange(desc(Z)) %>%
  mutate(
    Query = fct_inorder(Query),
    Target = fct_inorder(Target)
  ) %>%
  ggplot(aes(shift, Z, colour = Target)) +
  geom_line() +
  facet_wrap(~Query) +
  scale_x_continuous(
    labels = \(x) x * 1e-3, name = "Shift (kb)"
  ) +
  scale_y_continuous(expand = expansion(c(0, 0.05))) +
  scale_colour_manual(values = target_colours)
```


#### Overlap Heatmap

```{r plot-overlap-heatmap, fig.cap = glue("*Heatmap showing the strength of overlaps between each target and the alternative targets, here represented as the Query and Target respectively. Fill colours are derived from Z-scores and indicate the significance of overlaps, with asterisks indicating a formal result passing statistical significance as detailed in the reults table. The proportion of peaks from each query and alternative targets is also shown within each tile.*")}
pairwise_df %>% 
  ggplot(aes(Target, fct_rev(Query), fill = norm_zscore)) +
  geom_raster() +
  geom_label(
    aes(label = prop),
    data = . %>% 
      mutate(
        prop = percent(prop, 0.1),
        prop = case_when(
          adj.p_value < enrich_params$alpha ~ paste0(prop, "*"),
          TRUE ~ prop
        )
      ),
    fill = "white", alpha = 0.6
  ) +
  scale_x_discrete(expand = expansion(0, 0)) +
  scale_y_discrete(expand = expansion(0, 0)) +
  scale_fill_gradientn(
    colours = heat_col,
    limits = c(-1.05, 1.05) * max(abs(pairwise_df$norm_zscore)),
  ) +
  labs(y = "Query", fill = "Z") +
  theme(panel.grid = element_blank())
```


#### Results Table

```{r pairwise-tbl}
tbl <- pairwise_df %>%
  dplyr::select(
    Query, Target, n_regionA, n_regionB, prop, n_overlaps, mean_perm_test, 
    enrichment, norm_zscore, adj.p_value
  ) %>% 
  arrange(adj.p_value) %>% 
  reactable(
    columns = list(
      Query = colDef(maxWidth = 85),
      Target = colDef(maxWidth = 85),
      n_regionA = colDef("Query", format = comma_col),
      n_regionB = colDef("Target", format = comma_col),
      prop = colDef("% Query", format = colFormat(percent = TRUE, digits = 1)),
      n_overlaps = colDef("Observed", format = comma_col),
      mean_perm_test = colDef("Expected", format = comma_col),
      enrichment = colDef(
        "log<sub>2</sub> Enrichment", format = colFormat(digits = 2),
        html = TRUE,
        style = \(value) {
          text_colour = ifelse(value < 0, colours$direction$decreased, "black")
          list(color = text_colour)
        }
      ),
      norm_zscore = colDef(
        "Z", format = colFormat(digits = 2),
        style = \(value) {
          text_colour = ifelse(value < 0, colours$direction$decreased, "black")
          list(color = text_colour)
        }
      ),
      adj.p_value = colDef(
        glue("p<sub>{enrich_params$adj}</sub>"), html = TRUE,
        cell = \(value) sprint_pval(value),
        style = \(value) {
          text_colour = ifelse(
            value < enrich_params$alpha, "black", colours$direction[["unchanged"]]
          )
          list(color = text_colour)
        }
      )
    ),
    columnGroups = list(
      colGroup(name = "Nbr. Regions", columns = str_subset(names(.), "n_reg")),
      colGroup(
        name = "Overlaps", columns = c("prop", "n_overlaps", "mean_perm_test")
      )
    ),
    elementId = 'pairwise-res-table'
  )
cp <- htmltools::em(
  glue(
    "
    Results showing significance of the overlap between peaks from each target 
    and the other targets, defined in here as the Query and Target respectively. 
    Expected values represent those estimated using permutations, with the log2 
    ratio between the two values expressed as enrichment
    "
  )
)
tl <- tagList(tbl,cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

## Motif Analysis

```{r load-motif-res}
bs_genome <- get(bs_pkg)
fw_peaks <- resize(
  shared_peaks, width = motif_params$peak_width, fix = "center"
)
genome(fw_peaks) <- ucsc$build
fw_seq <- getSeq(bs_genome, fw_peaks)
motif_adj <- match.arg(motif_params$adj, p.adjust.methods)
motif_list <- file.path(all_paths$annotation, "motif_list.rds") %>% 
  read_rds() %>% 
  to_df %>% 
  as_tibble()
motif_uri <- file.path(all_paths$annotation, "motif_uri.rds") %>% 
  read_rds()   
pos_res <- here::here(all_paths$peaks, "shared", "shared_motif_position.tsv.gz") %>% 
  read_tsv() %>% 
  dplyr::select(-fdr) %>% 
  mutate(adj_p = p.adjust(p, motif_adj))
n_pos <- sum(pos_res$adj_p < motif_params$alpha)
enrich_res <-  here::here(all_paths$peaks, "shared", "shared_motif_enrichment.tsv.gz") %>% 
  read_tsv() %>% 
  dplyr::select(-fdr) %>% 
  mutate(adj_p = p.adjust(p, motif_adj))
n_enrich <- sum(enrich_res$adj_p < motif_params$alpha)
```

Using the motifs defined during preparation, testing was performed for 1) enrichment above background and 2) any positional bias within the tested sequences.
For this step peaks were set to a fixed width of `r motif_params$peak_width`bp, with sequences taken from these regions.

### Motif Enrichment {.tabset}

A simple enrichment analysis was performed by selecting a set of `r comma(enrich_res$sequences[[1]] * enrich_res$n_iter[[1]])` *background sequences* matched by position with genomic regions to the `r comma(enrich_res$sequences[[1]])` *test sequences*.
This gave a set of genomically matched control sequences to gauge enrichment by.
Analysis was performed using the `motifTestR` package and the `r motif_params$model`.

Whilst testing was two-sided, only enriched motifs (i.e. observed > expected) are shown in the results below, with `r n_enrich` of the `r comma(nrow(motif_list))` included motifs matching the criteria for being considered as enriched.

`r if (n_enrich > 0) "#### Enrichment Table"`

```{r tbl-res-enrich, eval = n_enrich > 0, echo = n_enrich > 0}
tbl <- enrich_res %>%
  arrange(p) %>% 
  dplyr::filter(adj_p < motif_params$alpha, Z > 0) %>% 
  mutate(cluster = fct_inorder(as.character(cluster))) %>% 
  dplyr::select(
    cluster, ends_with("name"), Z, p, adj_p, matches, expected, enrichment
  ) %>% 
  mutate(
    PWM = lapply(altname, \(x) motif_uri[[x]])
  ) %>% 
  reactable(
    groupBy = "cluster",
    showPageSizeOptions = TRUE, filterable = TRUE,
    theme = reactableTheme(style = list(fontSize = 12)),
    defaultSorted = "adj_p", defaultSortOrder = "asc",
    columns = list(
      cluster = colDef("Cluster", maxWidth = 70),
      altname = colDef(
        "Motif", minWidth = 180, aggregate = "unique",
        style = list(borderLeft = "1px solid rgba(0, 0, 0, 0.1)")
      ),
      name = colDef(
        "Name", minWidth = 120, aggregate = "unique",
        style = list(borderRight = "1px solid rgba(0, 0, 0, 0.1)")
      ),
      matches = colDef(
        "Total", maxWidth = 60, format = comma_col, aggregate = "max",
        filterMethod = js_greater
      ),
      expected = colDef(
        "Expected", maxWidth = 80, format = comma_col, aggregate = "max",
        filterMethod = js_greater
      ),
      enrichment = colDef(
        "Enrichment", maxWidth = 90, format = colFormat(digits = 3),
        aggregate = "max", filterMethod = js_greater,
        style = list(borderRight = "1px solid rgba(0, 0, 0, 0.1)")
      ),
      Z = colDef(
        maxWidth = 60, format = colFormat(digits = 2), aggregate = "max",
        filterMethod = js_greater
      ),
      p = colDef(show = FALSE),
      adj_p = colDef(
        glue("p<sub>{motif_adj}</sub>"), html = TRUE, maxWidth = 70,
        cell = \(value) sprint_pval(value), aggregate = "min",
        format = colFormat(digits = 3), filterMethod = js_less
      ),
      PWM = colDef(
        name = "IC Matrix", minWidth = 180, filterable = FALSE,
        cell = function(value) tags$img(src = value, height = '80px')
      )
    ),
    elementId = "enrich-res-table"
  )
cp <- htmltools::em(
  glue(
    "All {n_enrich} motifs considered as enriched relative to the background set
    of sequences, using the {motif_params$model} model and an adjusted 
    p-value ({motif_adj}) < {motif_params$alpha} as the criteria for 
    significance. Motifs are grouped by clusters formed earlier, with all motifs
    visible by clicking the arrow to the arbitrary cluster identifier. All 
    columns are searchable and filterable."
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('enrich-res-table', 'shared_enrich_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('enrich-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('enrich-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_enrich > 1) "#### Comparison of Motif Co-Occurrence"`

```{r enrich-corrplot, eval = n_enrich > 1, echo = n_enrich > 1, fig.width = 0.8 * fw, fig.height = 0.8 * fw, fig.cap = glue("*The top {length(top_enrich)} motifs ranked for enrichment were compared to each other using correlations derived from simple presence/absence calls. Highly correlated motifs may indicate similarity between TFBMs and the same sequence match being identified, but may also indicate co-occurrence. Numbes within each square are spearman correlations.*")}
top_enrich <- enrich_res %>%
  dplyr::filter(Z > 0, adj_p < motif_params$alpha) %>% 
  dplyr::slice(1:20) %>% 
  pull("altname")
motif_list %>% 
  dplyr::filter(altname %in% top_enrich) %>% 
  to_list() %>% 
  getPwmMatches(fw_seq, mc.cores = threads) %>% 
  lapply(\(x) tibble(seq = unique(x$seq))) %>% 
  bind_rows(.id = "altname") %>%
  distinct(altname, seq) %>% 
  left_join(
    dplyr::select(enrich_res, altname, name), by = "altname"
  ) %>% 
  mutate(detected = TRUE) %>% 
  dplyr::select(seq, name, detected) %>% 
  pivot_wider(
    names_from = "name", values_from = "detected", values_fill = FALSE
  ) %>% 
  dplyr::select(-seq) %>% 
  cor(method = "spearman") %>% 
  corrplot(
    addCoefasPercent = TRUE, addCoef.col = "grey20", 
    tl.cex = 0.75, number.cex = 0.8, order = "hclust"
  )
```


### Positional Bias {.tabset}

```{r get-top-pos, eval = n_pos > 0, echo = n_pos > 0}
top_pos <- pos_res %>% 
  dplyr::filter(adj_p < motif_params$alpha) %>% 
  dplyr::filter(matches_in_region == max(matches_in_region), .by = cluster) %>% 
  dplyr::slice(1:9) %>% 
  dplyr::select(altname, name, cluster)
clust_names <- pos_res %>% 
  dplyr::filter(
    adj_p < motif_params$alpha,
    cluster %in% top_pos$cluster
  ) %>% 
  arrange(desc(matches_in_region)) %>% 
  summarise(
    altname = altname[[1]], .by = cluster,
    name = paste(name, collapse = "/")
  ) %>% 
  mutate(name = setNames(name, altname)) %>% 
  pull(name)
```

Positional bias was tested using the package `motifTestR`, bin-sizes of `r motif_params$binwidth`bp and testing `r ifelse(motif_params$abs, "distance from sequence centres", "position either side of the sequence centres")`.
Any motifs which matched fewer than `r percent(motif_params$ignore_below)` of sequences were not tested for any positional bias.

Using an adjusted p-value (`r motif_adj`) less than `r motif_params$alpha` to be considered as significant, `r n_pos` motifs were considered as showing any type of positional bias.

It should also be noted that this type of analysis is agnostic to the number of matches found for a TFBM, and only assesses any bias within the distribution of matches.

`r if (n_pos > 0) "#### Results Table"`

```{r tbl-res-pos, eval = n_pos > 0, echo = n_pos > 0}
tbl <- pos_res %>%
  dplyr::filter(adj_p < motif_params$alpha) %>%
  mutate(cluster = fct_inorder(as.character(cluster))) %>% 
  dplyr::select(
    cluster, contains("name"), ends_with("p"), start, end, centre, width,
    contains("total"), matches_in_region, starts_with("e"), 
  ) %>% 
  mutate(
    PWM = lapply(altname, \(x) motif_uri[[x]])
  ) %>% 
  reactable(
    groupBy = "cluster", showPageSizeOptions = TRUE, filterable = TRUE,
    columns = list(
      cluster = colDef(maxWidth = 60),
      name = colDef("Name", aggregate = "unique", maxWidth = 80),
      altname = colDef("Motif", aggregate = "unique", minWidth = 180),
      start = colDef(
        "Start", aggregate = "min", maxWidth = 50,
        filterMethod = js_greater
      ),
      end = colDef(
        "End", aggregate = "max", maxWidth = 50, 
        filterMethod = js_greater
      ),
      centre = colDef(
        "Centre", aggregate = "median", maxWidth = 60, show = FALSE
      ),
      width = colDef(
        "Width", aggregate = "median", maxWidth = 60, 
        filterMethod = js_less
      ),
      total_matches = colDef(
        "Total", aggregate = "max", maxWidth = 60, format = comma_col,
        filterMethod = js_greater
      ),
      matches_in_region = colDef(
        "Region", aggregate = "max", maxWidth = 60, 
        filterMethod = js_greater
      ),
      expected = colDef(
        "Expected", aggregate = "max", maxWidth = 75, format = comma_col,
        filterMethod = js_greater
      ),
      enrichment = colDef(
        "Region Enrichment", aggregate = "max", format = colFormat(digits = 2),
        maxWidth = 90, filterMethod = js_greater
      ),
      prop_total = colDef(
        "% In Region", aggregate = "max", format = percent_col, maxWidth = 60,
        filterMethod = js_greater
      ),
      p = colDef(show = FALSE),
      adj_p = colDef(
        glue("p<sub>{motif_adj}</sub>"), html = TRUE, maxWidth = 70,
        cell = \(value) sprint_pval(value), format = colFormat(digits = 3),
        aggregate = "min", filterMethod = js_less
      ),
      PWM = colDef(
        name = "IC Matrix", minWidth = 180, filterable = FALSE,
        cell = function(value) tags$img(src = value, height = '80px')
      )
    ),
    columnGroups = list(
      colGroup(
        name = "Matches", 
        columns = c(
          "total_matches", "prop_total", "matches_in_region", "expected",
          "enrichment"
        )
      ),
      colGroup(
        name = "Positional Bias",  
        columns = c("start", "end", "centre", "width")
      )
    ),
    defaultSorted = "adj_p", defaultSortOrder = "asc",
    theme = reactableTheme(style = list(fontSize = 12)),
    elementId = "pos-res-table"
  )
cp <- htmltools::em(
  glue(
    "
    All {sum(pos_res$adj_p < motif_params$alpha)} TFBMs found to show
    positional bias using an adjusted p-value ({motif_adj}) below
    {motif_params$alpha} as the criteria for significance. Highly 
    similar motifs were clustered during preparation and are grouped accordingly.
    Clicking the arrow next to the arbitrary cluster id will reveal full details
    for all motifs within the cluster which were found to be significant, 
    including the sequence logo showing information content (ICM).
    "
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('pos-res-table', 'shared_position_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('pos-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('pos-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


`r if (n_pos > 0) "#### Total Matches"`

```{r plot-total-pos-matches, eval = n_pos > 0, echo = n_pos > 0, fig.cap = glue("*All best matches by their distance from the sequence centre, without binning by position. Black lines represent the loess curve through all matches. The motif with the most matches within the enriched region is shown for each cluster, with the other motifs within the cluster indicated below in brackets.*")}
lb <- glue("{names(clust_names)}\n({clust_names})") %>% 
  setNames(names(clust_names))
top_matches <- motif_list %>% 
  dplyr::filter(altname %in% top_pos$altname) %>% 
  to_list() %>% 
  getPwmMatches(
    fw_seq, abs = motif_params$abs, best_only = TRUE, mc.cores = threads
  )
top_matches %>% 
  plotMatchPos(
    geom = "point", abs = motif_params$abs, use_totals = TRUE,
    binwidth = 1
  ) +
  geom_smooth(se = FALSE, colour = "black", linewidth = 1/2, method = 'loess') +
  facet_wrap(~name, labeller = as_labeller(lb)) +
  theme(legend.position = "none") +
  labs(x = "Dsitance From Sequence Centre", y = "Total Matches")
```

`r if (n_pos > 0) "#### Proportional Match Distributions"`

```{r plot-smoothed-pos, eval = n_pos > 0, echo = n_pos > 0, fig.height = 0.75 * fh, fig.cap = glue("*Best matches for the representative motif within each cluster, shown as (A) proportions and (B) as a cumulative distribution*")}
A <- top_matches %>% 
  plotMatchPos(
    se = FALSE, abs = motif_params$abs, linewidth = 1/2,
    binwidth = motif_params$binwidth / 2
  ) +
  labs(
    x = "Distance From Centre", y = "Proportion", colour = "Motifs In Cluster"
  ) +
  theme(legend.position = "none")
B <- top_matches %>% 
  plotMatchPos(
    type = "cdf", geom = "line", abs = motif_params$abs,
    linewidth = 1 / 2, binwidth = 1
  ) +
  labs(x = "Distance From Centre", y = "Proportion", colour = "Motifs In Cluster")
A + B + plot_layout(guides = "collect") +
  theme(
    legend.key.height = unit(0.05, "npc"),
    legend.title = element_text(hjust = 0.5)
  )
```

`r if (n_pos > 0) "#### Match Heatmap"`

```{r heatmap-pos, eval = n_pos > 0, echo = n_pos > 0, fig.cap = glue("*The top-ranked motifs by positional bias showing the total number of matches within each bin. Motifs are clustered by similarity of totals within this figure.*")}
top_pos <- pos_res %>% 
  dplyr::filter(adj_p < motif_params$alpha) %>% 
  dplyr::slice(1:25) %>% 
  pull(altname)
motif_list %>% 
  dplyr::filter(altname %in% top_pos) %>% 
  to_list() %>% 
  getPwmMatches(
    fw_seq, abs = motif_params$abs, best_only = TRUE, mc.cores = threads
  ) %>% 
  plotMatchPos(
    abs = motif_params$abs, type = "heatmap", cluster = TRUE,
    use_totals = TRUE,
    # binwidth = floor(motif_params$binwidth / 2)
    binwidth = motif_params$binwidth 
  ) + labs(x = "Bin", fill = "Total\n Matches")
```


## Data Export 

```{r all-out}
all_out <- list(
  great_genomic_bg = here::here(
    "output", "results", "shared", "shared_great_results_genomic_bg.tsv.gz"
  ),
  great_targets_bg = here::here(
    "output", "results", "shared", "shared_great_results_targets_bg.tsv.gz"
  ),
  localz_shared_regions = here::here(
    "output", "results", "shared", "shared_regions_localz.tsv"
  ),
  localz_pairwise_targets = here::here(
    "output", "results", "shared", "pairwise_localz.tsv"
  )
)
great_df_genomic %>% 
  mutate(gene_id = map_chr(gene_id, paste, collapse = "; ")) %>% 
  write_tsv(all_out$great_genomic_bg)
great_df_targets %>% 
  mutate(gene_id = map_chr(gene_id, paste, collapse = "; ")) %>% 
  write_tsv(all_out$great_targets_bg)
localz_df %>% write_tsv(all_out$localz_shared_regions)
pairwise_df %>% write_tsv(all_out$localz_pairwise_targets)
```


Files exported during preparation of this document are:

`r pander(all_out)`

## References

<div id="refs"></div>

<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>

