---
title: "Comparison of Targets"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
---

```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```


```{r packages}
library(tidyverse)
library(yaml)
library(glue)
library(metap)
library(extraChIPs)
library(rGREAT)
library(msigdbr)
library(plyranges)
library(reactable)
library(htmltools)
library(magrittr)
library(tidygraph)
library(ggraph)
library(regioneR)
library(scales)
library(pander)
library(parallel)
library(patchwork)
library(regioneReloaded)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
panderOptions("big.mark", ",")
source(here::here("workflow/scripts/custom_functions.R"))
source(here::here("workflow/scripts/table_funs.R"))
```

```{r target-config}
config <- here::here("config", "config.yml") %>% read_yaml()
enrich_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("enrichment")
region_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("gene_regions")
network_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("networks")
targets <- here::here(config$samples) %>% 
  read_tsv() %>% 
  pull("target") %>% 
  unique()
threads <- detectCores() - 1
macs2_path <- here::here("output", "macs2")
samples <- file.path(macs2_path, targets, glue("{targets}_qc_samples.tsv")) %>% 
  lapply(read_tsv) %>% 
  bind_rows() %>% 
  dplyr::filter(qc == "pass") %>% 
  dplyr::select(-all_of("qc")) 
targets <- unique(samples$target)
n_targets <- length(targets)
```

```{r annotations}
annotation_path <- here::here("output", "annotations")
sq <- file.path(annotation_path, "seqinfo.rds") %>% 
  read_rds()
gtf_gene <- read_rds(file.path(annotation_path, "gtf_gene.rds"))
id2gene <- setNames(gtf_gene$gene_name, gtf_gene$gene_id)
tss <- read_rds(file.path(annotation_path, "tss.rds"))
gene_regions <- read_rds(here::here(annotation_path, "gene_regions.rds"))
external_features <- here::here(annotation_path, "features.rds") %>%
  read_rds()
all_feat <- c(gene_regions, external_features) %>% 
  endoapply(granges)
all_feat_labs <- c(
  map_chr(gene_regions, \(x) x$region[[1]]),
  map_chr(external_features, \(x) str_sep_to_title(x$feature[[1]]))
)
colours <- file.path(annotation_path, "colours.rds") %>% 
  read_rds()
target_colours <- RColorBrewer::brewer.pal(length(targets) + 1, "Set1") %>% 
  setNames(c(targets, "Shared"))
```



## Introduction

After performing individual analyses on the provided targets, this analysis performs a comparison of the regions with detected signal across all targets.
Comparisons were performed in a treatment-agnostic manner, using the sets of consensus peaks defined across all conditions, making this approach an analysis of the larger universe of regulation and pathways present within the cell type of interest,


## Peak Comparisons {.tabset}

```{r load-peaks}
consensus_peaks <- file.path(
  macs2_path, targets, glue("{targets}_consensus_peaks.bed.gz")
) %>% 
  importPeaks(seqinfo = sq, type = "bed") %>% 
  setNames(str_remove(names(.), "_consensus.+"))
## NB: for n = 2, this will be the union peaks
shared_peaks <- file.path(macs2_path, "shared", "shared_consensus_peaks.bed.gz") %>% 
  importPeaks(seqinfo = sq, type = "bed") %>% 
  setNames(str_remove(names(.), "_consensus.+")) %>% 
  unlist() %>% 
  unname() %>% 
  granges()
```

Consensus peaks from all targets (`r pander(targets)`) were loaded, and a set of common regions found.
Given that `r n_targets` were included in the dataset, the common regions were defined as the `r comma(length(shared_peaks))` overlapping regions across all targets, but where signal was detected in at least `r n_targets - 1` targets.
This ensures any individual targets with broader peaks do not lead to unrealistically broad common regions.

### Overlapping Regions

```{r plot-overlaps, fig.cap = glue("*Taking the combined overlap between any targets as the set of regions, the number of regions with each target overlapping these regions is shown below*")}
plotOverlaps(consensus_peaks, type = "upset", set_col = target_colours)
```

### Peak Widths

```{r boxplot-widths, fig.cap = glue("*Peak widths within each target showing the total number of peaks within each target*")}
consensus_peaks %>% 
  lapply(width) %>% 
  lapply(enframe, name = NULL, value = "width") %>% 
  bind_rows(.id = "target") %>%
  ggplot(aes(target, width, fill = target)) +
  geom_boxplot() +
  geom_label(
    aes(label = label),
    data = . %>% 
      summarise(n = dplyr::n(), width = min(width), .by = target) %>% 
      mutate(label = comma(n), width = min(width)),
    fill = "white", alpha = 0.7
  ) +
  scale_fill_manual(values = target_colours) +
  scale_y_log10(labels = comma, name = "Peak Width") +
  labs(x = "Target", fill = "Target")
```

### Distance to TSS 

```{r plot-shared-dist-to-tss-hist, fig.height=6, fig.cap = glue("*Distances from the centre of each set of consensus peaks to the nearest transcription start-site shown as A) a histogram, and B) as a cumulative distribution. The vertical dashed line indicates the range considered to be a promoter during annotation preparation. Shared peaks were removed from each set of consensus peaks to highlight any potential differences, and so that each peak is only included in one category.")}
df <- consensus_peaks %>% 
  endoapply(filter_by_non_overlaps, shared_peaks) %>% 
  c(GRangesList(Shared = shared_peaks)) %>% 
  endoapply(granges) %>% 
  lapply(
    \(x){
      join_nearest(x, mutate(tss, tss = start)) %>% 
        mutate(d = start + width/2 - tss) %>% 
        as_tibble()     
    }
  ) %>% 
  bind_rows(.id = "target") %>% 
  arrange(abs(d)) %>% 
  mutate(
    q = seq_along(d) / dplyr::n(), .by = all_of("target")
  )
A <- df %>% 
  ggplot(aes(d / 1e3, colour = target)) +
  geom_density() +
  coord_cartesian(xlim = c(-50, 50)) +
  scale_colour_manual(values = target_colours) +
  labs(
    x = "Distance To Nearest TSS (kb)",
    y = "Density"
  ) + 
  theme(legend.position = "none")
B <- df %>% 
  ggplot(aes(abs(d) / 1e3, q, colour = target)) +
  geom_line() +
  geom_vline(
    xintercept = max(unlist(region_params$promoters)) / 1e3, 
    linetype = 2, colour = "grey40"
  ) +
  coord_cartesian(xlim = c(0, 50)) +
  labs(
    x = "Absolute Distance to Nearest TSS (kb)",
    y = "Percentile", colour = "Target"
  ) +
  scale_colour_manual(values = target_colours) +
  scale_y_continuous(labels = percent, breaks = seq(0, 1, by = 0.2)) +
  scale_x_continuous(breaks = seq(0, 100, by = 20))
A + B + plot_annotation(tag_levels = "A")
```



## GREAT Enrichment  {.tabset}

```{r setup-great}
ucsc_ref <- map_great_refs(config$genome$build)
sp <- c(
  hg19 = "Homo sapiens", hg38 = "Homo sapiens", mm10 = "Mus musculus",
  mm39 = "Mus musculus", rn7 = "Rattus norvegicus", susScr11 = "Sus scrofa",
  canFam5 = "Canis lupus familiaris", dm6 = "Drosophila melanogaster",
  galGal6 = "Gallus gallus", panTro6 = "Pan troglodytes"
)[[ucsc_ref]]
ext_tss <- gtf_gene %>% 
  select(gene_id) %>% 
  extendTSS(
    genome = ucsc_ref, gene_id_type = 'ENSEMBL', 
    basal_upstream = region_params$promoters$upstream,
    basal_downstream = region_params$promoters$downstream
  ) 
ext_tss_ol <- subsetByOverlaps(ext_tss, shared_peaks)
msigdb <- msigdbr(sp) %>% 
  dplyr::filter(
    gs_cat %in% enrich_params$msigdb$gs_cat |
      gs_subcat %in% enrich_params$msigdb$gs_subcat,
    ensembl_gene %in% ext_tss$gene_id
  )
gs_list <- msigdb %>% 
  split(.$gs_name) %>% 
  lapply(pull, ensembl_gene) %>% 
  .[map_int(., length) <= enrich_params$max_size] %>% 
  .[map_int(., length) >= enrich_params$min_size] 
great_res <- great(
  set_genome_info(shared_peaks, genome = ucsc_ref), 
  gene_sets = gs_list, 
  extended_tss = set_genome_info(ext_tss, genome = ucsc_ref), 
  min_gene_set_size = enrich_params$min_size, 
  cores = threads
)
great_df <- getEnrichmentTable(great_res) %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  arrange(p_value_hyper) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, enrich_params$adj),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great <- sum(great_df$p_adjust_hyper < enrich_params$alpha)
```

In keeping with the analysis of each individual set of peaks, the `r comma(length(shared_peaks))`regions where all targets were detectable were analysed using `rRGEAT` [@Gu2023-rp] and identical parameterisation.
This gives clear insight into which pathways are likely to be regulated by all targets *acting in concert*, with `r n_great` gene-sets being considered as enriched within these shared regions.

### GREAT Results Table

```{r tbl-great-res}
tbl <- great_df %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>% 
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-all_of(c("p_value_hyper", "gene_id"))) %>% 
  dplyr::select(id, fold_enrichment_hyper, p_adjust_hyper, everything()) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE,
    columns = list(
      id = colDef(
        name = "Gene Set",
        cell = \(value) str_replace_all(value, "_", " "),
        minWidth = 180
      ),
      genome_fraction = colDef(show = FALSE),
      observed_region_hits = colDef(show = FALSE),
      fold_enrichment_hyper = colDef(
        name = "Fold Enrichment", format = colFormat(digits = 3),
        filterable = FALSE, minWidth = 110
      ),
      p_adjust_hyper = colDef(
        name = glue("P<sub>adj</sub> ({enrich_params$adj})"),
        html = TRUE, filterable = FALSE,
        cell = \(value) sprint_pval(value),
        maxWidth = 110
      ),
      mean_tss_dist = colDef(
        "Mean TSS Distance (kb)", 
        cell = \(value) round(value / 1e3, 2),
        filterable = FALSE
      ),
      observed_gene_hits = colDef(
        "Gene Hits", maxWidth = 100, filterable = FALSE
      ),
      gene_set_size = colDef(
        "Gene Set Size", maxWidth = 100, filterable = FALSE
      ),
      genes_with_hits = colDef(
        name = "Genes",
        cell = \(value) with_tooltip(value, width = 60),
        minWidth = 200
      )
    )
  )
cp <- htmltools::em(
  glue(
    "Enrichment results for regions showing consistently detectable signal for all of ",
    glue_collapse(targets, sep = ", ", last = " and "),
    " as considered significant when using rGREAT. ", 
    "Backround regions to determine relative enrichment were taken as the entire genome. ",
    "In the case of large numbers of significant gene-sets, results are limited to the 100 most highly ranked. ",
    "The genes listed are those associated with the set of shared regions."
  )
)
div(class = "table",
    div(class = "table-header",
        div(class = "caption", cp), tbl
    )
)
```

`r if (n_great >= network_params$min_size) "### Enrichment Network"`

```{r great-network, echo = n_great >= network_params$min_size, eval = n_great >= network_params$min_size, fig.cap = glue("*The {n_great} most highly ranked gene sets from rGREAT analysis. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with all targets detected. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {network_params$max_size} gene sets*")}
tg_great <- great_df %>% 
  dplyr::filter(p_adjust_hyper < enrich_params$alpha) %>%
  make_tbl_graph(
    gs = great_df[["gene_id"]], 
    alpha = enrich_params$alpha, p_col = "p_adjust_hyper", gs_col = "id", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = network_params$max_size
  )
if (length(tg_great) >= network_params$min_size) {
  tg_great %>% 
    mutate(
      ## The lowest p-value obtainable from pbinom is 1e-16
      p_value_hyper = ifelse(p_value_hyper > 0, p_value_hyper, 1e-16),
      prop = observed_gene_hits / gene_set_size 
    ) %>% 
    ggraph(layout = network_params$layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p_value_hyper), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, max.overlaps = max(10, round(length(tg_great) / 4, 0)),
      bg.color = "white", bg.r = 0.1, 
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```

### TSS Distribution

```{r plot-top-great, fig.height=6, fig.cap = glue("*The distribution of shared regions around the TSS for the most highly ranked gene-set ({top_id})*")}
top_id <- great_df$id[1]
plotRegionGeneAssociations(great_res, top_id, which = 2:3)
```


```{r}
knitr::opts_chunk$set(eval = FALSE, echo = FALSE)
```


## Region Comparisons

The package 


```{r}
## Now we can step through the peaks & match the other two
mlz_list <- names(consensus_peaks) %>% 
  lapply(
    \(i) {
      multiLocalZscore(
        A = consensus_peaks[[i]],
        Blist = consensus_peaks[setdiff(names(consensus_peaks), i)],
        ranFUN = "resampleGenome",
        evFUN = "numOverlaps",
        window = 5e3,
        ntimes = 500, # Ramp up to 5K for an HPC
        adj_pv_method = enrich_params$adj,
        max_pv = 1,
        genome = ucsc_ref,
        mc.cores = threads
      )
    }
  ) %>% 
  setNames(names(consensus_peaks))
dist_df <- mlz_list %>% 
  lapply(
    function(x) {
      mlz <- slot(x, "multiLocalZscores")
      tbl <- as_tibble(mlz$shifed_ZSs)
      tbl$shift <- mlz$shifts
      tbl
    }
  ) %>% 
  bind_rows(.id = "Query") %>% 
  pivot_longer(
    cols = all_of(names(consensus_peaks)), names_to = "Target", values_to = "Z"
  ) %>% 
  dplyr::filter(!is.na(Z)) %>% 
  mutate(
    Z = Z / sqrt(map_int(consensus_peaks, length)[Query]),
    Target = factor(Target, levels = names(consensus_peaks)) %>% fct_rev(),
    Query = factor(Query, levels = names(consensus_peaks)) %>% fct_rev()
  )
dist_df %>% 
  arrange(desc(Z)) %>%
  mutate(
    Query = fct_inorder(Query),
    Target = fct_inorder(Target)
  ) %>%
  ggplot(aes(shift, Z, colour = Target)) +
  geom_line() +
  facet_wrap(~Query) +
  scale_x_continuous(
    labels = \(x) x * 1e-3, name = "Shift (kb)"
  ) +
  scale_y_continuous(
    expand = expansion(c(0, 0.05)), name = expr(paste(Z[norm]))
  ) +
  scale_color_brewer(palette = "Set1") 
## Form a table
res_df <- mlz_list %>% 
  lapply(slot, "multiLocalZscores") %>% 
  lapply(pluck, "resumeTab") %>% 
  bind_rows(.id = "Query") %>% 
  dplyr::rename(Target = name) %>% 
  mutate(
    n_regionA = map_int(consensus_peaks, length)[Query],
    n_regionB = map_int(consensus_peaks, length)[Target],
    prop = n_overlaps / map_int(consensus_peaks, length)[Query],
    enrichment = log2(n_overlaps / mean_perm_test),
    p_value = 1 - pchisq(norm_zscore^2, 1),
    adj.p_value = p.adjust(p_value, enrich_params$adj)
  ) 
res_df %>%
  dplyr::select(
    Query, Target, n_regionA, n_regionB, prop, n_overlaps, mean_perm_test, 
    enrichment, norm_zscore, adj.p_value
  ) %>% 
  reactable(
    columns = list(
      Query = colDef(maxWidth = 85),
      Target = colDef(maxWidth = 85),
      n_regionA = colDef("Query Regions", format = comma_col),
      n_regionB = colDef("Target Regions", format = comma_col),
      prop = colDef("% Query", format = colFormat(percent = TRUE, digits = 1)),
      n_overlaps = colDef("Overlaps", format = comma_col),
      mean_perm_test = colDef("Expected", format = comma_col),
      enrichment = colDef(
        "log<sub>2</sub> Enrichment", format = colFormat(digits = 2),
        html = TRUE,
        style = \(value) {
          text_colour = ifelse(value < 0, colours$direction[["decreaeds"]], "black")
          list(color = text_colour)
        }
      ),
      norm_zscore = colDef(
        "Z", format = colFormat(digits = 2),
        style = \(value) {
          text_colour = ifelse(value < 0, colours$direction[["decreaeds"]], "black")
          list(color = text_colour)
        }
      ),
      adj.p_value = colDef(
        glue("p<sub>{enrich_params$adj}</sub>"), html = TRUE,
        cell = \(value) sprint_pval(value),
        style = \(value) {
          text_colour = ifelse(
            value < enrich_params$alpha, "black", colours$direction[["unchanged"]]
          )
          list(color = text_colour)
        }
      )
    )
  )

res_df %>% 
  ggplot(aes(Target, Query, fill = norm_zscore)) +
  geom_raster() +
  geom_label(
    aes(label = prop),
    data = . %>% 
      mutate(
        prop = percent(prop, 0.1),
        prop = case_when(
          adj.p_value < enrich_params$alpha ~ paste0(prop, "*"),
          TRUE ~ prop
        )
      ),
    fill = "white", alpha = 0.6
  ) +
  scale_x_discrete(expand = expansion(0, 0)) +
  scale_y_discrete(expand = expansion(0, 0)) +
  scale_fill_gradientn(
    colours = heat_col,
    limits = c(-1.05, 1.05) * max(abs(res_df$norm_zscore)),
    name = expr(paste(Z[norm]))
  ) +
  theme(panel.grid = element_blank())

```


Next is to compare the shared peaks against the set of regions in exactly the same way as for each individual set of peaks.

- Create the set of shared peaks using a new rule
- Run the regioner analysis on this set of peaks
- These can also be used to generate sequences for motif enrichment




```{r}
## Try a single RS against a multi-RS set
cpt_feat <- crosswisePermTest(
  A = list(`Shared Peaks` = set_genome_info(shared_peaks, ucsc_ref)), # List...
  B = all_feat %>% set_genome_info(ucsc_ref), 
  mc.cores = threads, 
  sampling = FALSE,
  ranFUN = "resampleGenome",
  evFUN = "numOverlaps",
  genome = ucsc_ref,
  ntimes = 1000 # Set to 5K for HPC
)


## How do these p-values compare to the ones from Z-scores?
slot(cpt_feat, "multiOverlaps")[["Shared Peaks"]]
slot(mlz, "multiLocalZscores")$resumeTab
## This fails!!!
cpt_feat %>% 
  makeCrosswiseMatrix() %>% 
  plotCrosswiseMatrix() +
  scale_x_discrete(
    expand = expansion(0, 0), name = NULL,
    labels = \(x) str_wrap(str_sep_to_title(x), 20)
  ) +
  scale_y_discrete(expand = expansion(0, 0), name = NULL) +
  labs(fill = expr(paste(Z[norm]))) +
  theme(
    plot.title = element_blank(),
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 10)
  ) 
slot(cpt_feat, "multiOverlaps") %>% 
  bind_rows(.id = "Query") %>% 
  dplyr::rename(Target = "name") %>% 
  mutate(
    Target = factor(Target, levels = names(all_feat)),
    prop = n_overlaps / n_regionA
  ) %>% 
  ggplot(aes(Target, Query, fill = norm_zscore)) +
  geom_raster() +
  geom_label(aes(label = percent(prop, 0.1))) +
  scale_x_discrete(expand = rep_len(0, 4)) +
  scale_y_discrete(expand = rep_len(0, 4)) +
  scale_fill_gradientn(
    colours = heat_col, 
    limits = c(-1.05, 1.05) * max(abs(slot(cpt_feat, "multiOverlaps")[[1]]$norm_zscore))
  )
## Or is it just easier:
slot(mlz, "multiLocalZscores")$resumeTab %>% 
  as_tibble() %>% 
  mutate(
    prop = n_overlaps / length(shared_peaks),
    name = all_feat_labs[name]
  ) %>% 
  dplyr::select(
    name, n_overlaps, prop, norm_zscore, adj.p_value
  )
```



