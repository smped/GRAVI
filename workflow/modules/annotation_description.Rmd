
```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```

```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(yaml)
library(reactable)
library(htmltools)
library(plyranges)
library(GenomicInteractions)
library(extraChIPs)
library(GenomeInfoDb)
library(universalmotif)
```


```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
source(here::here("workflow", "scripts", "custom_functions.R"))
config <- read_yaml(here::here("config", "config.yml"))
all_paths <- here::here("config", "json", "all_paths.json") %>% 
    jsonlite::fromJSON()
all_out <- lapply(params, here::here)
```

```{r config}
region_params <- read_yaml(here::here("config", "params.yml")) %>%
  pluck("gene_regions")
motif_params <- read_yaml(here::here("config", "params.yml")) %>%
  pluck("motifdb")
msigdb_params <- read_yaml(here::here("config", "params.yml")) %>%
  pluck("msigdb")
colours <- read_yaml(here::here("config", "colours.yml"))
treat_levels <- config$comparisons$contrasts %>% 
  unlist() %>% 
  unique()
samples <- here::here(config$samples$file) %>%
  read_tsv() %>% 
  mutate(
    treat = factor(treat, levels = unique(c(treat_levels, treat))),
    target = as.factor(target)
  )
targets <- unique(samples$target)
treat_levels <- levels(samples$treat)
has_external <- length(config$external$coverage) > 0
if (has_external) {
  treat_levels <- c(
    treat_levels,
    lapply(config$external$coverage, names) %>% unlist()
  ) %>% 
    unique()
}
```


# Genome Annotations

Before analysing any datasets, annotations for the genome and transcriptome were checked and key objects were defined for consistent use throughout the workflow.

## Genome Description

```{r sq}
sq <- read_rds(all_out$seqinfo)
```

As the foundation for all annotation objects, the description of the underlying genome is required as a `Seqinfo` object.
For this workflow, both the mitochondrial genome and any scaffolds are excluded, giving only the autosomes and the X/Y chromosomes.
This `Seqinfo` object is added to all subsequent objects requiring information about the underlying genome, such as a `GenomicRanges` object.

## Blacklisted Regions {.tabset}

Blacklisted regions were supplied in `r pander(unname(unlist(config$external$blacklist)))`.
In addition, grey-listed regions were derived from all the input sample(s), `r pander(unique(samples$input))`

```{r blacklist}
ip <- unique(samples$input)
bl <- unlist(config$external$blacklist)
exclude_ranges <- bl %>% 
  here::here() %>% 
  c(
    here::here(all_paths$greylist, glue("{ip}_greylist.bed.gz"))
  ) %>% 
  importPeaks(type = "bed", seqinfo = sq) %>% 
  setNames(c(basename(bl), ip))
```

### Similarity Between Black & Grey Lists

```{r plot-excluded-ranges, fig.width=7, fig.height=7, fig.cap = "Number of regions identified as blacklisted"}
plotOverlaps(exclude_ranges, set_col = seq_along(exclude_ranges))
```


### Breakdown By Chromosome

```{r plot-blacklist, fig.height = 7, fig.cap = "*Breakdown of blacklisted, greylisted and whitelisted, regions by chromosome. If multiple input samples were provided, greylisted regions will be variable across samples.*"}
exclude_ranges %>% 
  unlist() %>% 
  names_to_column("source") %>% 
  reduceMC() %>% 
  mutate(
    source = map_chr(
      source, \(x) ifelse(any(basename(bl) %in% x), "blacklisted", "greylisted")
    )
  ) %>% 
  c(
    setdiff(GRanges(sq), .) %>% mutate(source = "whitelisted")
  ) %>% 
  sort() %>% 
  select(source) %>% 
  as_tibble(rangeAsChar = FALSE) %>% 
  mutate(
    seqnames = fct_rev(seqnames),
    ymin = as.integer(seqnames) - 0.35, ymax = as.integer(seqnames) + 0.35,
    source = str_to_title(source)
  ) %>% 
  ggplot(aes(fill = source)) +
  geom_rect(
    aes(xmin = start, xmax = end, ymin = ymin, ymax = ymax)
  ) +
  scale_x_continuous(expand = expansion(c(0.01, 0.01)), labels = comma_format(scale = 1e-6)) +
  scale_y_continuous(
    expand = expansion(c(0.02, 0.02)), labels = rev(seqnames(sq)), 
    breaks = seq_along(seqnames(sq))
  ) +
  scale_fill_manual(
    values = c(
      Whitelisted = "lightblue", Greylisted = "grey", Blacklisted = "black"
    )
  ) +
  labs(x = "Chromosome Position (MB)", fill = "Status") +
  theme_classic() +
  theme(
    legend.position = "inside",
    legend.position.inside = c(0.9, 0.15)
  )
```


# Gene and Transcript Annotations

## Basic Annotations

```{r load-gtf}
gtf_gene <- read_rds(all_out$gtf_gene)
gtf_transcript <- read_rds(all_out$gtf_transcript)
gtf_exon <- read_rds(all_out$gtf_exon)
```

- The complete set of genes, transcripts and exons was loaded from the supplied `gtf`, excluding mitochondrial features.
- The previously generated `Seqinfo` was also placed as the foundation of this annotation object, ensuring this propagates through all subsequent objects
- Version numbers were removed from all gene, transcript and exon identifiers for convenience, with the minimal set of columns (`r pander(colnames(mcols(gtf_gene)))`) retained.
- Visualisation using the Bioconductor package `Gviz` requires a specific `GRanges` structure for gene and transcript models to be displayed.
This object was created at this point so transcript models could be simply visualised throughout the workflow.

In total this annotation build contained `r comma(length(gtf_gene))` genes, `r comma(length(gtf_transcript))` transcripts and `r comma(length(gtf_exon))` exons, after restricting the dataset to the autosomes and sex chromosomes.


## Gene-Centric Regions {.tabset}


```{r define-region-colours}
gene_regions <- read_rds(all_out$gene_regions)
regions <- vapply(gene_regions, function(x) unique(x$region), character(1))
missing_reg_col <- setdiff(names(regions), names(colours$regions))
if (length(missing_reg_col) > 0) {
  def_reg_cols <- c(
    promoter = "#FF3300", upstream_promoter = "#E1EE05", exon = "#7EDD57", 
    intron = "#006600", proximal_intergenic = "#000066", distal_intergenic = "#551A8B"
  )
  colours$regions[missing_reg_col] <- def_reg_cols[missing_reg_col]
}
region_cols <- unlist(colours$regions) %>% 
  setNames(regions[names(.)])
```


Using the provided GTF, **unique** gene and transcript-centric features were also defined using `defineRegions()`, and will be treated as annotated regions throughout the workflow.
The regions are:

1. Promoters (-`r region_params$promoters$upstream`/+`r region_params$promoters$downstream`bp)
2. Upstream Promoters (> `r region_params$promoters$upstream`bp; < `r region_params$upstream`bp)
3. Exons
4. Introns
5. Intergenic regions within `r region_params$intergenic/1e3`kb of a gene
6. Intergenic regions >`r region_params$intergenic/1e3`kb from any defined genes

Colours were also defined for each of these regions for consistent visualisation.

In addition, TSS regions were defined as a separate object given each TSS has single-base width. 
With the exception of TSS and Promoters, these features were non-overlapping and defined in a hierarchical, un-stranded manner.
*TSS* regions represent the individual start sites for each transcript, and given that many transcripts can originate from the same TSS, this is somewhat smaller than the number of actual transcripts defined in the GTF.


```{r tab-regions}
cp <- em(
  glue(
    "
  Summary of gene-centric regions defined as a key annotation set. 
  Colours used throughout the workflow for each region are indicated in the 
  first column, with other summary statistics making up the rest of the table.
  "
  )
)
tbl <- gene_regions %>% 
  lapply(
    function(x){
      tibble(
        n = length(x),
        width = sum(width(x)), 
        region = unique(x$region)
      )
    }
  ) %>%
  bind_rows() %>% 
  mutate(
    width = width / 1e6,
    mn = 1e3*width/n,
    region = fct_inorder(region),
    `% Genome` = width / sum(width),
  ) %>% 
  rename_all(str_to_title) %>% 
  mutate(Guide = region_cols[Region]) %>% 
  dplyr::select(
    Guide, Region, N, Width, Mn, `% Genome`
  ) %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      Guide = colDef(
        maxWidth = 50,
        style = function(value) list(background = value),
        cell = function(value) "",
        name = ""
      ),
      Region = colDef(minWidth = 200),
      N = colDef(
        maxWidth = 150,
        cell = function(value) comma(value, 1)
      ),
      Width = colDef(
        name = "Total Width (Mb)",
        cell = function(value) sprintf("%.1f", value)
      ),
      Mn = colDef(
        name = "Average Width (kb)",
        cell = function(value) sprintf("%.2f", value)
      ),
      "% Genome" = colDef(
        cell = function(value) percent(value, 0.1)
      )
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

### Summary

```{r pie-gene-regions, fig.height=8, fig.width=8, fig.cap = "*Summary of gene-centric regions using `defineRegions()` and the supplied GTF. Percentages represent the amount of the genome allocated to each region with total widths shown in Mb. Blacklisted regions were not considered for this step of the annotation.*"}
gene_regions %>% 
  lapply(select, region) %>% 
  GRangesList() %>% 
  unlist() %>% 
  mutate(region = factor(region, levels = regions)) %>% 
  setNames(NULL) %>%
  plotPie(
    fill = "region", scale_by = "width", scale_factor = 1e6,
    total_glue = "{comma(N, 0.1)}Mb", total_size = 4.5,
    cat_glue = "{str_wrap(.data[[fill]], 10)}\n{comma(n, 0.1)}Mb\n({percent(p, 0.1)})",
    cat_alpha = 0.8, cat_adj = 0.1, cat_size = 3.5
  ) +
  scale_fill_manual(values = region_cols) +
  theme(legend.position = "none")
```

### Example

```{r example-id}
id <- sort(gtf_gene$gene_id)[[1]]
```


```{r plot-example, fig.height=7, fig.cap = paste("*12kb region surrounding", collapseGenes(subset(gtf_gene, gene_id == id)$gene_name), "showing all annotated regions.*")}
gr <- subset(gtf_gene, gene_id == id) %>% 
  resize(width = width(.) + 2.4e4, fix = 'center') %>% 
  unstrand()
ft <- gene_regions %>% 
  lapply(subsetByOverlaps, gr) %>% 
  lapply(select, region) %>% 
  lapply(intersectMC, gr) %>% 
  GRangesList() %>% 
  unlist() %>% 
  setNames(c()) %>% 
  subset(region != "TSS") %>% 
  sort()
df <- list(
  gtf_transcript %>% 
    subsetByOverlaps(gr) %>% 
    as_tibble(rangeAsChar = FALSE),
  gtf_exon %>% 
    subsetByOverlaps(gr) %>% 
    as_tibble(rangeAsChar = FALSE) 
) %>% 
  bind_rows() %>% 
  mutate(
    transcript_name = as.factor(transcript_name)
  )
df %>% 
  ggplot(aes(x = start, y = as.integer(transcript_name))) +
  geom_rect(
    aes(
      xmin = start, xmax = end,
      ymin =  0, ymax =  Inf,
      fill = region
    ),
    data = ft %>%
      as.data.frame() %>% 
      mutate(region = fct_inorder(region) ),
    inherit.aes = FALSE,
    alpha = 0.6
  ) +
  geom_segment(
    aes(
      x = start, xend = end, 
      y = as.integer(transcript_name),
      yend = as.integer(transcript_name)
    ),
    data = . %>% 
      dplyr::filter(type == "transcript")
  ) +
  geom_segment(
    aes(
      x = mid, xend = mid_offset, 
      y = as.integer(transcript_name),
      yend = as.integer(transcript_name)
    ),
    data = gtf_transcript %>% 
      subsetByOverlaps(gr) %>% 
      select(transcript_name) %>% 
      setdiffMC(gtf_exon) %>%
      as.data.frame() %>% 
      mutate(transcript_name = vctrs::vec_proxy(transcript_name)) %>% 
      unnest(transcript_name) %>% 
      dplyr::filter(width > 600) %>% 
      mutate(
        mid = end - 0.5*width,
        mid_offset = ifelse(strand == "+", mid + 50, mid - 50),
        transcript_name = factor(transcript_name, levels = levels(df$transcript_name))
      ),
    arrow = arrow(angle = 40, length = unit(0.015, "npc"))
  ) +
  geom_rect(
    aes(
      xmin = start, xmax = end, 
      ymin = as.integer(transcript_name) - 0.2, 
      ymax = as.integer(transcript_name) + 0.2
    ),
    data = . %>% 
      dplyr::filter(type == "exon"),
    fill = "blue", colour = "blue"
  ) +
  coord_cartesian(xlim = c(start(gr), end(gr))) +
  scale_x_continuous(
    labels = comma, expand = expansion(c(0, 0))
  ) +
  scale_y_continuous(
    breaks = seq_along(levels(df$transcript_name)),
    labels = levels(df$transcript_name),
    expand = expansion(c(-0.05, 0.05))
  ) +
  scale_fill_manual(values = region_cols) + 
  labs(
    x = as.character(seqnames(gr)), y = "Transcript", fill = "Feature"
  ) +
  theme(panel.grid = element_blank())
```

# Enrichment Analysis

The same approach to enrichment analysis is defined to be used in all steps of the analysis.

The [MSigDB](https://www.gsea-msigdb.org/gsea/msigdb/) database version `r packageVersion("msigdbr")` was used [@Liberzon2011-fr].
Gene-sets and pathways were retained if more than `r min(msigdb_params$size)` genes and fewer than `r max(msigdb_params$size)` genes were assigned to it.
This left the following breakdown of gene-sets and pathways tested for enrichment during all steps.

```{r tbl-msigdb}
msigdb <- here::here(all_paths$annotation, "msigdb.rds") %>% read_rds()
msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name) %>%
  summarise(`Gene Sets` = dplyr::n(), .by = ends_with("cat")) %>% 
  dplyr::rename(Category = gs_cat, `Sub-Category` = gs_subcat) %>% 
  mutate(
    Description = case_when(
      Category == "H" ~ "Hallmark Gene-Sets",
      Category == "C1" ~ "Positional Gene Sets",
      Category == "C2" ~ str_replace_all(`Sub-Category`, "CP:(.+)", "Curated Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "TFT") ~ str_replace_all(`Sub-Category`, "TFT:(.+)", "Transcription Factor Target Prediction Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "MIR") ~ str_replace_all(`Sub-Category`, "MIR:(.+)", "microRNA Target Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "CGN") ~ "Cancer Gene Neighbourhoods",
      str_detect(`Sub-Category`, "CM") ~ "Cancer Modules",
      str_detect(`Sub-Category`, "GO:BP") ~ "Gene Ontology: Bological Process",
      str_detect(`Sub-Category`, "GO:MF") ~ "Gene Ontology: Molecular Function",
      str_detect(`Sub-Category`, "GO:CC") ~ "Gene Ontology: Cellular Component",
      str_detect(`Sub-Category`, "HPO") ~ "Human Phenotype Ontology",
      Category == "C6" ~ "Oncogenic Signature Gene Sets",
      `Sub-Category` == "IMMUNESIGDB" ~ "ImmuneSigDB Gene Sets",
      `Sub-Category` == "VAX" ~ "Vaccine Response Gene Sets",
      Category == "C8" ~ "Cell Type Signature Gene Sets"
    ),
    Category = factor(Category, levels = c("H", paste0("C", 1:8)))
  ) %>% 
  droplevels() %>% 
  arrange(Category) %>% 
  bind_rows(
    tibble(Category = "Total", `Gene Sets` = sum(.[["Gene Sets"]]))
  ) %>% 
  pander(
    justify = "llrl", 
    caption = "*Summary of Gene-Sets used for Enrichment Testing*",
    emphasize.strong.rows = which(grepl("Total", .$Category))
  )
```

# Transcription Factor Motifs 

```{r tf-db}
tf_db <- read_rds(all_out$motif_list) %>% 
  to_df() %>% 
  as_tibble() %>% 
  mutate(cluster = fct_infreq(cluster))
top3 <- levels(tf_db$cluster)[1:3]
if (!is.null(config$external$motifdb)) 
  motif_params$data_source <- basename(config$external$motifdb)
```

Transcription factor binding motifs (TFBMs) were prepared from `r pander(motif_params$data_source)` with `r nrow(tf_db)` motifs prepared for downstream analysis.
Whilst *all motifs will be retained for testing*, highly similar motifs were clustered to enable easier reporting and interpretation.
Pairwise correlations between motifs were found during preparation and those where $\rho \geq$ `r motif_params$cluster_above` were clustered, giving a final set of `r max(as.integer(tf_db$cluster))` clusters.
`r sum(table(tf_db$cluster) == 1)` TFBMs remained un-clustered.
The largest groups of clustered motifs contains:

`r tf_db %>% dplyr::filter(cluster %in% top3) %>% droplevels() %>% split(.$cluster) %>% lapply(pull, "name") %>% unname() %>% pander()`

```{r plot-tf-clusters, fig.height=6, fig.cap = glue("*Breakdown of the {max(as.integer(tf_db$cluster))} clusters formed amongst the {nrow(tf_db)} selected TFBMs*")}
table(tf_db$cluster) %>% 
  enframe(name = "cluster", value = "motifs") %>% 
  mutate(motifs = as.factor(motifs)) %>% 
  summarise(n = dplyr::n(), .by = motifs) %>% 
  ggplot(aes(motifs, n)) + 
  geom_col() +
  geom_label(aes(y = n + 0.05 * max(n), label = comma(n))) +
  labs(x = "Motifs in Cluster", y = "Number of Clusters") +
  scale_y_continuous(expand = expansion(c(0, 0.05)))
```

## TFBM Cluster Visualisation {.tabset}

As a check on the clustering strategy described above, the Information Content Matrices (ICM) for the largest three clusters are shown below.

### Cluster 1

```{r tf-cl1, fig.cap = glue("*Information Content logos for all TFBMs within the largest cluster. Reverse complement sequences from the defined matrix are annotated with RC.*")}
tf_db %>% 
  dplyr::filter(cluster == top3[[1]]) %>% 
  to_list() %>% 
  view_motifs(names.pos = "right")
```

### Cluster 2

```{r tf-cl2, fig.cap = glue("*Information Content logos for all TFBMs within the second largest cluster. Reverse complement sequences from the defined matrix are annotated with RC.*")}
tf_db %>% 
  dplyr::filter(cluster == top3[[2]]) %>% 
  to_list() %>% 
  view_motifs(names.pos = "right")
```

### Cluster 3

```{r tf-cl3, fig.cap = glue("*Information Content logos for all TFBMs within the third largest cluster. Reverse complement sequences from the defined matrix are annotated with RC.*")}
tf_db %>% 
  dplyr::filter(cluster == top3[[3]]) %>% 
  to_list() %>% 
  view_motifs(names.pos = "right")
```


# External Features

```{r external-features}
external_features <- here::here(all_paths$annotation, "features.rds") %>% 
  read_rds()
has_features <- length(external_features) > 0
```

```{r feat-col, eval = has_features, echo = has_features}
feat_col <- colours$features
feat_levels <- names(external_features)
missing_feat_col <- setdiff(feat_levels, names(feat_col))
if (length(missing_feat_col) > 0) {
  if (!"no_feature" %in% feat_levels)
    missing_feat_col <- c(missing_feat_col, "no_feature")
  n <- length(missing_feat_col) 
  feat_col[missing_feat_col] <- hcl.colors(max(9, n), "Spectral")[seq_len(n)]
}
colours$features <- feat_col
```


`r ifelse(!has_features, "No external features were supplied.", "External features were compared to the gene-centric annotations.")`

```{r plot-feature-by-region, fig.height = 7, eval = has_features, echo = has_features, fig.cap = glue("*The proportion of the ranges provided as external features in the file {basename(config$external$feature)}, and which overlap the gene-centric regions defined above. Values were estimated using the proportion of bases within each feature that overlap each of the regions.*")}
external_features %>% 
  unlist() %>% 
  as_tibble() %>% 
  dplyr::select(range, feature, all_of(names(gene_regions))) %>% 
  pivot_longer(
    cols = all_of(names(gene_regions)), names_to = "region", values_to = "p"
  ) %>% 
  mutate(region = regions[region]) %>% 
  plotSplitDonut(
    inner = "feature", outer = "region", scale_by = "p", scale_factor = 1,
    inner_palette = colours$feature, outer_palette = region_cols,
    inner_glue = "{str_wrap(.data[[inner]], 10)}\n{comma(n, 1)}\n{percent(p,0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 15)}\n{percent(p,0.1)}",
  )
```


```{r tab-features, eval = has_features, echo = has_features}
cp <- em(
  glue(
      "Summary of external features provided in the file ", 
      "{basename(config$external$feature)}. All peaks and windows will be ", 
      "compared to these throughout the workflow. The colours defined for each ",
      "feature is show as a guide on the left."
    )
)
tbl <- external_features %>% 
  unlist() %>% 
  mutate(w = width) %>%
  as_tibble() %>% 
  dplyr::rename(width = w) %>%
  group_by(feature) %>% 
  summarise(
    N = dplyr::n(),
    Width = sum(width/1e3),
    med = median(width/1e3),
    range = glue("[{round(min(width/1e3), 1)}, {round(max(width/1e3), 1)}]")
  ) %>% 
  mutate(
    guide = unlist(feat_col)[feature],
    feature = factor(feature, levels = names(feat_col)) %>%
      fct_relabel(str_sep_to_title)
  ) %>%
  arrange(feature) %>%
  dplyr::select(guide, everything()) %>% 
  reactable(
    filterable = FALSE, searchable = FALSE,
    columns = list(
      guide = colDef(
        maxWidth = 40,
        style = function(value) list(background = value),
        cell = function(value) "",
        name = ""
      ),
      feature = colDef(
        name = "Feature",
        footer = htmltools::tags$b("Total")
      ),
      N = colDef(
        cell = function(value) comma(value, 1),
        footer = htmltools::tags$b(comma(sum(.$N)))
      ),
      Width = colDef(
        name = "Total Width (kb)",
        cell = function(value) comma(value, 1),
        footer = htmltools::tags$b(comma(sum(.$Width), 1))
      ),
      med = colDef(
        name = "Median Width (kb)",
        cell = function(value) sprintf("%.2f", value)
      ),
      range = colDef(name = "Size Range (kb)", align = "right")
    )
  )
div(class = "table",
  div(class = "table-header",
      div(class = "caption", cp),
      tbl
  )
)
```

# RNA Datasets

```{r has-rna, echo=FALSE}
rna <- read_rds(all_out$rna)
has_rna <- length(rna) > 0
txt <- ifelse(
  has_rna,
  paste(
    length(rna), "transcriptomic datasets were provided, as summarised below.",
    "Note that no differentially expressed (DE) genes are required for data integration."
  ),
  "No transcriptomic datasets were provided"
)
```

`r txt`

```{r show-rna, eval = has_rna, echo = has_rna}
rna %>% 
  bind_rows(.id = "Dataset") %>% 
  summarise(
    Detected = dplyr::n(), 
    `Up-Regulated` = sum(logFC > 0 & FDR < 0.05),
    `Down-Regulated` = sum(logFC < 0 & FDR < 0.05),
    `Total DE` = `Up-Regulated` + `Down-Regulated`,
    .by = Dataset
  ) %>% 
  pander(
    justify = "lrrrr",
    caption = "Summary of all provided transcriptomic datasets"
  )
```


# HiC Data {.tabset}

```{r has-hic, echo = FALSE}
hic <- read_rds(all_out$hic)
has_hic <- length(hic) > 0
```

```{r load-hic, eval = has_hic, echo = has_hic}
reg_combs <- expand.grid(regions, regions) %>% 
  as.matrix() %>% 
  apply(
    MARGIN = 1, 
    function(x) {
      x <- sort(factor(x, levels = regions))
      paste(as.character(x), collapse = " - ")
    }
  ) %>% 
  unique()
hic$regions <- anchors(hic) %>%
  vapply(
    bestOverlap,
    y = GRangesList(lapply(gene_regions, granges)),
    character(length(hic))
  ) %>%
  apply(MARGIN = 2, function(x) regions[x]) %>%
  apply(
    MARGIN = 1,
    function(x) {
      x <- sort(factor(x, levels = regions))
      paste(as.character(x), collapse = " - ")
    }
  ) %>%
  factor(levels = reg_combs) %>%
  fct_relabel(
    str_replace_all,
    pattern = "Promoter \\([0-9kbp/\\+-]+\\)", replacement = "Promoter"
  )
```

`r ifelse(has_hic, glue("HiC data with {comma(length(hic), 1)} interaction pairs was provided and loaded."), "No HiC Data was supplied as an input.")`

`r ifelse(has_hic, "## Genomic Distribution of Interaction Pairs", "")`

```{r plot-pie-hic, eval = has_hic, echo = has_hic, fig.cap = "*Distribution of interaction pairs using pre-defined genomic regions. Region pairs with an interaction frequency < 1% were grouped into the 'Other' category*"}
hic %>% 
  as_tibble() %>% 
  mutate(
    regions = fct_lump_prop(regions, prop = 0.01)
  ) %>%
  plotPie(fill = "regions", min_p = 0.02, category_width = 20, label_size = 4) +
  labs(fill = "Interacting\n Regions") +
  scale_fill_viridis_d(direction = -1)
```

`r ifelse(has_hic & has_features, "## Feature Distribution of Interaction Pairs", "")`

```{r plot-pie-features, eval = has_features & has_hic, echo = has_features & has_hic, fig.cap = glue("*Distribution of HiC interaction pairs using the features provided above. Feature pairs with an interaction frequency < 1% were grouped into the 'Other' category*")}
feat_combs <- expand.grid(names(feat_col), names(feat_col)) %>% 
  as.matrix() %>% 
  apply(
    MARGIN = 1, 
    function(x) {
      x <- sort(factor(x, levels = names(feat_col)))
      paste(as.character(x), collapse = " - ")
    }
  ) %>% 
  unique()
hic$features <- vapply(
  anchors(hic),
  function(x) bestOverlap(
    x, external_features, var = "feature", missing = "no_feature"
  ),
  character(length(hic))
)  %>% 
  apply(
    MARGIN = 1, 
    function(x) {
      x <- sort(factor(x, levels = names(feat_col)))
      paste(as.character(x), collapse = " - ")
    }
  ) %>% 
  factor(levels = feat_combs) %>%
  fct_relabel(str_sep_to_title, pattern = "_")
hic %>% 
  as_tibble() %>% 
  mutate(
    features = fct_lump_prop(features, prop = 0.01)
  ) %>% 
  plotPie(fill = "features", min_p = 0.02, category_width = 15, label_size = 4) +
  labs(fill = "Interacting\n Features") +
  scale_fill_viridis_d(direction = -1)
```


# Colour Schemes {.tabset}

```{r set_colours}
## qc_colours need to have `Pass` and `Fail`
missing_qc_cols <- setdiff(c("pass", "fail"), names(colours$qc))
if ("pass" %in% missing_qc_cols) colours$qc$pass <- "#0571B0" # Blue
if ("fail" %in% missing_qc_cols) colours$qc$fail <- "#CA0020" # Red
colours$qc <- colours$qc[c("pass", "fail")]

## The colours specified as treat_colours should contain all treat_levels + Input
## If Input is missing, set to #33333380 ('grey20' + alpha = 50)
## This should be a standard chunk for all workflows
missing_treat_cols <- setdiff(
  c("Input", treat_levels), names(colours$treat)
)
if (length(missing_treat_cols) > 0) {
  if ("Input" %in% missing_treat_cols) 
    colours$treat$Input <- "#33333380"
  ## Automatically sample from the viridis palette if no colour is assigned
  colours$treat[setdiff(missing_treat_cols, "Input")] <- hcl.colors(
    length(setdiff(missing_treat_cols, "Input"))
  )
}

## Direction colours always need up, down, unchanged & undetected
missing_dir_cols <- setdiff(
  c("increased", "decreased", "unchanged", "undetected", "ambiguous"), 
  names(colours$direction)
)
if (length(missing_dir_cols) > 0) {
  def_dir_cols <- c(
    increased = "#CA0020", decreased = "#0571B0", 
    unchanged = "#7F7F7F", undetected = "#E5E5E5",
    ambiguous = "#000000"
  )
  colours$direction[missing_dir_cols] <- def_dir_cols[missing_dir_cols]
}

all_heat_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("profile_heatmaps")
heat_cols <- targets %>% 
  lapply(\(x) all_heat_params$default$gradient) %>% 
  setNames(targets)
for (i in targets) {
  if ("gradient" %in% names(all_heat_params[[i]])) {
    heat_cols[[i]] <- all_heat_params[[i]]$gradient
  }
}

target_cols <- map_chr(heat_cols, \(x) x[length(x)])
if (any(duplicated(target_cols))) {
  target_cols <- target_cols[!duplicated(target_cols)]
  missing_tgt_cols <- setdiff(targets, names(target_cols))
  n <- min(length(missing_tgt_cols), 9)
  pal <- RColorBrewer::brewer.pal(9, "Set1")[seq_len(n)]
  new_cols <- colorRampPalette(pal)(length(missing_tgt_cols))
  names(new_cols) <- missing_tgt_cols
  target_cols <- c(target_cols, new_cols)
}
colours$target <- target_cols

```


Colours were checked where provided and any missing colours were automatically assigned.
These colour schemes are shown below and will be propagated through all steps of the workflow.
To change any colours, simply add them to `config/rmarkdown.yml`.

```{r set-dev-to-png, echo=FALSE}
knitr::opts_chunk$set(dev = "png")
```


## QC

```{r plot-qc, fig.height=3, fig.width=2 + length(colours$qc)}
.plotScheme(colours$qc , xlab = "QC Category") 
```

## Treatment Groups

```{r plot-treat, fig.height=3, fig.width=2 + length(colours$treat)}
.plotScheme(colours$treat, xlab = "Treatment")
```

## Regions

```{r plot-regions, fig.height=3, fig.width=2 + length(colours$regions)}
.plotScheme(colours$regions, xlab = "Regions")
```


`r ifelse(has_features, "## Features", "")`

```{r plot-feat, eval = has_features, echo = has_features, fig.height=3, fig.width=2 + length(colours$features)}
.plotScheme(feat_col, xlab = "Feature")
```

## Direction

```{r plot-dir, fig.height=3, fig.width=2 + length(colours$direction)}
.plotScheme(colours$direction, xlab = "Direction")
```

## Heatmap Gradient

```{r plot-gradient, fig.height=5, fig.width=8}
heat_cols %>% 
  lapply(\(x) colorRampPalette(x)(11)) %>% 
  as_tibble() %>% 
  mutate(
    x = seq(0, 1, by = 0.1) %>% percent() %>% fct_inorder()
  ) %>% 
  pivot_longer(
    cols = all_of(targets), names_to = "target", values_to = "colour"
  ) %>% 
  ggplot(aes(x, target, fill = I(colour))) +
  geom_tile() +
  scale_x_discrete(expand = rep_len(0, 4), name = "% Of Maximal Signal") +
  scale_y_discrete(expand = rep_len(0, 4), name = "Target") +
  theme_minimal() 
```


# Data Export

```{r export}
write_rds(colours, all_out$colours, compress = "gz")
```


During setup of all required annotations, the following files were exported:

`r pander(lapply(all_out, str_extract, paste0(basename(here::here()), ".+")))`


<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
