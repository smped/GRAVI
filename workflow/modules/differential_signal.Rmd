```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```


<!-- This is a rewrite of the previous differential signal module. -->
<!-- Required input should be the sets of counts which can be produced by running -->
<!-- a standalone R script. These counts will be used as input for the DSA section. -->
<!-- Sliding window counts should also be filtered using `dualFilter()` as part of -->
<!-- this script. -->

<!-- Permitted DSA methods are: -->

<!-- 1. Fixed-Width Windows -->
<!-- + All edgeR normalisation & either QL or LT -->
<!-- 2. Sliding Windows -->
<!-- + All edgeR normalisation & either QL or LT -->
<!-- + SQ Normalisation & LT -->

<!-- The basic approach will be: -->

<!-- 1. Load counts -->
<!-- 2. Perform a quantro test -->
<!-- + Failed tests will only permit "none" (QL/LT) or SQ (FW-LT) normalisation -->
<!-- + Passed tests will permit all normalisation methods -->
<!-- 3. Perform DSA -->

```{r set-params, eval = interactive(), echo = FALSE}
# params <- list(
#   target = "AR", 
#   treat_levels = c("E2", "E2DHT")
# )
```

```{r packages}
library(tidyverse)
library(glue)
library(pander)
library(extraChIPs)
library(yaml)
library(GenomicInteractions)
library(quantro)
library(qsmooth)
library(edgeR)
library(patchwork)
library(plyranges)
library(reactable)
library(scales)
library(htmltools)
library(rtracklayer)
library(ggrepel)
library(rlang)
library(parallel)
library(goseq)
library(magrittr)
library(msigdbr)
library(tidygraph)
library(ggraph)
library(doParallel)
library(BiocParallel)
# library(GenomeInfoDb)
# library(Rsamtools)
# library(ngsReports)
# library(statmod)
# library(metap)
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
threads <- parallel::detectCores() - 1
register(MulticoreParam(workers = threads))
source(here::here("workflow", "scripts", "custom_functions.R"))
source(here::here("workflow", "scripts", "table_funs.R"))
config <- read_yaml(here::here("config", "config.yml"))
all_paths <- here::here("config", "json", "all_paths.json") %>% 
    jsonlite::fromJSON() %>% 
    lapply(here::here)
```

```{r set_params, echo = FALSE, eval=TRUE}
target <- params$target
treat_levels <- params$treat_levels
win_type <- match.arg(params$window_type, c("fixed", "sliding"))
method <- match.arg(params$method, c("qlf", "lt"))
norm <- match.arg(
  params$norm, c("none", "TMM", "RLE", "TMMwsp", "upperquartile", "sq")
)
check_norm <- norm != "none"
pair_col <- params$pair_column ## This may need revision of earlier modules
paired_samples <- !is.null(pair_col)
ihw_method <- match.arg(
  params$ihw, c("regions", "features", "targets", "none")
)
if (win_type == "fixed" & norm == "sq") stop(
  "Smooth Quantile normalisation not permitted on fixed-width windows."
)
mapping_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("mapping")
all_heat_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("profile_heatmaps") 
heat_params <- all_heat_params$default
if (target %in% names(all_heat_params)) {
  nm <- names(all_heat_params[[target]])
  heat_params[nm] <- all_heat_params[[target]][nm]
}
```


```{r load-data}
samples <- file.path(all_paths$macs2, target, glue("{target}_qc_samples.tsv")) %>% 
  read_tsv() %>% 
  dplyr::filter(treat %in% treat_levels, qc == "pass") %>% 
  mutate(treat = factor(treat, levels = treat_levels)) %>% 
  droplevels()
stopifnot(length(levels(samples$treat)) == 2)
counts <- here::here(params$counts) %>% 
  read_rds() %>% 
  .[,samples$sample]
assay_name <- c(qlf = "counts", lt = "logCPM")[method]
n_max <- min(5e5, nrow(counts))
```


```{r load-annotations}
sq <- file.path(all_paths$annotation, "seqinfo.rds") %>% read_rds()
blacklist <- here::here(all_paths$annotation, "blacklist.rds") %>% 
  read_rds()
greylist <- GRanges(seqinfo = sq)
if (length(unique(samples$input))) {
  greylist <- file.path(all_paths$greylist, "{samples$input}_greylist.bed.gz") %>% 
    glue() %>% 
    unique() %>% 
    importPeaks(type = "bed", seqinfo = sq) %>% 
    unlist() %>% 
    reduce()
}
exclude_gr <- c(blacklist, greylist)
gtf_gene <- file.path(all_paths$annotation, "gtf_gene.rds") %>% read_rds()
id2gene <- structure(gtf_gene$gene_name, names = gtf_gene$gene_id)

colours <- read_rds(file.path(all_paths$annotation, "colours.rds")) %>% 
  lapply(unlist)

external_features <- here::here(all_paths$annotation, "features.rds") %>% 
  read_rds()
has_features <- length(external_features) > 0
if (has_features)
  feature_colours <- setNames(
    colours$features, str_sep_to_title(names(colours$features))
  )

gene_regions <- file.path(all_paths$annotation, "gene_regions.rds") %>% 
  read_rds()
regions <- map_chr(gene_regions, \(x) unique(x$region))
region_colours <- setNames(colours$regions, regions[names(colours$regions)])

direction_colours <- colours$direction %>% 
  setNames(str_to_title(names(.))) %>% 
  .[names(.) %in% c("Increased", "Decreased", "Unchanged", "Ambiguous")]
treat_colours <- colours$treat[treat_levels]

fig_params <- here::here("config", "rmarkdown.yml") %>% 
  read_yaml() %>% 
  pluck("knitr_opts")
fw <- fig_params$fig.width
fh <- fig_params$fig.height
fig_type <- fig_params$dev[[1]]
if (is.null(fig_type)) stop("Couldn't detect figure type")
fig_fun <- match.fun(fig_type)
if (fig_type %in% c("bmp", "jpeg", "png", "tiff")) {
  ## These figure types require dpi & resetting to be inches
  formals(fig_fun)$units <- "in"
  formals(fig_fun)$res <- 300
}

has_rnaseq <- FALSE ## To be added in again later
```


```{r load-hic}
hic <- GInteractions()
hic_path <- here::here(config$external$hic)
if (length(hic_path) > 0)
  if (file.exists(hic_path)) {
    has_hic <- TRUE
    hic <- makeGenomicInteractionsFromFile(hic_path, type = "bedpe")
    reg_combs <- expand.grid(regions, regions) %>% 
      as.matrix() %>% 
      apply(
        MARGIN = 1, 
        \(x) {
          x <- sort(factor(x, levels = regions))
          paste(as.character(x), collapse = " - ")
        }
      ) %>% 
      unique()
    hic$regions <- anchors(hic) %>% 
      vapply(
        bestOverlap,
        y = GRangesList(lapply(gene_regions, granges)),
        character(length(hic))
      ) %>% 
      apply(MARGIN = 2, \(x) regions[x]) %>% 
      apply(
        MARGIN = 1, 
        \(x) {
          x <- sort(factor(x, levels = regions))
          paste(as.character(x), collapse = " - ")
        }
      ) %>% 
      factor(levels = reg_combs) %>%
      fct_relabel(
        str_replace_all,
        pattern = "Promoter \\([0-9kbp/\\+-]+\\)", replacement = "Promoter"
      )
    if (has_features) {
      feat_combs <- expand.grid(names(feature_colours), names(feature_colours)) %>% 
        as.matrix() %>% 
        apply(
          MARGIN = 1, 
          \(x) {
            x <- sort(factor(x, levels = names(feature_colours)))
            paste(as.character(x), collapse = " - ")
          }
        ) %>% 
        unique()
      hic$features <- vapply(
        anchors(hic),
        \(x) bestOverlap(
          x, external_features, var = "feature", missing = "no_feature"
        ),
        character(length(hic))
      )  %>% 
        apply(
          MARGIN = 1, 
          \(x) {
            x <- sort(factor(x, levels = names(feature_colours)))
            paste(as.character(x), collapse = " - ")
          }
        ) %>% 
        factor(levels = feat_combs) %>%
        fct_relabel(str_sep_to_title, pattern = "_")
    }
  }
stopifnot(is(hic, "GInteractions"))
seqlevels(hic) <- seqlevels(sq)
seqinfo(hic) <- sq
hic <- hic[!overlapsAny(hic, exclude_gr)]
has_hic <- as.logical(length(hic))
```


```{r define-outputs}
out_path <- here::here("output", "differential_signal", target)
comp <- glue("{target}_{treat_levels[[1]]}_{treat_levels[[2]]}")
all_out <- list(
  results = file.path(out_path, glue("{comp}-differential_signal.rds")),
  csv = file.path(out_path, glue("{comp}-differential_signal.csv.gz")),
  up_regions = file.path(out_path, glue("{comp}-up.bed")),
  down_regions = file.path(out_path, glue("{comp}-down.bed")),
  # de_genes = file.path(out_path, glue("{comp}-DE_genes.csv")),
  enrichment = file.path(out_path, glue("{comp}-enrichment.csv")),
  # rna_enrichment = file.path(out_path, glue("{comp}-rnaseq_enrichment.csv")),
  renv = here::here("output/envs", glue("{comp}-differential_signal.RData"))
)
## Initialise outputs from RNA-Seq
# cmn_diff <- cmn_up <- cmn_down <- tibble(leadingEdge = list())
fig_path <- here::here("docs", "assets", comp)
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE)
```

```{r method-descriptions, echo = FALSE}
norm_ref <- case_when(
  norm == "sq" ~ "normalised using Smooth-Quantile normalisation [@HicksSQN2017]",
  norm %in% c("TMM", "TMMwsp") ~ paste("with", norm, "normalisation [@Robinson2010-qp]", collapse = " "),
  norm == "RLE" ~ "with RLE normalisation [@Anders2010-sd].",
  norm == "upperquartile" ~ "with upperquartile normalisation",
  TRUE ~ "with library-size normalisation"
)
desc_windows <- c(
  sliding = glue(
    "During counting, sliding windows of {params$window_size}bp were used with a step-size
    defined to ensure each position is covered by at least 3 windows (e.g. 
    {ceiling(params$window_size/3)}bp). After performing the analysis on the set of 
    sliding windows, final results will be obtained by merging nearby windows 
    using the harmonic-mean p-value [@Wilson2019-ln]. Any windows within 
    {floor(1 + params$window_size * 2 / 3)}bp of each other are considered as 'nearby' 
    windows suitable for merging."
  ),
  fixed = glue(
    "During counting all ranges were set to be {params$window_size}bp and centred based on
    the estimated peaks centres determined by macs2. For downstream reporting of 
    results, the original range called as a 'peak' by macs2 is reported rather 
    than the centred range.
    "
  )
)[[win_type]] %>% 
  str_replace_all("\\n", " ") %>% 
  str_replace_all(" +", " ")
desc_method <- c(
  qlf = glue(
    "Quasi-Likelihood Generalised Linear Models [@LunSmythGLMQL2017] on counts {norm_ref}."
  ),
  lt = glue("Limma-Trend [@LawVoom2014] on logCPM values {norm_ref}.")
)[method]
desc_ihw <- list(
  regions = "the previously annotated genomic regions",
  features = "the provided external features",
  targets = "the presence/absence of any other ChIP targets under consideration in any condition",
  none = c()
)[[ihw_method]]
desc_treat <- ifelse(
  params$fc == 1,
  "The Null Hypothesis (H~0~) is the conventional H~0~ testing for zero against non-zero (i.e. H~A~) change",
  glue(
    "The Null Hypothesis (H~0~) is a range-based hypothesis testing for log fold-change beyond the range &#177;{round(log2(params$fc), 3)}"
  )
)
```


## Outline

This step of the GRAVI workflow uses a `r win_type` window approach to differential signal with windows of `r params$window_size`bp.
Counts for all windows were prepared across all `r target` samples as a stand-alone process, with the only samples retained in this analysis being those with counts from `r collapseGenes(treat_levels, last = " or ", format = "")`.
This process has produced counts for `r comma(nrow(counts))` ranges.

`r desc_windows`

Differential signal analysis will be performed using `r unname(desc_method)`.
`r desc_treat`
Ranges with an FDR < `r params$alpha` will be considered as significant.
`r if (paired_samples) "Samples were denoted as being paired"`

`r glue("Independent Hypothesis Weighting (IHW) [@IgnatiadisIHW2016] is additionally used to improve the power of the results. Under this strategy, p-values are partitioned based on {desc_ihw}, which is considered here to be a statistically independent variable.")`

The workflow depends heavily on the functions implemented in the Bioconductor package [extraChIPs](https://bioconductor.org/packages/release/bioc/html/extraChIPs.html)

<!-- ### Enrichment Analysis -->

<!-- Beyond the simple analysis of differential signal, peaks are mapped to genes and enrichment testing is performed on the following: -->

<!-- 1. Genes mapped to any range with detected `r target` are compared to all genes not mapped to any range -->
<!-- 2. Genes mapped to *all ranges with differential signal* are compared to genes mapped to ranges with no difference in signal -->
<!-- 3. Genes mapped to ranges with *increasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->
<!-- 4. Genes mapped to ranges with *decreasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->

<!-- Enrichment testing is performed using `goseq` [@YoungGoseq2010] with no term accounting for sampling bias (i.e. the Hypergeometric Distribution), *except when comparing genes mapped to any window.* -->
<!-- For this case **only**, gene width is used to capture any sampling bias and Wallenius' Non-Central Hypergeometric Distribution is used. -->
<!-- As RNA-seq data `r ifelse(has_rnaseq, "was", "was not")` provided, the genes considered for enrichment analysis are the `r comma(length(unique(gtf_gene$gene_id)))` `r ifelse(has_rnaseq, "genes considered as detected in the RNA-Seq data", "annotated genes")`. -->

<!-- `r if (has_rnaseq) "### Incorporation with RNA-Seq"` -->

<!-- `r if (has_rnaseq) "Any association between differentially expressed genes and differential signal regions will be assessed using Gene Set Enrichment Analysis [@SubramanianGsea2005], as implemented in the fgsea package [@KorotkevichFgsea2019]. The sets of genes associated with changed signal will be subset by regions and any provided external features, and these novel gene-sets will be used to test for enrichment within the RNA-Seq results. ChIP-seq derived gene-sets will be tested for differential expression using genes ranked directionally and by significance alone. A combined meta-analytic approach using Wilkinson's method will also be used to integration of results from enrichment testing in each standalone dataset."` -->

## Differential Signal Analysis

`r if (check_norm) "### Normalisation Checks"`

```{r qtest, eval = check_norm}
registerDoParallel(threads)
qtest <- quantro(assay(counts, "counts"), counts$treat, B = 1e3)
quantro_p <- c(
  perm = quantroPvalPerm(qtest),
  anova = anova(qtest)[["Pr(>F)"]][[1]]
)
if (any(quantro_p < 0.05) & norm != "sq") norm <- "none" 
```

```{r desc-quantro, echo = FALSE, eval = check_norm}
desc_quantro <- paste(
  "Prior to performing analysis, un-normalised logCPM values were tested for",
  "equality of distribution using the `quantro` test [@HicksQuantro2015].",
  "Results testing for equality of distribution gave a p-value of",
  paste0(round(quantro_p[["perm"]], 3), ","), 
  "and tests for an equality of medians between group returned a p-value of",
  paste0(round(quantro_p[["anova"]], 3), ".")
) %>% 
  c(
    case_when(
      any(quantro_p < 0.05) & norm == "sq" ~ "These results indicate that the data across treatments is drawn from different distributions and SQ-normalisation may improve the results",
      any(quantro_p < 0.05) & norm != "none" ~ paste(
        "These results indicate that the data across treatments is drawn from different distributions and **", norm, "normalisation will be inappropriate**. *The normalisation method has been reset to library-size.*", collapse = ""
      ),
      TRUE ~ paste(
        "All results from the quantro test support the choice of", 
        ifelse(norm == "none", "library-size", norm), 
        "normalisation.", collapse = " "
      )
    )
  )
```


`r desc_quantro`


```{r normalise-logcpm}
if (norm == "sq") {
  assay_name <- "qsmooth"
  qs <- qsmooth(assay(counts, "logCPM"), group_factor = counts$treat)
  assay(counts, assay_name) <- qsmoothData(qs)
} else {
  ## Make sure the normalisation is included for CPM values
  ## as well as the complete library sizes
  dge <- calcNormFactors(counts, method = norm)
  dge$samples$lib.size <- counts$totals
  lcpm <- cpm(dge, log = TRUE) 
  rownames(lcpm) <- NULL
  assay(counts, "logCPM") <- lcpm
}
```

`r if (norm != "sq") "For easier visualisation, the normalised assay *logCPM* was added to the counts object"`
`r if (norm == "sq") glue("The assay {assay_name} was then added to the counts object")`

### Data Inspection {.tabset}

`r if (norm == "sq") "#### QSmooth Weights"` 

```{r plot-sq-weights, eval = norm == "sq", echo = norm == "sq", fig.height = 6, fig.cap = "*Quantile-specific weights used by the Smooth-Quantile normalisation. Low weights indicate signal quantiles which appear to be more specific within a group, whilst higher weights indicate similarity between groups.*"}
qsmoothPlotWeights(
  qs, xLab = "Quantiles", yLab = "Weights", mainLab = "QSmooth Weights"
)
```


#### Densities

```{r plot-densities, fig.height = 6, fig.cap = "*Distributions of counts for each sample within each treatment group shown (A) before normalisation and (B) after normalisation..*"}
assays <- c("counts", "logCPM")
trans <- "log1p"
xlab <- "Normalised logCPM"
if (norm == "sq") {
  assays <- c("logCPM", "qsmooth")
  trans <- NULL
  xlab <- "SQ-Normalised logCPM"
}
a <- counts %>%
  plotAssayDensities(assays[[1]], colour = "treat", n_max = n_max, trans = trans) +
  scale_colour_manual(values = treat_colours) +
  labs(colour = "Treat")
b <- counts %>% 
  plotAssayDensities(assays[[2]], colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_colours) +
  labs(x = xlab, colour = "Treat")
a + b + 
  plot_layout(guides = "collect", axis_titles = "collect") +
  plot_annotation(tag_levels = "A")
```

#### RLE


```{r plot-rle, dev = 'png', fig.height=6, fig.cap = glue("*RLE plot showing two perspectives on the data. (A) shows all samples with median values taken across all samples. If any differences are evident between treatment groups, library-size or smooth-quantile normalisation may be the best approaches for normalisation. (B) shows all samples taking median values within treatment groups and potentially highlights any problematic samples within each groups.*")}
rle_assay <- ifelse(norm == "sq", "qsmooth", "logCPM")
a <- counts %>% 
  plotAssayRle(
    rle_assay, fill = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_colours) +
  ggtitle(glue("RLE: No Grouping")) +
  labs(x = "Sample", fill = "Treat") 
b <- counts %>% 
  plotAssayRle(
    rle_assay, fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  ggtitle(glue("RLE: Grouping by Treat")) +
  scale_fill_manual(values = treat_colours) +
  labs(x = "Sample", fill = "Treat")
a + b + 
  plot_layout(guides = "collect", axis_titles = "collect") + 
  plot_annotation(tag_levels = "A")
```


#### PCA

```{r plot-qsmooth-pca, fig.width = ifelse(norm == "sq", fw, fh), fig.cap = "*PCA showing the amount of variance attributed to each component*"}
a <- plotAssayPCA(
  counts, "logCPM", colour = "treat", label = "label", 
  show_points = FALSE
) +
  scale_colour_manual(values = treat_colours) +
  guides(colour = "none") +
  ggtitle("PCA using logCPM values")
b <- NULL
if (norm == "sq") {
  b <- plotAssayPCA(
    counts, "qsmooth", colour = "treat", label = "label",
    show_points = FALSE
  ) +
    scale_colour_manual(values = treat_colours) +
    guides(colour = "none") +
    ggtitle("PCA after SQ Normalisation")
  a <- a + b + 
    plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
}
a
```



### Model Fitting

```{r fit}
fm <- as.formula(
  ifelse(is.null(pair_col), "~treat", paste("~", pair_col, "+treat"))
)
X <- model.matrix(fm, data = colData(counts)) 
colnames(X) <- str_remove_all(colnames(X), "treat")
colData(counts)$design <- X
paired_cors <- block <- txt <- NULL
if (!is.null(pair_col) & method == "lt") {
  ## These will be passed to fitAssayDiff. This in turn passes these to
  ## lmFit, although when method is qlf they will be passed to glmQLFit.
  ## As they are not parameters for that modelling approach, they will be 
  ## ignored
  block <- colData(counts)[[pair_col]]
  set.seed(1e6)
  ind <- sample.int(nrow(counts), n_max, replace = FALSE)
  paired_cors <- duplicateCorrelation(
    object = assay(counts, assay_name)[ind, ],
    design = X,
    block = block
  )$consensus.correlation # This will be ignored in '...' if block = NULL
  txt <- glue(
    "During model fitting, data were nested within {{pair_col}} as a potential source of correlation. ",
    "The estimated correlation within replicate samples was $\\hat{\\rho} = {{round(paired_cors, 3)}}$",
    .open = "{{", .close = "}}"
  )
}
fit <- fitAssayDiff(
  counts, assay = assay_name, design = X, coef = treat_levels[[2]],
  method = method, norm = ifelse(norm == "sq", "none", norm), 
  fc = params$fc, block = block, correlation = paired_cors
) 
pcols <- c("PValue", "p_mu0")
if (win_type == "sliding") {
  results <- mergeByHMP(
    fit, pval = pcols, merge_within = floor(1 + 2 * params$window_size / 3),
    hm_pre = ""
  ) %>%
    plyranges::select(
      starts_with("n_"), keyval_range, starts_with("log"), any_of(pcols),
      FDR = PValue_fdr
    ) %>% 
    addDiffStatus(alpha = params$alpha)
} else {
  results <- rowRanges(fit) %>% addDiffStatus(alpha = params$alpha)
}
fdr_column <- "FDR"
n_sig <- sum(results$FDR < params$alpha)
```

`r txt`

### Independent Hypothesis Weighting {.tabset}

`r ifelse(ihw_method == "none", "No independent Hypothesis Weighting was specified", "")`

```{r ihw, eval = ihw_method != "none", echo = TRUE, child = here::here(glue("workflow/modules/ihw.Rmd"))}
```


### Mapping Windows To Genes

```{r map-to-regions}
results$region <- bestOverlap(results, unlist(gene_regions), var = "region") %>% 
  factor(levels = regions)
feat_prom <- GRanges()
feat_enh <- GRanges()
if (has_features) {
  results <- results %>% 
    mutate(
      feature = bestOverlap(
        ., external_features, "feature", missing = "no_feature"
      ) %>% 
        factor(levels = names(colours$features)) %>% 
        fct_relabel(str_sep_to_title)
    )
  if ("feature" %in% colnames(mcols(external_features))) {
    feat_prom <- external_features %>%
      subset(str_detect(feature, "[Pp]rom")) %>%
      granges()
    feat_enh <- external_features %>%
      subset(str_detect(feature, "[Ee]nhanc")) %>%
      granges()
  }
}
results <- results %>%
  mapByFeature(
    genes = gtf_gene, 
    prom = reduce(c(feat_prom, granges(gene_regions$promoter))),
    enh = feat_enh,
    gi = hic, 
    gr2gene = mapping_params$gr2gene,
    prom2gene = mapping_params$prom2gene,
    enh2gene = mapping_params$enh2gene,
    gi2gene = mapping_params$gi2gene
  )
```

In addition to statistical analysis, all ranges were first mapped to the gene-centric region with the largest overlap.
`r ifelse(has_features, "Ranges were then mapped to the external features provided in the same manner", "")`, followed by mapping to all annotated genes.

During mapping to genes, promoters were defined as the union of all potential promoter regions defined earlier, and any external features which were detected as promoters using string matching in the `feature` column.
`r ifelse(has_features, glue("Enhancers were any regions defined in {basename(config$external$features)} as enhancers."), glue(""))`
`r ifelse(length(hic) > 0, glue("A set of {comma(length(hic))} HiC-interactions was also included to enable the use of long-range interactions during the mappig process."), "")`

These features were used to map ranges to features using the process defined in the function `extraChIPs::mapByFeature()`:

1. Ranges *overlapping a promoter* are assigned to genes `r ifelse(mapping_params$prom2gene == 0, "directly overlapping", paste("within", mapping_params$prom2gene, "bp of"))` that specific promoter
2. Ranges *overlapping an enhancer* are assigned to all genes `r ifelse(mapping_params$enh2gene == 0, "directly overlapping", paste("within", round(mapping_params$enh2gene/1e3, 1), "kb of"))` the enhancer
3. Ranges *overlapping a long-range interaction* are assigned to all genes `r ifelse(mapping_params$gi2gene == 0, "directly overlapping", paste("within", round(mapping_params$gi2gene/1e3, 1), "kb of"))` either end of the interaction
4. Ranges with *no gene assignment from the previous steps* are assigned to all overlapping genes, or the nearest gene within `r round(mapping_params$gr2gene/1e3, 1)`kb

Notably, genes are only passed to step 4 if no gene assignment has been made in steps 1, 2 or 3.
For visualisation purposes, only genes which were considered as detected in any provided RNA-Seq data will be shown as the mapping targets.

## Results 


### Result Tables {.tabset}

```{r tbl-setup}
n_unch <- sum(results$status == "Unchanged")
n_windows <- length(results)
type <- ifelse(win_type == "fixed", "Peaks", "Windows")
tbl_cols <- list(
  Region = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Feature = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Increased = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- up_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Decreasd = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- down_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Ambiguous = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Unchanged = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / n_windows
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Changed` = colDef(
    format = percent_col,
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    align = "right",
    footer = htmltools::tags$b(
      percent(sum(1 - n_unch / n_windows), 0.1)
    )
  ),
  Total = colDef(
    format = comma_col,
    style = \(value) {
      bar_style(width = value / n_windows, fill = "#B3B3B3", align = "right")
    },
    align = "right",
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Of All Windows` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  ),
  `% Of All Peaks` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  )
)
```


#### Overall Results

```{r tab-overall}
tbl <- results %>% 
  mutate(w = width) %>% 
  as_tibble() %>% 
  summarise(
    n = dplyr::n(), 
    width = median(w),
    logCPM = median(logCPM),
    .by = all_of("status")
  ) %>% 
  mutate(`%` = n / sum(n)) %>% 
  dplyr::select(status, n, `%`, everything()) %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      status = colDef(
        name = "Status", maxWidth = 150,
        footer = htmltools::tags$b("Overall")
      ),
      n = colDef(
        name = glue("Nbr of {type}"), maxWidth = 150, format = colFormat(separators = TRUE),
        footer = htmltools::tags$b(comma(length(results)))
      ),
      width = colDef(
        name = "Median Width (bp)", format = colFormat(digits = 1),
        footer = htmltools::tags$b(round(median(width(results)), 1)),
        maxWidth = 200
      ),
      `%` = colDef(
        name = glue("% Total {type}"), format = colFormat(percent = TRUE, digits = 1),
        style = \(value) bar_style(width = value, align = "right"),
        maxWidth = 150
      ),
      logCPM = colDef(
        name = "Median Signal (logCPM)",
        format = colFormat(digits = 3),
        maxWidth = 200,
        footer = htmltools::tags$b(
          round(median(results$logCPM), 3)
        )
      )
    )
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison."
  )
)
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


#### Summary By Region

```{r tab-res-by-region}
df <- results %>% 
  select(status, !!sym(fdr_column), region) %>% 
  as_tibble() %>% 
  group_by(region, status) %>% 
  summarise(n = dplyr::n(), .groups = "drop") %>% 
  complete(region, status, fill = list(n = 0)) %>% 
  group_by(region) %>% 
  mutate(Total = sum(n)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    "% Of All {type}" := Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(region) %>% 
  dplyr::select(
    Region = region,
    any_of(names(direction_colours)),
    `% Changed`, Total, starts_with("% Of All")
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which genomic region contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = \(values) htmltools::tags$b(comma(sum(values)))
    ),
    fullWidth = TRUE, elementId = 'tbl-results-by-region'
  )
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r ifelse(has_features, "#### Summary By Feature", "")`

```{r tab-res-by-feature, echo = has_features, eval = has_features}
df <- results %>% 
  select(status, !!sym(fdr_column), feature) %>% 
  as_tibble() %>% 
  group_by(feature, status) %>% 
  tally() %>% 
  ungroup() %>% 
  complete(feature, status, fill = list(n = 0)) %>% 
  mutate(Total = sum(n), .by = all_of("feature")) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    "% Of All {type}" := Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(feature) %>% 
  dplyr::select(
    Feature = feature,
    any_of(names(direction_colours)),
    `% Changed`, Total, starts_with("% Of All")
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which external feature contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = \(values) htmltools::tags$b(comma(sum(values)))
    ),
    elementId = 'tbl-results-by-feature'
  )
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


#### Most Highly Ranked

```{r tab-highly-ranked}
show_n <- min(200, length(results))
scaling_vals <- list(
  logFC = c(-1, 1)*max(abs(results$logFC)),
  logCPM = range(results$logCPM),
  Width = max(width(results))
)
cp <- htmltools::em(
  glue(
    "The {show_n} most highly-ranked ranges by FDR, with {comma(n_sig)} ", 
    "in total showing evidence of changed {target} signal. ",
    "Regions were assigned based on which genomic region showed the largest ",
    "overlap with the range being analysed. ",
    ifelse(
      has_features, 
      glue("Features are as provided in the file {basename(config$external$features)}. "),
      glue("")
    ),
    "For ranges mapped to large numbers of genes, hovering a mouse over the ", 
    "cell will reveal the full set of genes. "
  )
)
fs <- 12
tbl <- results %>%
  mutate(w = width) %>% 
  arrange(!!sym(fdr_column)) %>% 
  plyranges::slice(seq_len(show_n)) %>% 
  plyranges::select(
    w, starts_with("log"), !!sym(fdr_column), status,
    Region = region, any_of("feature"), Genes = gene_name
  ) %>% 
  as_tibble() %>% 
  dplyr::rename(Range = range, `Width (bp)` = w) %>% 
  rename_with(\(x) str_replace_all(x, "feature", "Feature")) %>% 
  mutate(Genes = map_chr(Genes, paste, collapse = "; ")) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 20, 50, show_n), defaultPageSize = 10,
    borderless  = TRUE,
    columns = list2(
      Range = colDef(
        minWidth = 10 * fs,
        cell = \(value) str_replace_all(value, ":", ": ")
      ),
      `Width (bp)` = colDef(
        style = \(value) {
          x <- value / scaling_vals$Width
          colour <- expr_col(x)
          list(
            background = colour, 
            borderRight = "1px solid rgba(0, 0, 0, 0.1)"
          )
        },
        maxWidth = 5 * fs
      ),
      logCPM = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logCPM)) / diff(scaling_vals$logCPM)
          colour = expr_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      logFC = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logFC)) / diff(scaling_vals$logFC)
          colour <- lfc_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      "{fdr_column}" := colDef(
        name = "FDR",
        cell = \(value) {
          fmt <- ifelse(value < 0.01, "%.2e", "%.3f")
          sprintf(fmt, value)
        },
        style = \(value) {
          text_colour <- ifelse(value < params$alpha, "black", direction_colours[["Unchanged"]])
          list(color = text_colour, borderRight = "1px solid rgba(0, 0, 0, 0.1)")
        },
        maxWidth = 5.5 * fs
      ),
      status = colDef(
        "Status", maxWidth = 80,
        style = \(value) {
          i <- which(names(direction_colours) == value)
          list(color = direction_colours[[i]])
        } 
      ),
      Region = colDef(maxWidth = 150),
      Genes = colDef(
        cell = \(value) with_tooltip(value, width = ifelse(has_features, 30, 60)),
        minWidth = 11 * fs
      )
    ),
    theme = reactableTheme(style = list(fontSize = fs)),
    elementId = 'tbl-top-ranked'
  )
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('tbl-top-ranked', '{comp}_top_ranked.csv')"
    )
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('tbl-top-ranked', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```



### Summary Plots {.tabset}

```{r make-heatmaps}
type <- str_to_lower(type)
bw_type <- match.arg(heat_params$bw_type, c("FE", "coverage"))
fill_type <- c(coverage = "logCPM", FE = "Fold-Enrichment")[bw_type]
bwfl <- file.path(
  all_paths$macs2, target, ifelse(
    bw_type == "coverage",
    "{target}_{treat_levels}_merged_treat_pileup.bw",
    "{target}_{treat_levels}_merged_FE.bw"
  )
) %>% 
  glue() %>% 
  BigWigFileList() %>% 
  setNames(treat_levels) 
sig_ranges <- results %>% 
  filter(!!sym(fdr_column) < params$alpha) %>%
  splitAsList(f = .$status) %>% 
  .[map_int(., length) > heat_params$min_ranges] 
if (win_type == "sliding") {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "keyval_range")
} else {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "centred_peak")
}
sig_profiles <- lapply(sig_ranges, as.null)
for (i in names(sig_profiles)) {
  set.seed(threads)
  temp_gr <- granges(sig_ranges[[i]])
  n <- length(temp_gr)
  if (n > heat_params$max_ranges) 
    temp_gr <- temp_gr[sort(sample.int(n, heat_params$max_ranges))]
  sig_profiles[[i]] <- getProfileData(
    bwfl, temp_gr, upstream = heat_params$width / 2, 
    log = bw_type == "coverage", bins = heat_params$n_bins, 
    BPPARAM = bpparam()
  )
  rm(temp_gr)
}
profile_heatmaps <- list()

if (length(sig_profiles) > 0) {
  profile_heatmaps <- sig_profiles %>% 
    parallel::mclapply(
      plotProfileHeatmap,
      profileCol = "profile_data", colour = "name",
      xLab = "Distance from Centre (kb)", fillLab = fill_type,
      labelFunX = comma_format(accuracy = 0.1, scale = 1e-3),
      mc.cores = max(1, length(sig_profiles))
    ) 
  fill_range <- profile_heatmaps %>% 
    lapply(\(x) x$data[,"score"]) %>% 
    unlist() %>%
    range()
  sidey_range <- profile_heatmaps %>% 
    lapply(\(x) x$layers[[3]]$data$y) %>% 
    unlist() %>% 
    range()
  profile_heatmaps <- profile_heatmaps %>% 
    lapply(
      \(x) {
        suppressWarnings(
          x + 
            scale_fill_gradientn(
                colours = heat_params$gradient, limits = fill_range
            ) +
            scale_xsidey_continuous(limits = sidey_range) +
            scale_colour_manual(values = treat_colours) +
            labs(
              x = "Distance from Centre (kb)",
              fill = fill_type, colour = "Treat"
            ) +
            theme(strip.text.y = element_text(angle = 0))
        )
      }
    )
}
```


#### MA Plot

```{r plot-ma, fig.cap = glue("*MA plot showing the status of all {type} under consideration. The two most extreme {type} are labelled by region and any associated genes, whilst the overall pattern of association between signal level (logCPM) and changed signal (logFC) is shown as the blue curve.*")}
if (!"Ambiguous" %in% levels(results$status)) 
  direction_colours <- direction_colours[names(direction_colours) != "Ambiguous"]
results %>% 
  as_tibble() %>%
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, bs = "cs")) +
  geom_hline(yintercept = 0) +
  geom_label_repel(
    aes(y = logFC, label = annot, colour = status),
    data = . %>%
      dplyr::filter(!!sym(fdr_column) < params$alpha) %>% 
      arrange(desc(abs(logFC))) %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(x = "Ave Signal (logCPM)", colour = "Status") 
```


#### Volcano Plot

```{r plot-volcano, fig.cap = glue("*Volcano plot showing {type} with evidence of differential {target} signal. The most significant {type} are labelled along with any genes these regions are mapped to.*")}
results %>% 
  as_tibble() %>% 
  ggplot(aes(logFC, -log10(PValue))) +
  geom_point(aes(colour = status), alpha = 0.6) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data = . %>%
      arrange(PValue) %>%
      dplyr::filter(!!sym(fdr_column) < params$alpha) %>% 
      droplevels() %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(
    x = "logFC",
    y = expression(paste(-log[10], "p")),
    colour = "Status"
  )
```



```{r plot-all-profile-heatmaps, echo = FALSE}
htmltools::tagList(
  mclapply(
    seq_along(profile_heatmaps),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(profile_heatmaps)[[i]])
      img_out <- file.path(
        fig_path,
        glue("{nm}_profile_heatmap.{fig_type}")
      )
      n_ranges <- length(sig_profiles[[i]][[1]])
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = min(
          3.5 + knitr::opts_current$get("fig.height") * n_ranges / 1.5e3, 
          10
        )
      )
      print(profile_heatmaps[[i]])
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(
        glue(
          "
        {n_ranges} {type} selected as showing {nm} signal. Heatmaps were 
        restricted to a maximum of {comma(heat_params$max_ranges)} {type}. Values 
        shown are use the {bw_type}-based bigwig files produced by macs2 callpeak.
        "
        )
      )
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(
            glue("Profile Heatmaps: {str_to_title(nm)} Signal")
          ),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


#### Signal By Region

```{r boxplot-regions, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each genomic region.*"}
results %>% 
  select(logCPM, logFC, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    ),
  ) %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(x, value, fill = region)) +
  geom_boxplot() +
  facet_grid(rows = vars(name), scales = "free", switch = "y") +
  scale_fill_manual(values = region_colours) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r if (n_sig > 0) "#### Differential Signal By Region"`

```{r plot-db-regions, eval = n_sig > 0, echo = n_sig > 0, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all genomic regions.*")}
results %>% 
  dplyr::filter(!!sym(fdr_column) < params$alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Region = region) %>% 
  droplevels() %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Region", min_p = 0.02,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = region_colours
  )
```

`r ifelse(has_features, "#### Signal By Feature", "")`

```{r boxplot-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each external features.*"}
results %>% 
  select(logCPM, logFC, feature) %>% 
  as_tibble() %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(feature, value, fill = feature)) +
  geom_boxplot() +
  facet_grid(
    name~., scales = "free", labeller = facet_labeller, switch = "y"
  ) +
  scale_fill_manual(values = feature_colours) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r ifelse(has_features, "#### Differential Signal By Feature", "")`

```{r plot-db-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all external features.*")}
results %>% 
  dplyr::filter(!!sym(fdr_column) < params$alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Feature = feature) %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Feature", min_p = 0.01,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = feature_colours
  )
```


### Inspection of Top-Ranked Regions {.tabset}

```{r get-cmn-plot-objects}
cb <- config$genome$build %>% 
  str_to_lower() %>% 
  paste0(".cytobands") 
data(list = cb)
bands_df <- get(cb)
stopifnot(
  colnames(bands_df) == c("chrom", "chromStart", "chromEnd", "name", "gieStain")
)
trans_models <- file.path(all_paths$annotation, "trans_models.rds") %>% 
  read_rds() 
```


```{r grl-to-plot}
## Define a GRL with the key ranges.
## Then we can step through it & make all of the requisite plots
grl_to_plot <- GRangesList(
  
  top_inc_by_fdr = results %>% 
    filter(logFC > 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_inc_by_lfc = filter(results, logFC == max(logFC)),
  
  top_dec_by_fdr = results %>% 
    filter(logFC < 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_dec_by_lfc = filter(results, logFC == min(logFC))
  
) %>% 
  unlist() %>% 
  .[!duplicated(.)] %>%
  splitAsList(names(.)) %>% 
  lapply(setNames, c()) %>% 
  lapply(\(x) x[1]) %>%
  GRangesList()
```


```{r prepare-plot-objects}
## The coverage
bwfl <- list2(
  "{target}" := file.path(
    all_paths$macs2, target, "{target}_{treat_levels}_merged_treat_pileup.bw"
  ) %>% 
    glue() %>% 
    BigWigFileList() %>% 
    setNames(treat_levels)
)
line_col <- list2("{target}" := treat_colours)
## Coverage annotations
annot <- results %>% 
  splitAsList(.$status) %>% 
  .[map_int(., length) > 0] %>% 
  endoapply(granges) %>% 
  list() %>% 
  setNames(target)
## Coverage y-limits
ind <- counts %>% 
  assay("counts") %>% 
  apply(MARGIN = 2, which.max) %>%
  unique()
max_ranges <- rowRanges(counts[ind])
y_lim <- bwfl[[target]] %>%
  lapply(import.bw, which = max_ranges) %>%
  lapply(\(x) c(0, max(x$score))) %>% 
  unlist() %>% 
  range() %>% 
  list() %>% 
  setNames(target)

## The features track
feat_gr <- gene_regions %>% 
  lapply(granges) %>% 
  GRangesList()
feat_col_hfgc <- colours$regions
if (has_features) {
  feat_gr <- list(Regions = feat_gr)
  feat_gr$Features <- splitAsList(external_features, external_features$feature)
  feat_col_hfgc <- list(
    Regions = unlist(colours$regions),
    Features = unlist(colours$features)
  )
}

## The genes track
hfgc_genes <- trans_models
gene_col <- "grey"
if (has_rnaseq) {
  if (!is.na(rna_lfc_col) & !is.na(rna_fdr_col)) {
    hfgc_genes <- trans_models %>% 
      mutate(
        status = case_when(
          !gene %in% rnaseq$gene_id ~ "Undetected",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) > 0, !!sym(rna_fdr_col) < params$alpha
          )$gene_id ~ "Up",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) < 0, !!sym(rna_fdr_col) < params$alpha
          )$gene_id ~ "Down",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_fdr_col) >= params$alpha
          )$gene_id ~ "Unchanged",
        )
      ) %>% 
      splitAsList(.$status) %>% 
      lapply(select, -status) %>% 
      GRangesList()
    gene_col <- colours$direction %>% 
      setNames(str_to_title(names(.)))
  }
}

## External Coverage (Optional)
if (!is.null(config$external$coverage)) {
  ext_cov_path <- config$external$coverage %>% 
    lapply(unlist) %>% 
    lapply(\(x) setNames(here::here(x), names(x)))
  bwfl <- c(
    bwfl[target],
    lapply(ext_cov_path, \(x) setNames(BigWigFileList(x), names(x)))
  )
  line_col <- c(
    line_col[target],
    ext_cov_path %>% 
      lapply(
        \(x) {
          missing <- setdiff(names(x), names(colours$treat))
          cmn <- intersect(names(x), names(colours$treat))
          col <- setNames(character(length(names(x))), names(x))
          if (length(cmn) > 0) col[cmn] <- colours$treat[cmn]
          if (length(missing) > 0) 
            col[missing] <- hcl.colors(
              max(5, length(missing)), "Zissou 1")[seq_along(missing)]
          col
        }
      )
  )
  
  y_ranges <- grl_to_plot %>% 
    unlist() %>% 
    granges() %>% 
    resize(w = 10 * width(.), fix = 'center')
  
  y_lim <- c(
    y_lim[target],
    bwfl[names(bwfl) != target] %>% 
      lapply(
        \(x) {
          GRangesList(lapply(x, import.bw, which = y_ranges)) %>% 
            unlist() %>% 
            filter(score == max(score)) %>% 
            mcols() %>% 
            .[["score"]] %>% 
            c(0) %>% 
            range()
        }
      )
  )
  
}
```



```{r plot-all-top-ranges}
.makeCaption <- function(.gr) {
  if (is.null(.gr)) return(NULL)
  dir <- str_to_lower(.gr$status)
  reg <- case_when(
    str_detect(.gr$region, "Inter") ~ paste("an", .gr$region, "region"),
    str_detect(.gr$region, "Upstream") ~ paste("an", .gr$region),
    str_detect(.gr$region, "(Ex|Intr)on") ~ paste("an", .gr$region),
    str_detect(.gr$region, "^Prom") ~ paste("a", .gr$region)
  )
  feat <- c()
  if (has_features) feat <- case_when(
    str_detect(.gr$feature, "^[AEIOU]") ~ paste("an", .gr$feature),
    !str_detect(.gr$feature, "^[AEIOU]") ~ paste("a", .gr$feature)
  )
  gn <- unlist(.gr$gene_name)
  fdr <- mcols(.gr)[[fdr_column]]
  fdr <- ifelse(
    fdr < 0.001, sprintf('%.2e', fdr), sprintf('%.3f', fdr)
  )
  cp <- c(
    glue(
      "*The {width(.gr)}bp region showing {dir} {target} signal in response to ", 
      "{treat_levels[[2]]} treatment (FDR = {fdr}). ",
      "The range mostly overlapped with {reg}, with all ",
      "defined regions shown as a contiguous bar in the upper panel. ",
      ifelse(
        has_features,
        glue(
          "Using the features supplied in {basename(config$external$features)}, ",
          "this mostly overlapped {feat}, shown as a separate block ",
          "with the gene-centric regions. "
        ),
        glue("")
      )
    ),
    ifelse(
      .gr$overlaps_ref,
      paste(
        "A union peak overlapping this region was identified by",
        "`macs2 callpeak` when using merged samples."
      ),
      "No union peak was identified using `macs2 callpeak`."
    ),
    ifelse(
      length(gn) > 0,
      paste0(
        "Using the above mapping strategy, this range is likely to regulate ",
        collapseGenes(gn, format = ""), "."
      ),
      "No genes were able to be assigned to this region."
    ),
    paste(
      "For each sample, the y-axis limits represent the values from the window", 
      "with the highest signal.*"
    )
  )
  paste(cp, collapse = " ")
}
htmltools::tagList(
  mclapply(
    seq_along(grl_to_plot),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(grl_to_plot)[[i]])
      tag <- nm %>% 
        str_replace_all("_", " ") %>%
        str_to_title() %>% 
        str_replace_all("(Dec|Inc)", "\\1reased Range (") %>% 
        str_replace_all("Fdr", "FDR") %>% 
        str_replace_all("Lfc", "logFC") %>% 
        str_replace_all("\\( (.+)$", "(\\1)")
      img_out <- file.path(fig_path, glue("{nm}.{fig_type}"))
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = knitr::opts_current$get("fig.height")
      )
      plotHFGC(
        grl_to_plot[[i]],
        hic = hic,
        features = feat_gr,featcol = feat_col_hfgc, featsize = 1 + has_features,
        genes = hfgc_genes, genecol = gene_col,
        coverage = bwfl, linecol = line_col,
        annotation = annot, 
        annotcol = direction_colours,
        cytobands = bands_df,
        zoom = 10,
        max = 8e3,
        ylim = y_lim,
        col.title = "black", background.title = "white", showAxis = FALSE,
        rotation.title = 90
      )
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(.makeCaption(grl_to_plot[[i]]))
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(tag),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


## Enrichment Testing 

```{r msigdb}
enrich_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("enrichment")
msigdb_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("msigdb")
network_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("networks")
region_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("gene_regions")

## Ensure we don't have nulls/NAs
min_gs_size <- enrich_params$min_size
if (is.null(min_gs_size) | is.na(min_gs_size)) min_gs_size <- 0
max_gs_size <- enrich_params$max_size
if (is.null(max_gs_size) | is.na(max_gs_size)) max_gs_size <- Inf
min_sig <- enrich_params$min_sig
if (is.null(min_sig) | is.na(min_sig)) min_sig <- 1
sp <- match.arg(msigdb_params$species, msigdbr_species()$species_name)

## Set parameters for enabling networks
min_network_size <- network_params$min_size
if (is.null(min_network_size) | is.na(min_network_size))
  min_network_size <- 2
max_network_size <- network_params$max_size
if (is.null(max_network_size) | is.na(max_network_size))
  max_network_size <- Inf
max_network_dist <- network_params$max_distance
if (is.null(max_network_dist) | is.na(max_network_dist))
  max_network_dist <- 1
net_layout <- network_params$layout
enrich_alpha <- enrich_params$alpha
adj_method <- match.arg(enrich_params$adj, p.adjust.methods)
```



```{r try-great}
library(rGREAT)
## The parameters for enrichment
adj_method <- match.arg(enrich_params$adj, p.adjust.methods)
ucsc <- get_ucsc(config$genome$build)
ext_tss <- gtf_gene %>% 
  select(gene_id) %>% 
  extendTSS(
    genome = ucsc$build, gene_id_type = 'ENSEMBL', 
    basal_upstream = region_params$promoters$upstream,
    basal_downstream = region_params$promoters$downstream
  )
ext_tss_ol <- subsetByOverlaps(ext_tss, results)
msigdb <- msigdbr(sp) %>% 
  dplyr::filter(
    gs_cat %in% msigdb_params$gs_cat |
      gs_subcat %in% msigdb_params$gs_subcat,
    ensembl_gene %in% ext_tss$gene_id
  )
gs_list <- msigdb %>% 
  split(.$gs_name) %>% 
  lapply(pull, ensembl_gene) %>% 
  .[map_int(., length) <= enrich_params$max_size] %>% 
  .[map_int(., length) >= enrich_params$min_size] 
gs_url <- msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name, gs_url, gs_exact_source) %>%
  mutate(
    gs_url = case_when(
      gs_subcat == "CP:REACTOME" ~ str_remove_all(gs_url, "\\|.+"),
      gs_subcat == "CP:KEGG" ~ paste0("https://www.genome.jp/pathway/", gs_exact_source),
      gs_subcat == "CP:WIKIPATHWAYS" ~ paste0(
        "https://www.wikipathways.org/pathways/", gs_exact_source, ".html"
      ),
      gs_url == "" ~ "http://www.gsea-msigdb.org/gsea/msigdb/collections.jsp",
      TRUE ~ gs_url
    ) %>% 
      setNames(gs_name)
  ) %>% 
  pull(gs_url)
great_changed <- results %>% 
  filter(!!sym(fdr_column) < params$alpha) %>% 
  set_genome_info(ucsc$build) %>% 
  great(
    gene_sets = gs_list, extended_tss = ext_tss, 
    min_gene_set_size = enrich_params$min_size, 
    background = set_genome_info(results, ucsc$build), cores = threads
  )
great_changed_df <- great_changed %>% 
  getEnrichmentTable() %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  arrange(p_value_hyper, desc(fold_enrichment_hyper)) %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, adj_method),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great_changed <- sum(great_changed_df$p_adjust_hyper < enrich_params$alpha)

great_increased <- results %>% 
  filter(status == "Increased") %>% 
  set_genome_info(ucsc$build) %>% 
  great(
    gene_sets = gs_list, extended_tss = ext_tss, 
    min_gene_set_size = enrich_params$min_size, 
    background = set_genome_info(results, ucsc$build), cores = threads
  )
great_increased_df <- great_increased %>% 
  getEnrichmentTable() %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  arrange(p_value_hyper, desc(fold_enrichment_hyper)) %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, adj_method),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great_increased <- sum(great_increased_df$p_adjust_hyper < enrich_params$alpha)

great_decreased <- results %>% 
  filter(status == "Decreased") %>% 
  set_genome_info(ucsc$build) %>% 
  great(
    gene_sets = gs_list, extended_tss = ext_tss, 
    min_gene_set_size = enrich_params$min_size, 
    background = set_genome_info(results, ucsc$build), cores = threads
  )
great_decreased_df <- great_decreased %>% 
  getEnrichmentTable() %>% 
  dplyr::select(-all_of(c("fold_enrichment", "p_adjust", "p_value"))) %>% 
  as_tibble() %>% 
  arrange(p_value_hyper, desc(fold_enrichment_hyper)) %>% 
  dplyr::filter(observed_gene_hits >= enrich_params$min_sig) %>% 
  mutate(
    p_adjust_hyper = p.adjust(p_value_hyper, adj_method),
    gene_id  = gs_list[id],
    genes_with_hits = map_chr(
      gene_id, 
      \(x) {
        ids <- subset(ext_tss_ol, gene_id %in% x)$gene_id
        paste(unname(id2gene[unique(ids)]), collapse = "; ")
      }
    )
  )
n_great_decreased <- sum(great_decreased_df$p_adjust_hyper < enrich_params$alpha)
```



```{r}
## The original methods for goseq
msigdb <- msigdbr(species = sp) %>% 
  dplyr::filter(
    gs_cat %in% unlist(msigdb_params$gs_cat) |
      gs_subcat %in% unlist(msigdb_params$gs_subcat),
    str_detect(ensembl_gene, "^E")
  ) %>% 
  # For easier integration 
  dplyr::rename(gene_id = ensembl_gene, gene_name = gene_symbol) %>% 
  dplyr::select(-starts_with("human"), -contains("entrez")) %>% 
  dplyr::filter(gene_id %in% gtf_gene$gene_id) %>% 
  mutate(gs_url = str_extract(gs_url, "^[^|]+")) %>% 
  dplyr::filter(
    dplyr::n() >= min_gs_size, dplyr::n() < max_gs_size, .by = gs_name
  )
gs_by_gsid <- msigdb %>% 
  split(.$gs_name) %>% 
  lapply(pull, "gene_id") %>% 
  lapply(unique)
gs_by_geneid <- msigdb %>% 
  split(.$gene_id) %>% 
  lapply(pull, "gs_name") %>% 
  lapply(unique)
## There are some current errors in the msigdb urls
gs_url <- msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name, gs_url, gs_exact_source) %>%
  mutate(
    gs_url = case_when(
      gs_subcat == "CP:REACTOME" ~ str_remove_all(gs_url, "\\|.+"),
      gs_subcat == "CP:KEGG" ~ paste0("https://www.genome.jp/pathway/", gs_exact_source),
      gs_subcat == "CP:WIKIPATHWAYS" ~ paste0(
        "https://www.wikipathways.org/pathways/", gs_exact_source, ".html"
      ),
      gs_url == "" ~ "http://www.gsea-msigdb.org/gsea/msigdb/collections.jsp",
      TRUE ~ gs_url
    ) %>% 
      setNames(gs_name)
  ) %>% 
  pull(gs_url)


adj_desc <- case_when(
  p.adjust.methods %in% c("fdr", "BH") ~ "the Benjamini-Hochberg FDR",
  p.adjust.methods %in% c("BY") ~ "the Benjamini-Yekutieli FDR",
  p.adjust.methods %in% c("bonferroni") ~ "the Bonferroni",
  p.adjust.methods %in% c("holm") ~ "Holm's",
  p.adjust.methods %in% c("hommel") ~ "Hommel's",
  p.adjust.methods %in% c("hochberg") ~ "Hochberg's",
  p.adjust.methods %in% c("none") ~ "no"
) %>% 
  setNames(p.adjust.methods)
mapped_ids <- results %>%
  as_tibble() %>% 
  dplyr::select(status, starts_with("gene")) %>%
  unnest(starts_with("gene")) %>%
  summarise(
    increased = any(status == "Increased"), 
    decreased = any(status == "Decreased"), 
    n_peaks = dplyr::n(),
    .by = starts_with("gene")
  )
```









Enrichment testing in this section takes a different approach to the analysis of [macs2 peaks](`r glue("{target}_macs2_summary.html#Enrichment_Analysis")`).
Mappings to genes as described above are instead used to perform a conventional enrichment testing using genes assigned to `r type`, using hypergeometric tests [@YoungGoseq2010].
This allows a tailored approach when assigning genes to `r type` and fine control of distances between `r type` and any associated genes.

This strategy also

Hypergeometric testing also tends to be more conservative


As an initial exploration, the ranges containing `r target` signal were compared to pre-defined gene-sets.
These were taken from the `MSigDB` database for `r sp` and the gene-sets used for enrichment testing were restricted to only include those with between `r min_gs_size` and `r max_gs_size` genes.

```{r tbl-msigdb}
msigdb %>% 
  distinct(gs_cat, gs_subcat, gs_name) %>%
  summarise(`Gene Sets` = dplyr::n(), .by = ends_with("cat")) %>% 
  dplyr::rename(Category = gs_cat, `Sub-Category` = gs_subcat) %>% 
  mutate(
    Description = case_when(
      Category == "H" ~ "Hallmark Gene-Sets",
      Category == "C1" ~ "Positional Gene Sets",
      Category == "C2" ~ str_replace_all(`Sub-Category`, "CP:(.+)", "Curated Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "TFT") ~ str_replace_all(`Sub-Category`, "TFT:(.+)", "Transcription Factor Target Prediction Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "MIR") ~ str_replace_all(`Sub-Category`, "MIR:(.+)", "microRNA Target Gene-Sets: \\1"),
      str_detect(`Sub-Category`, "CGN") ~ "Cancer Gene Neighbourhoods",
      str_detect(`Sub-Category`, "CM") ~ "Cancer Modules",
      str_detect(`Sub-Category`, "GO:BP") ~ "Gene Ontology: Bological Process",
      str_detect(`Sub-Category`, "GO:MF") ~ "Gene Ontology: Molecular Function",
      str_detect(`Sub-Category`, "GO:CC") ~ "Gene Ontology: Cellular Component",
      str_detect(`Sub-Category`, "HPO") ~ "Human Phenotype Ontology",
      Category == "C6" ~ "Oncogenic Signature Gene Sets",
      `Sub-Category` == "IMMUNESIGDB" ~ "ImmuneSigDB Gene Sets",
      `Sub-Category` == "VAX" ~ "Vaccine Response Gene Sets",
      Category == "C8" ~ "Cell Type Signature Gene Sets"
    ),
    Category = factor(Category, levels = c("H", paste0("C", 1:8)))
  ) %>% 
  droplevels() %>% 
  arrange(Category) %>% 
  pander(
    justify = "llrl", 
    caption = "*Summary of Gene-Sets used for Enrichment Testing*"
  )
```

Ranges were tested for enrichment of these gene-sets using:

1. Any range mapped to a gene from these gene-sets
2. Any range with evidence of differential signal mapped to a gene from these gene-sets

In the first case, mapped genes were tested for enrichment against *all annotated genes*, or all detected genes if RNA-Seq data was provided.
In the second case, i.e. Differential Signal Windows, the control set of genes were those mapped to any range (i.e. those test set from step 1).
All adjusted p-values below are calculated using `r adj_desc[[adj_method]]` adjustment.
After p-value adjustment, any enriched gene-sets with fewer than `r min_sig` mapped genes were excluded as being uninformative.

If `r min_network_size` or more gene-sets were considered to be enriched, a network plot will be produced for that specific analysis, with network sizes capped at `r max_network_size` for easier interpretability.
The distances between gene-sets were calculated using the overlap coefficient (OC).
Gene-sets with a large overlap will thus be given small distances and in the case of a complete overlap ($OC = 1$) the only most highly ranked gene-set was retained.
Gene-set (i.e. node) pairs with a distance > `r max_network_dist` will not have edges drawn between them and edge width also corresponds to the distance between nodes with closely related nodes having thicker edges.
All network plots were generated using the `r net_layout` layout algorithm.

### Windows With Detected `r target` {.tabset}


```{r goseq-mapped, fig.show='hide'}
pwf_mapped <- gtf_gene %>% 
  mutate(w = width(.)) %>% 
  as_tibble() %>% 
  dplyr::select(gene_id, w) %>% 
  arrange(desc(w)) %>% 
  distinct(gene_id, .keep_all = TRUE) %>% 
  mutate(mapped = gene_id %in% mapped_ids$gene_id) %>% 
  with(
    nullp(
      structure(mapped, names = gene_id),
      genome = config$genome$build,
      bias.data = log10(w),
      plot.fit = TRUE
    )
  )
goseq_mapped <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(pwf_mapped$DEgenes) > 0) {
  goseq_mapped <- goseq(
    pwf_mapped, config$genome$build, gene2cat = gs_by_geneid,
    method = "Wallenius"
  ) %>% 
    dplyr::rename(gs_name = category, pval = over_represented_pvalue) %>% 
    dplyr::select(-starts_with("under")) %>% 
    as_tibble() %>% 
    arrange(pval) %>% 
    dplyr::filter(numDEInCat > 0) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_mapped <- sum(goseq_mapped$adj_p < enrich_alpha) > 0
tg_mapped <- make_tbl_graph(
  goseq_mapped, 
  gs = gs_by_gsid %>% 
    lapply(intersect, rownames(subset(pwf_mapped, DEgenes))) %>% 
    .[map_int(., length) > 0]
)
plot_network_mapped <- length(tg_mapped) >= min_network_size
```

`r ifelse(!any_goseq_mapped, "No enrichment was found amongst genes mapped to any range with detected signal", "#### Results Table")`


```{r tbl-goseq-mapped, eval = any_goseq_mapped, echo = any_goseq_mapped}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_mapped$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
        < {enrich_alpha}) amongst the ranges with detectable {target} signal.
        Genes mapped to a range with detected signal were compared to those not 
        mapped to any merged windows. The length of each gene locus was used to 
        capture any gene-level sampling bias.
        "
      )
    )
  )
)
tbl <- goseq_mapped %>%
  dplyr::filter(adj_p < enrich_alpha) %>% 
  left_join(
    dplyr::select(msigdb, gs_name, gene_name, gene_id, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  dplyr::filter(gene_id %in% unlist(results$gene_id)) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  mutate(
    gene_name = map_chr(gene_name, paste, collapse = "; "),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, 
    p = pval, adj_p, 
    `Mapped Genes` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = \(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          value %>% 
            str_replace_all("_", " ") %>% 
            str_replace_all("^(GO|HALLMARK|KEGG|REACTOME|WP)", "\\1:")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = \(value) with_tooltip(value, width = 100)
      ),
      numDEInCat = colDef(name = "Total Mapped", maxWidth = 80),
      numInCat = colDef(
        name = "Gene Set Size",
        maxWidth = 80,
        cell = \(value) comma(value, 1)
      ),
      "%" = colDef(
        name = "% Mapped",
        cell = \(value) percent(value, 0.1),
        maxWidth = 80
      ),
      p = colDef(
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 80, show = FALSE
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 80
      ),
      "Mapped Genes" = colDef(
        cell = \(value) with_tooltip(value, width = 100),
        minWidth = 150
      )
    )
  )
div(class = "table",
    div(class = "table-header",
        div(class = "caption", cp),
        tbl
    )
)
```

`r ifelse(plot_network_mapped, "#### Network Plot", "")`

```{r plot-network-mapped, eval = plot_network_mapped, echo = plot_network_mapped, fig.cap=glue("*Network plot showing gene-sets enriched amongst the overall set of sites with detectable signal for {target}.*")}
tg_mapped %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_mapped) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```


### Ranges With Differential `r target` Signal {.tabset}

```{r goseq-diff, fig.show='hide'}
pwf_diff <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = increased | decreased) 
goseq_diff <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(pwf_diff$diff) > 0) {
  goseq_diff <- dplyr::select(pwf_diff, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_diff <- sum(goseq_diff$adj_p < enrich_alpha) > 0
tg_diff <- make_tbl_graph(
  goseq_diff, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(pwf_diff, diff)$gene_id) %>%
    .[map_int(., length) > 0]
)
plot_network_diff <- length(tg_diff) >= min_network_size
```


`r ifelse(!any_goseq_diff, "No enrichment was found amongst genes mapped to sites showing any differential signal", "#### Results Table")`


```{r tbl-goseq-diff, eval = any_goseq_diff, echo = any_goseq_diff}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_diff$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of changed 
        {target} signal. Genes mapped to a differential signal window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_diff %>%
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  mutate(
    gene_name = map_chr(DEgenes,  \(x) paste(id2gene[x], collapse = "; ")),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to DB Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = \(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          value %>% 
            str_replace_all("_", " ") %>% 
            str_replace_all("^(GO|HALLMARK|KEGG|REACTOME|WP)", "\\1:")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = \(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% DB",
        maxWidth = 80,
        cell = \(value) percent(value, 0.1)
      ),
      numDEInCat = colDef(name = "Total Mapped To DB", maxWidth = 80),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = \(value) comma(value, 1)
      ),
      p = colDef(
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to DB Windows" = colDef(
        cell = \(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
    div(class = "table-header",
        div(class = "caption", cp),
        tbl
    )
)
```

`r ifelse(plot_network_diff, "#### Network Plot", "")`

```{r plot-network-diff, eval = plot_network_diff, echo = plot_network_diff, fig.cap=glue("*Network plot showing gene-sets enriched amongst those differential signal for {target}.*")}
tg_diff %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_diff) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```

### Windows With Increased `r target` Signal {.tabset}

```{r goseq-up, fig.show='hide'}
pwf_up <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = increased)
goseq_up <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(pwf_up$diff) > 0) {
  goseq_up <- dplyr::select(pwf_up, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_up <- sum(goseq_up$adj_p < enrich_alpha) > 0
tg_up <- make_tbl_graph(
  goseq_up, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(pwf_up, diff)$gene_id) %>%
    .[map_int(., length) > 0]
)
plot_network_up <- length(tg_up) >= min_network_size
```


`r ifelse(!any_goseq_up, glue("No enrichment was found amongst genes mapped to sites showing increased {target} signal"), "#### Results Table")`


```{r tbl-goseq-up, eval = any_goseq_up, echo = any_goseq_up}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_up$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of increased 
        {target} signal. Genes mapped to an increasing window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_up %>%
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  mutate(
    gene_name = map_chr(DEgenes, \(x) paste(id2gene[x], collapse = "; ")),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to Increasing Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = \(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          value %>% 
            str_replace_all("_", " ") %>% 
            str_replace_all("^(GO|HALLMARK|KEGG|REACTOME|WP)", "\\1:")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = \(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% Gained",
        cell = \(value) percent(value, 0.1),
        maxWidth = 80
      ),
      numDEInCat = colDef(name = "Mapped to Increasing Windows", maxWidth = 80),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = \(value) comma(value, 1)
      ),
      p = colDef(
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to Increasing Windows" = colDef(
        cell = \(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
    div(class = "table-header",
        div(class = "caption", cp),
        tbl
    )
)
```

`r ifelse(plot_network_up, "#### Network Plot", "")`

```{r plot-network-up, eval = plot_network_up, echo = plot_network_up, fig.cap=glue("*Network plot showing  gene-sets enriched amongst those showing increased signal for {target}.*")}
tg_up %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_up) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```


### Windows With Decreased `r target` Signal {.tabset}

```{r goseq-down, fig.show='hide'}
pwf_down <- tibble(gene_id  = unique(gtf_gene$gene_id)) %>% 
  left_join(mapped_ids, by = "gene_id") %>% 
  dplyr::filter(!is.na(n_peaks)) %>% 
  mutate(diff = decreased)
goseq_down <- tibble(
  gs_name = character(), pval = numeric(), adj_p = numeric(), DEgenes = list()
)
if (sum(pwf_down$diff) > 0) {
  goseq_down <- dplyr::select(pwf_down, gene_id, DEgenes = diff) %>% 
    as.data.frame() %>% 
    column_to_rownames("gene_id") %>% 
    goseq_hyper(gene2cat = gs_by_geneid) %>% 
    mutate(adj_p = p.adjust(pval, adj_method)) %>% 
    dplyr::filter(numDEInCat >= min_sig)
}
any_goseq_down <- sum(goseq_down$adj_p < enrich_alpha) > 0
tg_down <- make_tbl_graph(
  goseq_down, 
  gs = gs_by_gsid %>% 
    lapply(intersect, subset(pwf_down, diff)$gene_id) %>%
    .[map_int(., length) > 0]
)
plot_network_down <- length(tg_down) >= min_network_size
```


`r ifelse(!any_goseq_down, glue("No enrichment was found amongst genes mapped to sites showing decreased {target} signal"), "#### Results Table")`


```{r tbl-goseq-down, eval = any_goseq_down, echo = any_goseq_down}
cp <- htmltools::tags$caption(
  htmltools::em(
    glue(
      "
    All {sum(goseq_down$adj_p < enrich_alpha)} gene sets considered as 
    significantly enriched (p
    "
    ),
    htmltools::tags$sub("adj"),
    htmltools::em(
      glue(
        "
         < {enrich_alpha}) amongst the windows showing evidence of decreased 
        {target} signal. Genes mapped to a decreasing window were 
        compared to those mapped to any merged window. A standard (unbiased)
        hypergeomtric test was used to test for enrichment.
        "
      )
    )
  )
)
tbl <- goseq_down %>% 
  dplyr::filter(adj_p < enrich_alpha) %>%
  left_join(
    distinct(msigdb, gs_name, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  mutate(
    gene_name = map_chr(DEgenes, \(x) paste(id2gene[x], collapse = "; ")),
    `%` = numDEInCat / numInCat
  ) %>% 
  dplyr::select(
    `Gene Set` = gs_name, Description = gs_description,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to Decreasing Windows` = gene_name
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    columns = list(
      "Gene Set" = colDef(
        minWidth = 150,
        cell = \(value) htmltools::tags$a(
          href = gs_url[[value]], 
          target = "_blank", 
          value %>% 
            str_replace_all("_", " ") %>% 
            str_replace_all("^(GO|HALLMARK|KEGG|REACTOME|WP)", "\\1:")
        ),
        html = TRUE
      ),
      Description = colDef(
        minWidth = 150,
        cell = \(value) with_tooltip(value, width = 100)
      ),
      "%" = colDef(
        name = "% Decreased",
        cell = \(value) percent(value, 0.1),
        maxWidth = 80
      ),
      numDEInCat = colDef(name = "Mapped to Decreasing Windows", maxWidth = 90),
      numInCat = colDef(
        name = "Total Mapped",
        maxWidth = 80,
        cell = \(value) comma(value, 1)
      ),
      p = colDef(
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      adj_p = colDef(
        name = "p<sub>adj</sub>", html = TRUE,
        cell = \(value) {
          ifelse(
            value < 0.001, sprintf("%.2e", value), sprintf("%.3f", value)
          )
        },
        maxWidth = 70
      ),
      "Genes Mapped to Decreasing Windows" = colDef(
        cell = \(value) with_tooltip(value, width = 100),
        minWidth = 200
      )
    )
  )
div(class = "table",
    div(class = "table-header",
        div(class = "caption", cp),
        tbl
    )
)
```

`r ifelse(plot_network_down, "#### Network Plot", "")`

```{r plot-network-down, eval = plot_network_down, echo = plot_network_down, fig.cap=glue("*Network plot showing gene-sets enriched amongst those showing decreased signal for {target}.*")}
tg_down %>% 
  ggraph(layout = net_layout, weights = oc^2) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(fill = -log10(pval), size = numDEInCat),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% str_trunc(60) %>% str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_down) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.25) +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none") +
  labs(size = "Mapped Genes", edge_width = expr(paste(OC^2))) +
  theme_void() 
```

# CHECK RNASEQ MODULE

```{r add-rna, eval = has_rnaseq, child = here::here('workflow/modules/rnaseq_differential.Rmd')}
```


## Data Export

```{r export-diff-by-gene}
results %>% 
  as_tibble() %>%
  unnest(all_of("gene_id")) %>%
  mutate(gene_name = id2gene[gene_id]) %>% 
  dplyr::select(
    gene_id, gene_name, range, logCPM, logFC, PValue, !!sym(fdr_column), 
    status, any_of(c("region", "feature")), macs2_peak = overlaps_ref,
  ) %>% 
  mutate(
    distance_to_gene = distance(
      GRanges(range),
      setNames(gtf_gene, gtf_gene$gene_id)[gene_id]
    )
  ) %>% 
  write_csv(
    gzfile(all_out$csv)
  )
```


```{r data-export, results='hide'}
write_rds(results, all_out$results, compress = "gz")
file.create(all_out$de_genes)
if (has_rnaseq) write_csv(de_genes_db_regions, all_out$de_genes)

file.create(all_out$up_regions)
if (sum(results$status == "Increased") > 0) {
  results %>% 
    filter(status == "Increased") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}

file.create(all_out$down_regions)
if (sum(results$status == "Decreased") > 0) {
  results %>% 
    filter(status == "Decreased") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}
## Enrichment results need a bit of tweaking to match the tables
list2(
  `All Differentially Bound` = goseq_diff,
  "All Increased {target}" := goseq_up,
  "All Decreased {target}" := goseq_down
) %>% 
  bind_rows(.id = 'group') %>% 
  dplyr::filter(adj_p < enrich_alpha) %>% 
  left_join(
    dplyr::select(msigdb, gs_name, gene_name, gene_id, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  dplyr::filter(
    gene_id %in% unlist(subset(results, status != "Unchanged")$gene_id)
  ) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  mutate(
    gene_name = map_chr(gene_name, paste, collapse = ": "),
    `%` = numDEInCat / numInCat,
  ) %>% 
  dplyr::select(
    group,
    `Gene Set` = gs_name, Description = gs_description, URL = gs_url,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to DB Windows` = gene_name
  ) %>% 
  write_csv(all_out$enrichment)
list2(
  `All Differentially Bound` = cmn_diff,
  "All Increased {target}" := cmn_up,
  "All Decreased {target}" := cmn_down
) %>% 
  bind_rows(.id = "group") %>% 
  mutate(
    genes = map_chr(leadingEdge, paste, collapse = "; "),
    leadingEdge = map_chr(leadingEdge, paste, collapse = "; "),
  ) %>% 
  write_csv(all_out$rna_enrichment)
## Save key memory on the HDD
gc()
save.image(all_out$renv)
```

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, "output.+"))`

## References

<div id="refs"></div>
<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">

```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```

</div>
