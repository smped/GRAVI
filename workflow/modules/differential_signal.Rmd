
```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```


```{r set-params, eval = interactive(), echo = FALSE}
# params <- list(
#   target = "AR",
#   treat_levels = c("E2", "E2DHT"), 
#   results = "output/differential_signal/AR/AR_E2_E2DHT-differential-signal.rds",
#   counts = "output/differential_signal/AR/AR_counts.rds",
#   ihw = "output/differential_signal/AR/AR_E2_E2DHT-ihw.rds"
# )
```

```{r packages}
library(tidyverse)
library(glue)
library(pander)
library(IHW)
library(extraChIPs)
library(yaml)
library(reactable)
library(qsmooth)
library(edgeR)
library(patchwork)
library(scales)
library(htmltools)
library(rlang)
library(rtracklayer)
library(ggrepel)
library(GenomicInteractions)
library(parallel)
library(tidygraph)
library(ggraph)
library(BiocParallel)
# library(plyranges)
# library(quantro)
# library(Rsamtools)
# library(statmod)
# library(metap)
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
threads <- parallel::detectCores() - 1
register(MulticoreParam(workers = threads))
source(here::here("workflow", "scripts", "custom_functions.R"))
source(here::here("workflow", "scripts", "table_funs.R"))
source(here::here("workflow", "scripts", "enrichment_funs.R"))
config <- read_yaml(here::here("config", "config.yml"))
all_paths <- here::here("config", "json", "all_paths.json") %>% 
    jsonlite::fromJSON() %>% 
    lapply(here::here)
ucsc <- get_ucsc(config$genome$build)
```

```{r load-data}
counts <- here::here(params$counts) %>% 
  read_rds() 
counts <- counts[, counts$treat %in% treat_levels]
colData(counts) <- droplevels(colData(counts))
n_max <- min(5e5, nrow(counts))

results <- here::here(params$results) %>% read_rds()
diff_sig_params <- metadata(results)
fdr_column <- ifelse(
  "fdr_ihw" %in% colnames(mcols(results)), "fdr_ihw", "FDR"
)
fdr_alpha <- diff_sig_params$alpha

has_features <- "feature" %in% colnames(mcols(results))
n_sig <- sum(mcols(results)[[fdr_column]] < fdr_alpha)
ihw <- here::here(params$ihw) %>% read_rds()
```



```{r set_params, echo = FALSE, eval=TRUE}
target <- params$target
treat_levels <- params$treat_levels
comp <- params$results %>% 
  basename() %>% 
  str_remove_all("-differential-signal.rds")

all_heat_params <- here::here("config", "params.yml") %>%
  read_yaml() %>%
  pluck("profile_heatmaps")
heat_params <- all_heat_params$default
if (target %in% names(all_heat_params)) {
  nm <- names(all_heat_params[[target]])
  heat_params[nm] <- all_heat_params[[target]][nm]
}
enrich_params <- here::here("config", "params.yml") %>%
  read_yaml() %>%
  pluck("enrichment")
network_params <- here::here("config", "params.yml") %>%
  read_yaml() %>%
  pluck("networks")
region_params <- here::here("config", "params.yml") %>%
  read_yaml() %>%
  pluck("gene_regions")
```




```{r load-annotations}
gtf_gene <- file.path(all_paths$annotation, "gtf_gene.rds") %>% read_rds()
id2gene <- structure(gtf_gene$gene_name, names = gtf_gene$gene_id)

colours <- read_rds(file.path(all_paths$annotation, "colours.rds")) %>% 
  lapply(unlist)

feature_colours <- setNames(
  colours$features, str_sep_to_title(names(colours$features))
)
features <- here::here(all_paths$annotation, "features.rds") %>%
  read_rds()
hic <- file.path(all_paths$annotation, "hic.rds") %>% read_rds()
has_hic <- length(hic) > 0

gene_regions <- file.path(all_paths$annotation, "gene_regions.rds") %>% 
  read_rds()
regions <- map_chr(gene_regions, \(x) unique(x$region))
region_colours <- setNames(colours$regions, regions[names(colours$regions)])

direction_colours <- colours$direction %>% 
  setNames(str_to_title(names(.))) %>% 
  .[names(.) %in% c("Increased", "Decreased", "Unchanged", "Ambiguous")]
treat_colours <- colours$treat[treat_levels]

full_palette <- c(
  feature_colours, region_colours, direction_colours, treat_colours,
  colours$target,
  c(
    "None" = colours$direction[["undetected"]],
    "Other" = colours$direction[["unchanged"]])
)

fig_params <- here::here("config", "rmarkdown.yml") %>% 
  read_yaml() %>% 
  pluck("knitr_opts")
fw <- fig_params$fig.width
fh <- fig_params$fig.height
fig_type <- fig_params$dev[[1]]
if (is.null(fig_type)) stop("Couldn't detect figure type")
fig_fun <- match.fun(fig_type)
if (fig_type %in% c("bmp", "jpeg", "png", "tiff")) {
  ## These figure types require dpi & resetting to be inches
  formals(fig_fun)$units <- "in"
  formals(fig_fun)$res <- 300
}
fig_path <- here::here("docs", "assets", comp)
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE)

has_rnaseq <- FALSE ## To be added in again later
```


## Outline

Differential Signal Analysis (DSA) was performed in a standalone R script prior to compilation of this document.
The initial stages of this page describe the data as important QC steps, before moving onto the results from DSA.
All steps rely heavily on the functions implemented in the Bioconductor package [extraChIPs](https://bioconductor.org/packages/release/bioc/html/extraChIPs.html).


<!-- ### Enrichment Analysis -->

<!-- Beyond the simple analysis of differential signal, peaks are mapped to genes and enrichment testing is performed on the following: -->

<!-- 1. Genes mapped to any range with detected `r target` are compared to all genes not mapped to any range -->
<!-- 2. Genes mapped to *all ranges with differential signal* are compared to genes mapped to ranges with no difference in signal -->
<!-- 3. Genes mapped to ranges with *increasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->
<!-- 4. Genes mapped to ranges with *decreasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->

<!-- Enrichment testing is performed using `goseq` [@YoungGoseq2010] with no term accounting for sampling bias (i.e. the Hypergeometric Distribution), *except when comparing genes mapped to any window.* -->
<!-- For this case **only**, gene width is used to capture any sampling bias and Wallenius' Non-Central Hypergeometric Distribution is used. -->
<!-- As RNA-seq data `r ifelse(has_rnaseq, "was", "was not")` provided, the genes considered for enrichment analysis are the `r comma(length(unique(gtf_gene$gene_id)))` `r ifelse(has_rnaseq, "genes considered as detected in the RNA-Seq data", "annotated genes")`. -->

<!-- `r if (has_rnaseq) "### Incorporation with RNA-Seq"` -->

<!-- `r if (has_rnaseq) "Any association between differentially expressed genes and differential signal regions will be assessed using Gene Set Enrichment Analysis [@SubramanianGsea2005], as implemented in the fgsea package [@KorotkevichFgsea2019]. The sets of genes associated with changed signal will be subset by regions and any provided external features, and these novel gene-sets will be used to test for enrichment within the RNA-Seq results. ChIP-seq derived gene-sets will be tested for differential expression using genes ranked directionally and by significance alone. A combined meta-analytic approach using Wilkinson's method will also be used to integration of results from enrichment testing in each standalone dataset."` -->

## Data Inspection {.tabset}

```{r build-required-assays}
norm <- ifelse(diff_sig_params$norm == "sq", "none", diff_sig_params$norm)
dge <- calcNormFactors(counts, method = diff_sig_params$norm)
dge$samples$lib.size <- counts$totals
lcpm <- cpm(dge, log = TRUE) 
rownames(lcpm) <- NULL
assay(counts, "logCPM") <- lcpm
if (diff_sig_params$norm == "sq") {
  norm <- "sq"
  qs <- qsmooth(lcpm, group_factor = counts$treat)
  assay(counts, "qsmooth") <- qsmoothData(qs)
}
n_assays <- length(assayNames(counts))
```


`r if (norm == "sq") "### QSmooth Weights"` 

```{r plot-sq-weights, echo = norm == "sq", fig.height = 6, fig.cap = "*Quantile-specific weights used by the Smooth-Quantile normalisation. Low weights indicate signal quantiles which appear to be more specific within a group, whilst higher weights indicate similarity between groups.*"}
if (norm == "sq")
  qsmoothPlotWeights(
    qs, xLab = "Quantiles", yLab = "Weights", mainLab = "QSmooth Weights"
  )
```


### Densities

```{r plot-densities, fig.height = 6, fig.cap = "*Distributions of counts for each sample within each treatment group shown as a distinct colour.*"}
plot_trans <- list("log1p", NULL, NULL)
counts %>% 
  assayNames() %>% 
  seq_along() %>% 
  lapply(
    \(i) {
      nm <- assayNames(counts)[[i]]
      counts %>%
        plotAssayDensities(
          nm, colour = "treat", n_max = n_max, trans = plot_trans[[i]]
        ) +
        scale_colour_manual(values = full_palette) +
        labs(colour = "Treat")
    }
  ) %>% 
  wrap_plots() + 
  plot_layout(guides = "collect", axis_titles = "collect") +
  plot_annotation(tag_levels = "A")
```

### RLE

```{r plot-rle, fig.height=6, fig.cap = glue("*RLE plot showing two perspectives on the data. (A) shows all samples with median values taken across all samples. If any differences are evident between treatment groups, library-size or smooth-quantile normalisation may be the best approaches for normalisation. (B) shows all samples taking median values within treatment groups and potentially highlights any problematic samples within each groups.*")}
plot_assay <- assayNames(counts)[n_assays]
a <- counts %>% 
  plotAssayRle(
    plot_assay, fill = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = full_palette) +
  ggtitle(glue("RLE: No Grouping")) +
  labs(x = "Sample", fill = "Treat") 
b <- counts %>% 
  plotAssayRle(
    plot_assay, fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  ggtitle(glue("RLE: Grouping by Treat")) +
  scale_fill_manual(values = full_palette) +
  labs(x = "Sample", fill = "Treat")
a + b + 
  plot_layout(guides = "collect", axis_titles = "collect") + 
  plot_annotation(tag_levels = "A")
```

### PCA

```{r plot-qsmooth-pca, fig.cap = "*PCA showing the amount of variance attributed to each component*"}
plotAssayPCA(
  counts, plot_assay, colour = "treat", label = "label", show_points = FALSE
) +
  scale_colour_manual(values = full_palette) +
  guides(colour = "none") +
  ggtitle(glue("PCA ({plot_assay})"))
```



## DSA Results 

`r metadata(results)$description`

### Result Tables {.tabset}

```{r tbl-setup}
n_unch <- sum(results$status == "Unchanged")
n_windows <- length(results)
region_type <- ifelse(
  diff_sig_params$window_type == "fixed", "Peaks", "Windows"
)
tbl_cols <- list(
  Region = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  feature = colDef(
    "Feature", cell = \(value) str_sep_to_title(value),
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Increased = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- up_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Decreasd = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- down_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Ambiguous = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Unchanged = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / n_windows
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Changed` = colDef(
    format = percent_col,
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    align = "right",
    footer = htmltools::tags$b(
      percent(sum(1 - n_unch / n_windows), 0.1)
    )
  ),
  Total = colDef(
    format = comma_col,
    style = \(value) {
      bar_style(width = value / n_windows, fill = "#B3B3B3", align = "right")
    },
    align = "right",
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Of All Windows` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  ),
  `% Of All Peaks` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  )
)
```


#### Overall Results

```{r tab-overall}
tbl <- results %>% 
  mutate(w = width) %>% 
  as_tibble() %>% 
  summarise(
    n = dplyr::n(), 
    width = median(w),
    logCPM = median(logCPM),
    .by = all_of("status")
  ) %>% 
  mutate(`%` = n / sum(n)) %>% 
  dplyr::select(status, n, `%`, everything()) %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      status = colDef(
        name = "Status", maxWidth = 150,
        footer = htmltools::tags$b("Overall")
      ),
      n = colDef(
        name = glue("Nbr of {region_type}"), 
        maxWidth = 150, format = colFormat(separators = TRUE),
        footer = htmltools::tags$b(comma(length(results)))
      ),
      width = colDef(
        name = "Median Width (bp)", format = colFormat(digits = 1),
        footer = htmltools::tags$b(round(median(width(results)), 1)),
        maxWidth = 200
      ),
      `%` = colDef(
        name = glue("% Total {region_type}"), 
        format = colFormat(percent = TRUE, digits = 1),
        style = \(value) bar_style(width = value, align = "right"),
        maxWidth = 150
      ),
      logCPM = colDef(
        name = "Median Signal (logCPM)",
        format = colFormat(digits = 3),
        maxWidth = 200,
        footer = htmltools::tags$b(
          round(median(results$logCPM), 3)
        )
      )
    )
  )
cp <- htmltools::em(
  glue(
    "
    Overall results for changed {target} signal when comparing signal from 
    {treat_levels[[2]]} aginst the baseline signal observed in {treat_levels[[1]]}.
    "
  )
)
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


#### Summary By Region

```{r tab-res-by-region}
df <- results %>% 
  select(status, !!sym(fdr_column), region) %>% 
  as_tibble() %>% 
  group_by(region, status) %>% 
  summarise(n = dplyr::n(), .groups = "drop") %>% 
  complete(region, status, fill = list(n = 0)) %>% 
  group_by(region) %>% 
  mutate(Total = sum(n)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    "% Of All {region_type}" := Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(region) %>% 
  dplyr::select(
    Region = region,
    any_of(names(direction_colours)),
    `% Changed`, Total, starts_with("% Of All")
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which genomic region contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = \(values) htmltools::tags$b(comma(sum(values)))
    ),
    fullWidth = TRUE, elementId = 'tbl-results-by-region'
  )
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r ifelse(has_features, "#### Summary By Feature", "")`

```{r tab-res-by-feature, echo = has_features}
if (has_features) {
  df <- results %>% 
    select(status, !!sym(fdr_column), feature) %>% 
    as_tibble() %>% 
    group_by(feature, status) %>% 
    tally() %>% 
    ungroup() %>% 
    complete(feature, status, fill = list(n = 0)) %>% 
    mutate(Total = sum(n), .by = all_of("feature")) %>% 
    pivot_wider(names_from = "status", values_from = "n") %>% 
    dplyr::filter(Total > 0) %>% 
    mutate(
      "% Of All {region_type}" := Total / length(results),
      `% Changed` = 1 - Unchanged / Total
    ) %>% 
    arrange(feature) %>% 
    dplyr::select(
      feature, any_of(names(direction_colours)),
      `% Changed`, Total, starts_with("% Of All")
    )
  cp <- htmltools::em(
    glue(
      "Overall results for changed {target} signal in the ",
      glue_collapse(rev(treat_levels), last = " Vs. "),
      " comparison, broken down by which external feature contains the largest ", 
      "overlap with each range in the set of results."
    )
  )
  tbl <- df %>%
    reactable(
      columns = tbl_cols[colnames(df)],
      defaultColDef = colDef(
        footer = \(values) htmltools::tags$b(comma(sum(values)))
      ),
      elementId = 'tbl-results-by-feature'
    )
  tl <- tagList(tbl, cp)
  if (interactive()) {
    htmltools::browsable(tl)
  } else {
    tl
  }
}
```


#### Most Highly Ranked

```{r tab-highly-ranked}
show_n <- min(200, length(results))
scaling_vals <- list(
  logFC = c(-1, 1)*max(abs(results$logFC)),
  logCPM = range(results$logCPM),
  Width = max(width(results))
)
cp <- htmltools::em(
  glue(
    "The {show_n} most highly-ranked ranges by FDR, with {comma(n_sig)} ", 
    "in total showing evidence of changed {target} signal. ",
    "Regions were assigned based on which genomic region showed the largest ",
    "overlap with the range being analysed. ",
    ifelse(
      has_features, 
      glue(
        glue("Features are as provided in "), 
        glue_collapse(basename(config$external$features), sep = ", ", last = " and "),
        ". "
      ),
      glue("")
    ),
    "For ranges mapped to large numbers of genes, hovering a mouse over the ", 
    "cell will reveal the full set of genes. "
  )
)
fs <- 12
tbl <- results %>%
  mutate(w = width) %>% 
  arrange(!!sym(fdr_column)) %>% 
  plyranges::slice(seq_len(show_n)) %>% 
  plyranges::select(
    w, starts_with("log"), !!sym(fdr_column), status,
    Region = region, any_of("feature"), Genes = gene_name
  ) %>% 
  as_tibble() %>% 
  dplyr::rename(Range = range, `Width (bp)` = w) %>% 
  rename_with(\(x) str_replace_all(x, "feature", "Feature")) %>% 
  mutate(
    Genes = map_chr(Genes, paste, collapse = "; "),
    across(any_of("Feature"), str_sep_to_title)
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 20, 50, show_n), defaultPageSize = 10,
    borderless  = TRUE,
    columns = list2(
      Range = colDef(
        minWidth = 10 * fs,
        cell = \(value) str_replace_all(value, ":", ": ")
      ),
      `Width (bp)` = colDef(
        style = \(value) {
          x <- value / scaling_vals$Width
          colour <- expr_col(x)
          list(
            background = colour, 
            borderRight = "1px solid rgba(0, 0, 0, 0.1)"
          )
        },
        maxWidth = 5 * fs
      ),
      logCPM = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logCPM)) / diff(scaling_vals$logCPM)
          colour = expr_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      logFC = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logFC)) / diff(scaling_vals$logFC)
          colour <- lfc_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      "{fdr_column}" := colDef(
        name = "FDR",
        cell = \(value) {
          fmt <- ifelse(value < 0.01, "%.2e", "%.3f")
          sprintf(fmt, value)
        },
        style = \(value) {
          text_colour <- ifelse(
            value < params$alpha, "black", direction_colours[["Unchanged"]]
          )
          list(color = text_colour, borderRight = "1px solid rgba(0, 0, 0, 0.1)")
        },
        maxWidth = 5.5 * fs
      ),
      status = colDef(
        "Status", maxWidth = 80,
        style = \(value) {
          i <- which(names(direction_colours) == value)
          list(color = direction_colours[[i]])
        } 
      ),
      Region = colDef(maxWidth = 150),
      Genes = colDef(
        cell = \(value) with_tooltip(value, width = ifelse(has_features, 30, 60)),
        minWidth = 11 * fs
      )
    ),
    theme = reactableTheme(style = list(fontSize = fs)),
    elementId = 'tbl-top-ranked'
  )
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('tbl-top-ranked', '{comp}_top_ranked.csv')"
    )
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('tbl-top-ranked', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


### Summary Plots {.tabset}

```{r make-heatmaps}
region_type <- str_to_lower(region_type)
bw_type <- match.arg(heat_params$bw_type, c("FE", "coverage"))
fill_type <- c(coverage = "logCPM", FE = "Fold-Enrichment")[bw_type]
bwfl <- file.path(
  all_paths$macs2, target, ifelse(
    bw_type == "coverage",
    "{target}_{treat_levels}_merged_treat_pileup.bw",
    "{target}_{treat_levels}_merged_FE.bw"
  )
) %>% 
  glue() %>% 
  BigWigFileList() %>% 
  setNames(treat_levels) 
sig_ranges <- results %>% 
  filter(!!sym(fdr_column) < fdr_alpha) %>%
  splitAsList(f = .$status) %>% 
  .[map_int(., length) > heat_params$min_ranges] 
if (diff_sig_params$window_type == "sliding") {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "keyval_range")
} else {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "centred_peak")
}
sig_profiles <- lapply(sig_ranges, as.null)
for (i in names(sig_profiles)) {
  set.seed(threads)
  temp_gr <- granges(sig_ranges[[i]])
  n <- length(temp_gr)
  if (n > heat_params$max_ranges) 
    temp_gr <- temp_gr[sort(sample.int(n, heat_params$max_ranges))]
  sig_profiles[[i]] <- getProfileData(
    bwfl, temp_gr, upstream = heat_params$width / 2, 
    log = bw_type == "coverage", bins = heat_params$n_bins, 
    BPPARAM = bpparam()
  )
  rm(temp_gr)
}
profile_heatmaps <- list()

if (length(sig_profiles) > 0) {
  profile_heatmaps <- sig_profiles %>% 
    parallel::mclapply(
      plotProfileHeatmap,
      profileCol = "profile_data", colour = "name",
      xLab = "Distance from Centre (kb)", fillLab = fill_type,
      labelFunX = comma_format(accuracy = 0.1, scale = 1e-3),
      mc.cores = max(1, length(sig_profiles))
    ) 
  fill_range <- profile_heatmaps %>% 
    lapply(\(x) x$data[,"score"]) %>% 
    unlist() %>%
    range()
  sidey_range <- profile_heatmaps %>% 
    lapply(\(x) x$layers[[3]]$data$y) %>% 
    unlist() %>% 
    range()
  profile_heatmaps <- profile_heatmaps %>% 
    lapply(
      \(x) {
        suppressWarnings(
          x + 
            scale_fill_gradientn(
                colours = heat_params$gradient, limits = fill_range
            ) +
            scale_xsidey_continuous(limits = sidey_range) +
            scale_colour_manual(values = treat_colours) +
            labs(
              x = "Distance from Centre (kb)",
              fill = fill_type, colour = "Treat"
            ) +
            theme(strip.text.y = element_text(angle = 0))
        )
      }
    )
}
```


#### MA Plot

```{r plot-ma, fig.cap = glue("*MA plot showing the status of all {type} under consideration. The two most extreme {type} are labelled by region and any associated genes, whilst the overall pattern of association between signal level (logCPM) and changed signal (logFC) is shown as the blue curve.*")}
if (!"Ambiguous" %in% levels(results$status)) 
  direction_colours <- direction_colours[names(direction_colours) != "Ambiguous"]
results %>% 
  as_tibble() %>%
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, bs = "cs")) +
  geom_hline(yintercept = 0) +
  geom_label_repel(
    aes(y = logFC, label = annot, colour = status),
    data = . %>%
      dplyr::filter(!!sym(fdr_column) < fdr_alpha) %>% 
      arrange(desc(abs(logFC))) %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = full_palette) +
  labs(x = "Ave Signal (logCPM)", colour = "Status") 
```


#### Volcano Plot

```{r plot-volcano, fig.cap = glue("*Volcano plot showing {type} with evidence of differential {target} signal. The most significant {type} are labelled along with any genes these regions are mapped to.*")}
results %>% 
  as_tibble() %>% 
  ggplot(aes(logFC, -log10(PValue))) +
  geom_point(aes(colour = status), alpha = 0.6) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data = . %>%
      arrange(PValue) %>%
      dplyr::filter(!!sym(fdr_column) < fdr_alpha) %>% 
      droplevels() %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = full_palette) +
  labs(
    x = "logFC",
    y = expression(paste(-log[10], "p")),
    colour = "Status"
  )
```



```{r plot-all-profile-heatmaps, echo = FALSE}
htmltools::tagList(
  mclapply(
    seq_along(profile_heatmaps),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(profile_heatmaps)[[i]])
      img_out <- file.path(
        fig_path,
        glue("{nm}_profile_heatmap.{fig_type}")
      )
      n_ranges <- length(sig_profiles[[i]][[1]])
      fig_fun(
        filename = img_out, width = fw, 
        height = min(3.5 + fh * n_ranges / 1.5e3, fh)
      )
      print(profile_heatmaps[[i]])
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(
        glue(
          "
        {n_ranges} {region_type} selected as showing {nm} signal. Heatmaps were 
        restricted to a maximum of {comma(heat_params$max_ranges)} {region_type}. Values 
        shown are use the {bw_type}-based bigwig files produced by macs2 callpeak.
        "
        )
      )
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(
            glue("Profile Heatmaps: {str_to_title(nm)} Signal")
          ),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


#### Signal By Region

```{r boxplot-regions, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each genomic region.*"}
results %>% 
  select(logCPM, logFC, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    ),
  ) %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(x, value, fill = region)) +
  geom_boxplot() +
  facet_grid(rows = vars(name), scales = "free", switch = "y") +
  scale_fill_manual(values = full_palette) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r if (n_sig > 0) "#### Differential Signal By Region"`

```{r plot-db-regions, eval = n_sig > 0, echo = n_sig > 0, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all genomic regions.*")}
results %>% 
  dplyr::filter(!!sym(fdr_column) < fdr_alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Region = region) %>% 
  droplevels() %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Region", min_p = 0.02,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = full_palette, outer_palette = full_palette
  )
```

`r ifelse(has_features, "#### Signal By Feature", "")`

```{r boxplot-features, echo = has_features, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each external feature.*"}
if (has_features) {
  results %>% 
    select(logCPM, logFC, feature) %>% 
    as_tibble() %>% 
    pivot_longer(cols = c("logCPM", "logFC")) %>% 
    ggplot(aes(feature, value, fill = feature)) +
    geom_boxplot() +
    facet_grid(rows = vars(name), scales = "free", switch = "y") +
    scale_fill_manual(values = colours$features) +
    labs(x = "Feature", y = c(), fill = "Overlaps") 
}
```

`r ifelse(has_features, "#### Differential Signal By Feature", "")`

```{r plot-db-features, echo = has_features, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all external features.*")}
if (has_features) {
  results %>% 
    dplyr::filter(!!sym(fdr_column) < fdr_alpha) %>%
    as_tibble() %>% 
    mutate(feature = str_sep_to_title(feature)) %>% 
    dplyr::rename("{target}" := status, Feature = feature) %>% 
    plotSplitDonut(
      inner = !!sym(target), outer = "Feature", min_p = 0.01,
      inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
      outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
      inner_palette = full_palette,
      outer_palette = full_palette
    )
}
```


### Inspection of Top-Ranked Regions {.tabset}

```{r get-cmn-plot-objects}
cb <- config$genome$build %>% 
  str_to_lower() %>% 
  paste0(".cytobands") 
data(list = cb)
bands_df <- get(cb)
stopifnot(
  colnames(bands_df) == c("chrom", "chromStart", "chromEnd", "name", "gieStain")
)
trans_models <- file.path(all_paths$annotation, "trans_models.rds") %>% 
  read_rds() 
```


```{r grl-to-plot}
## Define a GRL with the key ranges.
## Then we can step through it & make all of the requisite plots
grl_to_plot <- GRangesList(
  
  top_inc_by_fdr = results %>% 
    filter(logFC > 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_inc_by_lfc = filter(results, logFC == max(logFC)),
  
  top_dec_by_fdr = results %>% 
    filter(logFC < 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_dec_by_lfc = filter(results, logFC == min(logFC))
  
) %>% 
  unlist() %>% 
  .[!duplicated(.)] %>%
  splitAsList(names(.)) %>% 
  lapply(setNames, c()) %>% 
  lapply(\(x) x[1]) %>%
  GRangesList()
```


```{r prepare-plot-objects}
## The coverage
bwfl <- list2(
  "{target}" := file.path(
    all_paths$macs2, target, "{target}_{treat_levels}_merged_treat_pileup.bw"
  ) %>% 
    glue() %>% 
    BigWigFileList() %>% 
    setNames(treat_levels)
)
line_col <- list2("{target}" := treat_colours)
## Coverage annotations
annot <- results %>% 
  splitAsList(.$status) %>% 
  .[map_int(., length) > 0] %>% 
  endoapply(granges) %>% 
  list() %>% 
  setNames(target)
## Coverage y-limits
ind <- counts %>% 
  assay("counts") %>% 
  apply(MARGIN = 2, which.max) %>%
  unique()
max_ranges <- rowRanges(counts[ind])
y_lim <- bwfl[[target]] %>%
  lapply(import.bw, which = max_ranges) %>%
  lapply(\(x) c(0, max(x$score))) %>% 
  unlist() %>% 
  range() %>% 
  list() %>% 
  setNames(target)

## The features track
feat_gr <- gene_regions %>% 
  lapply(granges) %>% 
  GRangesList()
feat_col_hfgc <- colours$regions
if (has_features) {
  feat_gr <- list(Regions = feat_gr)
  feat_gr$Features <- features
  feat_col_hfgc <- list(
    Regions = unlist(colours$regions),
    Features = unlist(colours$features)
  )
}

## The genes track
hfgc_genes <- trans_models
gene_col <- "grey"
# if (has_rnaseq) {
#   if (!is.na(rna_lfc_col) & !is.na(rna_fdr_col)) {
#     hfgc_genes <- trans_models %>% 
#       mutate(
#         status = case_when(
#           !gene %in% rnaseq$gene_id ~ "Undetected",
#           gene %in% dplyr::filter(
#             rnaseq, !!sym(rna_lfc_col) > 0, !!sym(rna_fdr_col) < params$alpha
#           )$gene_id ~ "Up",
#           gene %in% dplyr::filter(
#             rnaseq, !!sym(rna_lfc_col) < 0, !!sym(rna_fdr_col) < params$alpha
#           )$gene_id ~ "Down",
#           gene %in% dplyr::filter(
#             rnaseq, !!sym(rna_fdr_col) >= params$alpha
#           )$gene_id ~ "Unchanged",
#         )
#       ) %>% 
#       splitAsList(.$status) %>% 
#       lapply(select, -status) %>% 
#       GRangesList()
#     gene_col <- colours$direction %>% 
#       setNames(str_to_title(names(.)))
#   }
# }

## External Coverage (Optional)
if (!is.null(config$external$coverage)) {
  ext_cov_path <- config$external$coverage %>% 
    lapply(unlist) %>% 
    lapply(\(x) setNames(here::here(x), names(x)))
  bwfl <- c(
    bwfl[target],
    lapply(ext_cov_path, \(x) setNames(BigWigFileList(x), names(x)))
  )
  line_col <- c(
    line_col[target],
    ext_cov_path %>% 
      lapply(
        \(x) {
          missing <- setdiff(names(x), names(colours$treat))
          cmn <- intersect(names(x), names(colours$treat))
          col <- setNames(character(length(names(x))), names(x))
          if (length(cmn) > 0) col[cmn] <- colours$treat[cmn]
          if (length(missing) > 0) 
            col[missing] <- hcl.colors(
              max(5, length(missing)), "Zissou 1")[seq_along(missing)]
          col
        }
      )
  )
  
  y_ranges <- grl_to_plot %>% 
    unlist() %>% 
    granges() %>% 
    resize(w = 10 * width(.), fix = 'center')
  
  y_lim <- c(
    y_lim[target],
    bwfl[names(bwfl) != target] %>% 
      lapply(
        \(x) {
          GRangesList(lapply(x, import.bw, which = y_ranges)) %>% 
            unlist() %>% 
            filter(score == max(score)) %>% 
            mcols() %>% 
            .[["score"]] %>% 
            c(0) %>% 
            range()
        }
      )
  )
  
}
```



```{r plot-all-top-ranges}
.makeCaption <- function(.gr) {
  if (is.null(.gr)) return(NULL)
  dir <- str_to_lower(.gr$status)
  reg <- case_when(
    str_detect(.gr$region, "Inter") ~ paste("an", .gr$region, "region"),
    str_detect(.gr$region, "Upstream") ~ paste("an", .gr$region),
    str_detect(.gr$region, "(Ex|Intr)on") ~ paste("an", .gr$region),
    str_detect(.gr$region, "^Prom") ~ paste("a", .gr$region)
  )
  feat <- c()
  if (has_features) feat <- case_when(
    str_detect(.gr$feature, "^[AEIOU]") ~ paste("an", .gr$feature),
    !str_detect(.gr$feature, "^[AEIOU]") ~ paste("a", .gr$feature)
  )
  gn <- unlist(.gr$gene_name)
  fdr <- mcols(.gr)[[fdr_column]]
  fdr <- ifelse(
    fdr < 0.001, sprintf('%.2e', fdr), sprintf('%.3f', fdr)
  )
  cp <- c(
    glue(
      "*The {width(.gr)}bp region showing {dir} {target} signal in response to ", 
      "{treat_levels[[2]]} treatment (FDR = {fdr}). ",
      "The range mostly overlapped with {reg}, with all ",
      "defined regions shown as a contiguous bar in the upper panel. ",
      ifelse(
        has_features,
        glue(
          "Using the features supplied in {basename(config$external$features)}, ",
          "this mostly overlapped {feat}, shown as a separate block ",
          "with the gene-centric regions. "
        ),
        glue("")
      )
    ),
    ifelse(
      length(gn) > 0,
      paste0(
        "Using the above mapping strategy, this range is likely to regulate ",
        collapseGenes(gn, format = ""), "."
      ),
      "No genes were able to be assigned to this region."
    ),
    paste(
      "For each sample, the y-axis limits represent the values from the window", 
      "with the highest signal.*"
    )
  )
  paste(cp, collapse = " ")
}
htmltools::tagList(
  mclapply(
    seq_along(grl_to_plot),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(grl_to_plot)[[i]])
      tag <- nm %>% 
        str_replace_all("_", " ") %>%
        str_to_title() %>% 
        str_replace_all("(Dec|Inc)", "\\1reased Range (") %>% 
        str_replace_all("Fdr", "FDR") %>% 
        str_replace_all("Lfc", "logFC") %>% 
        str_replace_all("\\( (.+)$", "(\\1)")
      img_out <- file.path(fig_path, glue("{nm}.{fig_type}"))
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = knitr::opts_current$get("fig.height")
      )
      plotHFGC(
        grl_to_plot[[i]],
        hic = hic,
        features = feat_gr, featcol = feat_col_hfgc, featsize = 1 + has_features,
        genes = hfgc_genes, genecol = gene_col,
        coverage = bwfl, linecol = line_col,
        annotation = annot, 
        annotcol = direction_colours,
        cytobands = bands_df,
        zoom = 10,
        max = 8e3,
        ylim = y_lim,
        col.title = "black", background.title = "white", showAxis = FALSE,
        rotation.title = 90
      )
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(.makeCaption(grl_to_plot[[i]]))
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(tag),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```

### Independent Hypothesis Weighting {.tabset}

`r ifelse(diff_sig_params$ihw == "none", "No IHW was applied", paste("IHW was applied based on the relation ship of each peak to", diff_sig_params$ihw))`

`r if (diff_sig_params$ihw != "none") "#### IHW Impact Table"`

```{r tbl-ihw, echo =  diff_sig_params$ihw != "none"}
if (diff_sig_params$ihw != "none") {
  ihw %>%
    as.data.frame() %>% 
    mutate(
      fdr = p.adjust(pvalue, "fdr"),
      ihw_status = case_when(
        fdr < fdr_alpha & adj_pvalue > fdr_alpha ~ "Lost",
        fdr < fdr_alpha & adj_pvalue < fdr_alpha ~ "Retained",
        fdr > fdr_alpha & adj_pvalue < fdr_alpha ~ "Gained",
        fdr > fdr_alpha & adj_pvalue > fdr_alpha ~ "Never Significant"
      ) %>% 
        factor(
          levels = c("Never Significant", "Retained", "Gained", "Lost")
        )
    ) %>% 
    as_tibble() %>% 
    summarise(n = dplyr::n(), .by = all_of(c("covariate", "ihw_status"))) %>% 
    complete(ihw_status = ihw_status, covariate = covariate, fill = list(n = 0)) %>% 
    pivot_wider(
      names_from = ihw_status, values_from = n, values_fill = 0
    ) %>% 
    mutate(`Nett Change` = Gained - Lost) %>% 
    bind_rows(
      summarise_if(., is.numeric, sum)
    ) %>% 
    mutate(
      covariate = covariate %>% 
        as.character() %>% 
        str_replace_na("Total"),
      Significant = Retained + Gained,
      Total = `Never Significant` + Significant + Lost
    ) %>% 
    dplyr::select(
      Covariate = covariate, Total, ends_with("Significant"), Retained, everything()
    ) %>% 
    pander(
      justify = "lrrrrrrr",
      caption = paste(
        "*Summary of changes introduced by IHW for windows considered as",
        paste0("showing differential ", target, " signal."),
        "This corresponds to a nett change of", 
        dplyr::slice(., nrow(.)) %>% 
          mutate(
            p = percent(`Nett Change` / (Significant - `Nett Change`), 0.1)
          ) %>% 
          .[["p"]],
        "from the initial list.*"
      ),
      emphasize.strong.rows = nrow(.)
    )
}
```

`r if (diff_sig_params$ihw != "none") "#### Distribution of P-values"`

```{r ihw-pvals, echo = diff_sig_params$ihw != "none", fig.cap = "*Histograms of p-values separated by whether each peak belong to an IHW group*"}
if (diff_sig_params$ihw != "none") {
  results %>% 
    select(PValue, ihw_covariate) %>% 
    mcols() %>% 
    as_tibble() %>% 
    ggplot(aes(PValue, after_stat(density))) +
    geom_histogram(aes(fill = ihw_covariate), colour = "black", bins = 100) +
    geom_text(
      aes(0.8, y, label = lab),
      data = . %>% 
        summarise(
          n = dplyr::n(), y = 90 * mean(PValue < 1/101),
          .by = ihw_covariate
        ) %>% 
        mutate(
          lab = glue("N = {comma(n, 1)}"), 
          y = max(y)
        )
    ) +
    facet_wrap(~ihw_covariate) +
    scale_fill_manual(values = full_palette) +
    scale_y_continuous(expand = expansion(c(0, 0.05))) +
    labs(x = "P Value", y = "Density", fill = diff_sig_params$ihw)
}
```

`r if (diff_sig_params$ihw != "none") "#### IHW Weights"`

```{r ihw-weights, echo = diff_sig_params$ihw != "none", fig.cap = "*Weights applied to each group of p-values to obtain FDR-adjusted, weighted p-values*"}
if (diff_sig_params$ihw != "none") {
  plot(ihw) +
    geom_hline(yintercept = 1, linetype = 2) +
    scale_y_continuous(expand = expansion(c(0, 0.05))) +
    scale_fill_brewer(palette = "Set2")
}
```

`r if (diff_sig_params$ihw != "none") "#### IHW Group Sizes"`

```{r ihw-group-sizes, echo = diff_sig_params$ihw != "none", fig.cap = "*Group sizes for each covariate. Groups were progressively collapsed until all groups contained > 1000 p-values*"}
if (diff_sig_params$ihw != "none") {
  results %>% 
    as_tibble() %>% 
    ggplot(aes(ihw_covariate, fill = ihw_covariate)) +
    geom_bar() +
    geom_hline(yintercept = 1e3, colour = "blue") +
    geom_text(
      aes(y = n + 0.025*max(n), label = comma(n, 1)),
      data = . %>% summarise(n = dplyr::n(), .by = ihw_covariate) 
    ) +
    scale_x_discrete(labels = label_wrap(25)) +
    scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
    scale_fill_manual(values = full_palette) +
    labs(x = str_to_title(diff_sig_params$ihw), y = "Total") +
    theme(legend.position = "none")
}
```



## Enrichment Testing 

```{r msigdb}
msigdb <- file.path(all_paths$annotation, "msigdb.rds") %>% read_rds()
gs_url <- msigdb$gs_url[!duplicated(names(msigdb$gs_url))]
enrich_method <- match.arg(enrich_params$method, c("great", "gene_id"))
adj_method <- match.arg(enrich_params$adj, p.adjust.methods)
net_layout <- c(network_params$layout, "fr")[[1]]
```

`r desc_enrichment(enrich_method)`

For all analyses below, the complete set of regions showing signal were used as the background ranges.
As such, if the majority of sites are showing change, there will be minimal opportunity for any pathways to emerge as enriched amongst the changed sites.
Likewise, when very few sites are changed, no enrichment is likely to be observed.

Three primary sets of genomic regions are tested for enrichment relative to background, with these being:

1. All sites showing any change
2. All sites showing increased signal
3. All sites showing decreased signal

All p-values will be adjusted using the `r adj_method` correction during testing.

### Any Changed Site {.tabset}

```{r enrich-changed}
enrich_args <- list(
  test_ranges = filter(results, !!sym(fdr_column) < enrich_params$alpha),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  changed_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  changed_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_changed_enrich <- sum(changed_enrich_df$adj_p < enrich_params$alpha)
tg_changed_enrich <- changed_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```

When testing for enrichment in the `r comma(sum(grepl("creased", results$status)))` sites (`r percent(mean(grepl("creased", results$status)), 0.1)`) showing evidence of any changed signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.

`r if (n_changed_enrich > 0) "#### Results Table"`

```{r tbl-changed-res, echo = n_changed_enrich > 0}
if (n_changed_enrich > 0) {
  tbl <- changed_enrich_df %>% 
    dplyr::filter(adj_p < enrich_params$alpha) %>%
    dplyr::slice(seq_len(100)) %>%
    dplyr::select(-any_of(c("gene_id"))) %>% 
    dplyr::select(
      gs_name, genes_with_hits, contains("gene"), everything()
    ) %>% 
    reactable(
      sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
      columns = enrich_cols[colnames(.)],
      details =  function(index){
        htmltools::div(
          htmltools::tags$pre(
            str_wrap(
              paste(capture.output(changed_enrich_df$genes_with_hits[index]), collapse = "\n"),
              width = 120
            )
          )
        )
      },
      elementId = "changed-enrich-res-table"
    )
  cp <- htmltools::em(
    glue(
      "
    Enrichment results for regions showing consistently changed signal for 
    {target}, regardless of direction, using an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
    )
  )
  tl <- tagList(
    tags$button(
      tagList(fontawesome::fa("download"), "Download as CSV"),
      onclick = glue(
        "Reactable.downloadDataCSV('changed-enrich-res-table',
      '{target}_changed_enrich_res.csv')"
      )
    ),
    tags$button(
      "Expand/Collapse All",
      onclick = "Reactable.toggleAllRowsExpanded('changed-enrich-res-table')"
    ),
    tags$button(
      "Clear All Filters",
      onclick = "Reactable.setAllFilters('changed-enrich-res-table', [])"
    ),
    tbl,
    cp
  )
  if (interactive()) {
    htmltools::browsable(tl)
  } else {
    tl
  }
}
```

`r if (n_changed_enrich > min(network_params$size)) "#### Network Plot"`

```{r changed-network, echo = n_changed_enrich > min(network_params$size), fig.cap = glue("*The {n_changed_enrich} most highly ranked gene sets from enrichment analysis using all sites showing changed signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
if (n_changed_enrich > min(network_params$size)) {
  tg_changed_enrich %>% 
    ggraph(layout = net_layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, bg.color = "white", bg.r = 0.1, 
      max.overlaps = max(10, round(length(tg_changed_enrich) / 4, 0)),
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```


### Any Increased Site {.tabset}

```{r enrich-increased}
enrich_args <- list(
  test_ranges = filter(results, status == "Increased"),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  increased_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  increased_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_increased_enrich <- sum(increased_enrich_df$adj_p < enrich_params$alpha)
tg_increased_enrich <- increased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```

When testing for enrichment in the `r comma(sum(grepl("Increased", results$status)))` sites (`r percent(mean(grepl("Increased", results$status)), 0.1)`) showing evidence of any *decreased* signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.


`r if (n_increased_enrich > 0) "#### Results Table"`

```{r tbl-increased-res, echo = n_increased_enrich > 0}
if (n_increased_enrich > 0) {
  tbl <- increased_enrich_df %>% 
    dplyr::filter(adj_p < enrich_params$alpha) %>%
    dplyr::slice(seq_len(100)) %>%
    dplyr::select(-any_of(c("gene_id"))) %>% 
    dplyr::select(
      gs_name, genes_with_hits, contains("gene"), everything()
    ) %>% 
    reactable(
      sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
      columns = enrich_cols[colnames(.)],
      details =  function(index){
        htmltools::div(
          htmltools::tags$pre(
            str_wrap(
              paste(
                capture.output(increased_enrich_df$genes_with_hits[index]),
                collapse = "\n"
              ),
              width = 120
            )
          )
        )
      },
      elementId = "increased-enrich-res-table"
    )
  cp <- htmltools::em(
    glue(
      "
    Enrichment results for regions showing consistently increased signal for 
    {target}, using direction of change along with an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
    )
  )
  tl <- tagList(
    tags$button(
      tagList(fontawesome::fa("download"), "Download as CSV"),
      onclick = glue(
        "Reactable.downloadDataCSV('increased-enrich-res-table',
      '{target}_increased_enrich_res.csv')"
      )
    ),
    tags$button(
      "Expand/Collapse All",
      onclick = "Reactable.toggleAllRowsExpanded('increased-enrich-res-table')"
    ),
    tags$button(
      "Clear All Filters",
      onclick = "Reactable.setAllFilters('increased-enrich-res-table', [])"
    ),
    tbl,
    cp
  )
  if (interactive()) {
    htmltools::browsable(tl)
  } else {
    tl
  }
}
```

`r if (n_increased_enrich > min(network_params$size)) "#### Network Plot"`

```{r increased-network, echo = n_increased_enrich > min(network_params$size), fig.cap = glue("*The {n_increased_enrich} most highly ranked gene sets from enrichment analysis using only the sites showing consistently increasing signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
if (n_increased_enrich > min(network_params$size)) {
  tg_increased_enrich %>% 
    ggraph(layout = net_layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, max.overlaps = max(10, round(length(tg_increased_enrich) / 4, 0)),
      bg.color = "white", bg.r = 0.1, 
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```

### Any Decreased Site {.tabset}

```{r enrich-decreased}
enrich_args <- list(
  test_ranges = filter(results, status == "Decreased"),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  decreased_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  decreased_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_decreased_enrich <- sum(decreased_enrich_df$adj_p < enrich_params$alpha)
tg_decreased_enrich <- decreased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```


When testing for enrichment in the `r comma(sum(grepl("Decreased", results$status)))` sites (`r percent(mean(grepl("Decreased", results$status)), 0.1)`) showing evidence of any *decreased* signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.



`r if (n_decreased_enrich > 0) "#### Results Table"`

```{r tbl-decreased-res, echo = n_decreased_enrich > 0}
if (n_decreased_enrich > 0) {
  tbl <- decreased_enrich_df %>% 
    dplyr::filter(adj_p < enrich_params$alpha) %>%
    dplyr::slice(seq_len(100)) %>%
    dplyr::select(-any_of(c("gene_id"))) %>% 
    dplyr::select(
      gs_name, genes_with_hits, contains("gene"), everything()
    ) %>% 
    reactable(
      sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
      columns = enrich_cols[colnames(.)],
      details =  function(index){
        htmltools::div(
          htmltools::tags$pre(
            str_wrap(
              paste(
                capture.output(decreased_enrich_df$genes_with_hits[index]), 
                collapse = "\n"
              ),
              width = 120
            )
          )
        )
      },
      elementId = "decreased-enrich-res-table"
    )
  cp <- htmltools::em(
    glue(
      "
    Enrichment results for regions showing consistently decreased signal for 
    {target}, using direction of change along with an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
    )
  )
  tl <- tagList(
    tags$button(
      tagList(fontawesome::fa("download"), "Download as CSV"),
      onclick = glue(
        "Reactable.downloadDataCSV('decreased-enrich-res-table',
      '{target}_decreased_enrich_res.csv')"
      )
    ),
    tags$button(
      "Expand/Collapse All",
      onclick = "Reactable.toggleAllRowsExpanded('decreased-enrich-res-table')"
    ),
    tags$button(
      "Clear All Filters",
      onclick = "Reactable.setAllFilters('decreased-enrich-res-table', [])"
    ),
    tbl,
    cp
  )
  if (interactive()) {
    htmltools::browsable(tl)
  } else {
    tl
  }
}
```

`r if (n_decreased_enrich > min(network_params$size)) "#### Network Plot"`

```{r decreased-network, echo = n_decreased_enrich > min(network_params$size), fig.cap = glue("*The {n_decreased_enrich} most highly ranked gene sets from enrichment analysis using the sites showing constent decrease in signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
if (n_decreased_enrich > min(network_params$size)) {
  tg_decreased_enrich %>% 
    ggraph(layout = net_layout, weights = oc) +
    geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
    geom_node_point(
      aes(
        fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
      ),
      shape = 21
    ) +
    geom_node_text(
      aes(label = label, alpha = prop),
      colour = "black", size = 3, 
      data = . %>%
        mutate(
          label = str_replace_all(label, "_", " ") %>% 
            str_trunc(60) %>% 
            str_wrap(width = 18)
        ),
      repel = TRUE, max.overlaps = max(10, round(length(tg_decreased_enrich) / 4, 0)),
      bg.color = "white", bg.r = 0.1, 
    ) +
    scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
    scale_fill_viridis_c(option = "inferno", begin = 0.2) +
    scale_alpha(range = c(0.5, 1), trans = "sqrt") +
    scale_size_continuous(range = c(1, 10)) +
    scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
    scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
    guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
    labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
    theme_void() 
}
```



# CHECK RNASEQ MODULE

```{r add-rna, eval = FALSE, child = here::here('workflow/modules/rnaseq_differential.Rmd')}
```


## Data Export


```{r define-outputs}
out_path <- file.path(all_paths$diff_signal, target)
all_out <- list(
  csv = file.path(out_path, glue("{comp}-differential_signal.csv.gz")),
  # de_genes = file.path(out_path, glue("{comp}-DE_genes.csv")),
  changed = file.path(out_path, glue("{comp}-changed-enrichment.csv")),
  decreased = file.path(out_path, glue("{comp}-decreased-enrichment.csv")),
  increased = file.path(out_path, glue("{comp}-increased-enrichment.csv")),
  # rna_enrichment = file.path(out_path, glue("{comp}-rnaseq_enrichment.csv")),
  renv = here::here("output/envs", glue("{comp}-differential_signal.RData"))
)
```

```{r data-export, results='hide'}
results %>% 
  as_tibble() %>% 
  dplyr::select(
    starts_with("gene"), range, starts_with("log"), PValue, 
    FDR = !!sym(fdr_column), status, any_of(c("region", "feature"))
  ) %>%
  unnest(all_of("gene_id")) %>%
  mutate(
    gene_name = id2gene[gene_id],
    distance_to_gene = distance(
      GRanges(range),
      setNames(gtf_gene, gtf_gene$gene_id)[gene_id]
    )
  ) %>% 
  write_csv(all_out$csv)
## Enrichment results need a bit of tweaking to match the tables
changed_enrich_df %>% 
  dplyr::select(-gene_id) %>% 
  write_csv(all_out$changed)
increased_enrich_df %>% 
  dplyr::select(-gene_id) %>% 
  write_csv(all_out$increased)
decreased_enrich_df %>% 
  dplyr::select(-gene_id) %>% 
  write_csv(all_out$increased)
## Save key memory on the HDD
gc()
save.image(all_out$renv)
```

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, "output.+"))`

## References

<div id="refs"></div>
<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">

```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```

</div>
