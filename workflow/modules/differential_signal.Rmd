
```{r set-knitr-opts, echo=FALSE, child = here::here('analysis/setup_chunk.Rmd')}
```


```{r set-params, eval = interactive(), echo = FALSE}
# params <- list(
#   target = "AR", 
#   treat_levels = c("E2", "E2DHT")
# )
```

```{r packages}
library(tidyverse)
library(glue)
library(pander)
library(extraChIPs)
library(yaml)
library(GenomicInteractions)
library(quantro)
library(qsmooth)
library(edgeR)
library(patchwork)
library(plyranges)
library(reactable)
library(scales)
library(htmltools)
library(rtracklayer)
library(ggrepel)
library(rlang)
library(parallel)
library(goseq)
library(magrittr)
library(msigdbr)
library(tidygraph)
library(ggraph)
library(doParallel)
library(BiocParallel)
# library(GenomeInfoDb)
# library(Rsamtools)
# library(ngsReports)
# library(statmod)
# library(metap)
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
threads <- parallel::detectCores() - 1
register(MulticoreParam(workers = threads))
source(here::here("workflow", "scripts", "custom_functions.R"))
source(here::here("workflow", "scripts", "table_funs.R"))
source(here::here("workflow", "scripts", "enrichment_funs.R"))
config <- read_yaml(here::here("config", "config.yml"))
all_paths <- here::here("config", "json", "all_paths.json") %>% 
    jsonlite::fromJSON() %>% 
    lapply(here::here)
ucsc <- get_ucsc(config$genome$build)
```

```{r set_params, echo = FALSE, eval=TRUE}
target <- params$target
treat_levels <- params$treat_levels
win_type <- match.arg(params$window_type, c("fixed", "sliding"))
method <- match.arg(params$method, c("qlf", "lt"))
norm <- match.arg(
  params$norm, c("none", "TMM", "RLE", "TMMwsp", "upperquartile", "sq")
)
check_norm <- norm != "none"
pair_col <- params$pair_column ## This may need revision of earlier modules
paired_samples <- !is.null(pair_col)
ihw_method <- match.arg(
  params$ihw, c("regions", "features", "targets", "none")
)
if (norm == "sq") {
  if (win_type == "fixed") stop(
    "Smooth Quantile normalisation not permitted on fixed-width windows."
  )
  if (method == "qlf")  stop(
    "Smooth Quantile normalisation is only enabled for limma-trend."
  )
}
mapping_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("mapping")
all_heat_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("profile_heatmaps") 
heat_params <- all_heat_params$default
if (target %in% names(all_heat_params)) {
  nm <- names(all_heat_params[[target]])
  heat_params[nm] <- all_heat_params[[target]][nm]
}
enrich_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("enrichment")
msigdb_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("msigdb")
network_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("networks")
region_params <- here::here("config", "params.yml") %>% 
  read_yaml() %>% 
  pluck("gene_regions")
```


```{r load-data}
samples <- file.path(all_paths$macs2, target, glue("{target}_qc_samples.tsv")) %>% 
  read_tsv() %>% 
  dplyr::filter(treat %in% treat_levels, qc == "pass") %>% 
  mutate(treat = factor(treat, levels = treat_levels)) %>% 
  droplevels()
stopifnot(length(levels(samples$treat)) == 2)
counts <- here::here(params$counts) %>% 
  read_rds() %>% 
  .[,samples$sample]
assay_name <- c(qlf = "counts", lt = "logCPM")[method]
n_max <- min(5e5, nrow(counts))
```


```{r load-annotations}
sq <- file.path(all_paths$annotation, "seqinfo.rds") %>% read_rds()
blacklist <- here::here(all_paths$annotation, "blacklist.rds") %>% 
  read_rds()
greylist <- GRanges(seqinfo = sq)
if (length(unique(samples$input))) {
  greylist <- file.path(all_paths$greylist, "{samples$input}_greylist.bed.gz") %>% 
    glue() %>% 
    unique() %>% 
    importPeaks(type = "bed", seqinfo = sq) %>% 
    unlist() %>% 
    reduce()
}
exclude_gr <- c(blacklist, greylist)
gtf_gene <- file.path(all_paths$annotation, "gtf_gene.rds") %>% read_rds()
id2gene <- structure(gtf_gene$gene_name, names = gtf_gene$gene_id)

colours <- read_rds(file.path(all_paths$annotation, "colours.rds")) %>% 
  lapply(unlist)

external_features <- here::here(all_paths$annotation, "features.rds") %>% 
  read_rds()
has_features <- length(external_features) > 0
if (has_features)
  feature_colours <- setNames(
    colours$features, str_sep_to_title(names(colours$features))
  )

hic <- file.path(all_paths$annotation, "hic.rds") %>% read_rds()
has_hic <- length(hic) > 0

gene_regions <- file.path(all_paths$annotation, "gene_regions.rds") %>% 
  read_rds()
regions <- map_chr(gene_regions, \(x) unique(x$region))
region_colours <- setNames(colours$regions, regions[names(colours$regions)])

direction_colours <- colours$direction %>% 
  setNames(str_to_title(names(.))) %>% 
  .[names(.) %in% c("Increased", "Decreased", "Unchanged", "Ambiguous")]
treat_colours <- colours$treat[treat_levels]

fig_params <- here::here("config", "rmarkdown.yml") %>% 
  read_yaml() %>% 
  pluck("knitr_opts")
fw <- fig_params$fig.width
fh <- fig_params$fig.height
fig_type <- fig_params$dev[[1]]
if (is.null(fig_type)) stop("Couldn't detect figure type")
fig_fun <- match.fun(fig_type)
if (fig_type %in% c("bmp", "jpeg", "png", "tiff")) {
  ## These figure types require dpi & resetting to be inches
  formals(fig_fun)$units <- "in"
  formals(fig_fun)$res <- 300
}

has_rnaseq <- FALSE ## To be added in again later
```



```{r define-outputs}
out_path <- file.path(all_paths$diff_signal, target)
comp <- glue("{target}_{treat_levels[[1]]}_{treat_levels[[2]]}")
all_out <- list(
  results = file.path(out_path, glue("{comp}-differential_signal.rds")),
  csv = file.path(out_path, glue("{comp}-differential_signal.csv.gz")),
  up_regions = file.path(out_path, glue("{comp}-increased.bed")),
  down_regions = file.path(out_path, glue("{comp}-decreased.bed")),
  # de_genes = file.path(out_path, glue("{comp}-DE_genes.csv")),
  enrichment = file.path(out_path, glue("{comp}-enrichment.csv")),
  # rna_enrichment = file.path(out_path, glue("{comp}-rnaseq_enrichment.csv")),
  renv = here::here("output/envs", glue("{comp}-differential_signal.RData"))
)
## Initialise outputs from RNA-Seq
# cmn_diff <- cmn_up <- cmn_down <- tibble(leadingEdge = list())
fig_path <- here::here("docs", "assets", comp)
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE)
```

```{r method-descriptions, echo = FALSE}
norm_ref <- case_when(
  norm == "sq" ~ "normalised using Smooth-Quantile normalisation [@HicksSQN2017]",
  norm %in% c("TMM", "TMMwsp") ~ paste("with", norm, "normalisation [@Robinson2010-qp]", collapse = " "),
  norm == "RLE" ~ "with RLE normalisation [@Anders2010-sd].",
  norm == "upperquartile" ~ "with upperquartile normalisation",
  TRUE ~ "with library-size normalisation"
)
desc_windows <- c(
  sliding = glue(
    "During counting, sliding windows of {params$window_size}bp were used with a step-size
    defined to ensure each position is covered by at least 3 windows (e.g. 
    {ceiling(params$window_size/3)}bp). After performing the analysis on the set of 
    sliding windows, final results will be obtained by merging nearby windows 
    using the harmonic-mean p-value [@Wilson2019-ln]. Any windows within 
    {floor(1 + params$window_size * 2 / 3)}bp of each other are considered as 'nearby' 
    windows suitable for merging."
  ),
  fixed = glue(
    "During counting all ranges were set to be {params$window_size}bp and centred based on
    the estimated peaks centres determined by macs2. For downstream reporting of 
    results, the original range called as a 'peak' by macs2 is reported rather 
    than the centred range.
    "
  )
)[[win_type]] %>% 
  str_replace_all("\\n", " ") %>% 
  str_replace_all(" +", " ")
desc_method <- c(
  qlf = glue(
    "Quasi-Likelihood Generalised Linear Models [@LunSmythGLMQL2017] on counts {norm_ref}."
  ),
  lt = glue("Limma-Trend [@LawVoom2014] on logCPM values {norm_ref}.")
)[method]
desc_ihw <- list(
  regions = "the previously annotated genomic regions",
  features = "the provided external features",
  targets = "the presence/absence of any other ChIP targets under consideration in any condition",
  none = c()
)[[ihw_method]]
desc_treat <- ifelse(
  params$fc == 1,
  "The Null Hypothesis (H~0~) is the conventional H~0~ testing for zero against non-zero (i.e. H~A~) change",
  glue(
    "The Null Hypothesis (H~0~) is a range-based hypothesis testing for log fold-change beyond the range &#177;{round(log2(params$fc), 3)}"
  )
)
```


## Outline

This step of the GRAVI workflow uses a `r win_type` window approach to differential signal with windows of `r params$window_size`bp.
Counts for all windows were prepared across all `r target` samples as a stand-alone process, with the only samples retained in this analysis being those with counts from `r collapseGenes(treat_levels, last = " or ", format = "")`.
This process has produced counts for `r comma(nrow(counts))` ranges.

`r desc_windows`

Differential signal analysis will be performed using `r unname(desc_method)`.
`r desc_treat`
Ranges with an FDR < `r params$alpha` will be considered as significant.
`r if (paired_samples) "Samples were denoted as being paired"`

`r glue("Independent Hypothesis Weighting (IHW) [@IgnatiadisIHW2016] is additionally used to improve the power of the results. Under this strategy, p-values are partitioned based on {desc_ihw}, which is considered here to be a statistically independent variable.")`

The workflow depends heavily on the functions implemented in the Bioconductor package [extraChIPs](https://bioconductor.org/packages/release/bioc/html/extraChIPs.html)

<!-- ### Enrichment Analysis -->

<!-- Beyond the simple analysis of differential signal, peaks are mapped to genes and enrichment testing is performed on the following: -->

<!-- 1. Genes mapped to any range with detected `r target` are compared to all genes not mapped to any range -->
<!-- 2. Genes mapped to *all ranges with differential signal* are compared to genes mapped to ranges with no difference in signal -->
<!-- 3. Genes mapped to ranges with *increasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->
<!-- 4. Genes mapped to ranges with *decreasing* `r target` signal are compared to genes mapped to ranges with no difference in signal -->

<!-- Enrichment testing is performed using `goseq` [@YoungGoseq2010] with no term accounting for sampling bias (i.e. the Hypergeometric Distribution), *except when comparing genes mapped to any window.* -->
<!-- For this case **only**, gene width is used to capture any sampling bias and Wallenius' Non-Central Hypergeometric Distribution is used. -->
<!-- As RNA-seq data `r ifelse(has_rnaseq, "was", "was not")` provided, the genes considered for enrichment analysis are the `r comma(length(unique(gtf_gene$gene_id)))` `r ifelse(has_rnaseq, "genes considered as detected in the RNA-Seq data", "annotated genes")`. -->

<!-- `r if (has_rnaseq) "### Incorporation with RNA-Seq"` -->

<!-- `r if (has_rnaseq) "Any association between differentially expressed genes and differential signal regions will be assessed using Gene Set Enrichment Analysis [@SubramanianGsea2005], as implemented in the fgsea package [@KorotkevichFgsea2019]. The sets of genes associated with changed signal will be subset by regions and any provided external features, and these novel gene-sets will be used to test for enrichment within the RNA-Seq results. ChIP-seq derived gene-sets will be tested for differential expression using genes ranked directionally and by significance alone. A combined meta-analytic approach using Wilkinson's method will also be used to integration of results from enrichment testing in each standalone dataset."` -->

## Differential Signal Analysis

`r if (check_norm) "### Normalisation Checks"`

```{r qtest, eval = check_norm}
registerDoParallel(threads)
qtest <- quantro(assay(counts, "counts"), counts$treat, B = 1e3)
quantro_p <- c(
  perm = quantroPvalPerm(qtest),
  anova = anova(qtest)[["Pr(>F)"]][[1]]
)
if (any(quantro_p < 0.05) & norm != "sq") norm <- "none" 
```

```{r desc-quantro, echo = FALSE, eval = check_norm}
desc_quantro <- paste(
  "Prior to performing analysis, un-normalised logCPM values were tested for",
  "equality of distribution using the `quantro` test [@HicksQuantro2015].",
  "Results testing for equality of distribution gave a p-value of",
  paste0(round(quantro_p[["perm"]], 3), ","), 
  "and tests for an equality of medians between group returned a p-value of",
  paste0(round(quantro_p[["anova"]], 3), ".")
) %>% 
  c(
    case_when(
      any(quantro_p < 0.05) & norm == "sq" ~ "These results indicate that the data across treatments is drawn from different distributions and SQ-normalisation may improve the results",
      any(quantro_p < 0.05) & norm != "none" ~ paste(
        "These results indicate that the data across treatments is drawn from different distributions and **", norm, "normalisation will be inappropriate**. *The normalisation method has been reset to library-size.*", collapse = ""
      ),
      TRUE ~ paste(
        "All results from the quantro test support the choice of", 
        ifelse(norm == "none", "library-size", norm), 
        "normalisation.", collapse = " "
      )
    )
  )
```


`r desc_quantro`


```{r normalise-logcpm}
if (norm == "sq") {
  assay_name <- "qsmooth"
  qs <- qsmooth(assay(counts, "logCPM"), group_factor = counts$treat)
  assay(counts, assay_name) <- qsmoothData(qs)
} else {
  ## Make sure the normalisation is included for CPM values
  ## as well as the complete library sizes
  dge <- calcNormFactors(counts, method = norm)
  dge$samples$lib.size <- counts$totals
  lcpm <- cpm(dge, log = TRUE) 
  rownames(lcpm) <- NULL
  assay(counts, "logCPM") <- lcpm
}
```

`r if (norm != "sq") "For easier visualisation, the normalised assay *logCPM* was added to the counts object"`
`r if (norm == "sq") glue("The assay {assay_name} was then added to the counts object")`

### Data Inspection {.tabset}

`r if (norm == "sq") "#### QSmooth Weights"` 

```{r plot-sq-weights, eval = norm == "sq", echo = norm == "sq", fig.height = 6, fig.cap = "*Quantile-specific weights used by the Smooth-Quantile normalisation. Low weights indicate signal quantiles which appear to be more specific within a group, whilst higher weights indicate similarity between groups.*"}
qsmoothPlotWeights(
  qs, xLab = "Quantiles", yLab = "Weights", mainLab = "QSmooth Weights"
)
```


#### Densities

```{r plot-densities, fig.height = 6, fig.cap = "*Distributions of counts for each sample within each treatment group shown (A) before normalisation and (B) after normalisation..*"}
assays <- c("counts", "logCPM")
trans <- "log1p"
xlab <- "Normalised logCPM"
if (norm == "sq") {
  assays <- c("logCPM", "qsmooth")
  trans <- NULL
  xlab <- "SQ-Normalised logCPM"
}
a <- counts %>%
  plotAssayDensities(assays[[1]], colour = "treat", n_max = n_max, trans = trans) +
  scale_colour_manual(values = treat_colours) +
  labs(colour = "Treat")
b <- counts %>% 
  plotAssayDensities(assays[[2]], colour = "treat", n_max = n_max) +
  scale_colour_manual(values = treat_colours) +
  labs(x = xlab, colour = "Treat")
a + b + 
  plot_layout(guides = "collect", axis_titles = "collect") +
  plot_annotation(tag_levels = "A")
```

#### RLE


```{r plot-rle, dev = 'png', fig.height=6, fig.cap = glue("*RLE plot showing two perspectives on the data. (A) shows all samples with median values taken across all samples. If any differences are evident between treatment groups, library-size or smooth-quantile normalisation may be the best approaches for normalisation. (B) shows all samples taking median values within treatment groups and potentially highlights any problematic samples within each groups.*")}
rle_assay <- ifelse(norm == "sq", "qsmooth", "logCPM")
a <- counts %>% 
  plotAssayRle(
    rle_assay, fill = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  scale_fill_manual(values = treat_colours) +
  ggtitle(glue("RLE: No Grouping")) +
  labs(x = "Sample", fill = "Treat") 
b <- counts %>% 
  plotAssayRle(
    rle_assay, fill = "treat", rle_group = "treat", n_max = n_max, by_x = "label"
  ) +
  geom_hline(yintercept = 0) + 
  facet_grid(.~treat, scales = "free_x", space = "free_x") +
  ggtitle(glue("RLE: Grouping by Treat")) +
  scale_fill_manual(values = treat_colours) +
  labs(x = "Sample", fill = "Treat")
a + b + 
  plot_layout(guides = "collect", axis_titles = "collect") + 
  plot_annotation(tag_levels = "A")
```


#### PCA

```{r plot-qsmooth-pca, fig.width = ifelse(norm == "sq", fw, fh), fig.cap = "*PCA showing the amount of variance attributed to each component*"}
a <- plotAssayPCA(
  counts, "logCPM", colour = "treat", label = "label", 
  show_points = FALSE
) +
  scale_colour_manual(values = treat_colours) +
  guides(colour = "none") +
  ggtitle("PCA using logCPM values")
b <- NULL
if (norm == "sq") {
  b <- plotAssayPCA(
    counts, "qsmooth", colour = "treat", label = "label",
    show_points = FALSE
  ) +
    scale_colour_manual(values = treat_colours) +
    guides(colour = "none") +
    ggtitle("PCA after SQ Normalisation")
  a <- a + b + 
    plot_layout(guides = "collect") + plot_annotation(tag_levels = "A")
}
a
```



### Model Fitting

```{r fit}
fm <- as.formula(
  ifelse(is.null(pair_col), "~treat", paste("~", pair_col, "+treat"))
)
X <- model.matrix(fm, data = colData(counts)) 
colnames(X) <- str_remove_all(colnames(X), "treat")
colData(counts)$design <- X
paired_cors <- block <- txt <- NULL
if (!is.null(pair_col) & method == "lt") {
  ## These will be passed to fitAssayDiff. This in turn passes these to
  ## lmFit, although when method is qlf they will be passed to glmQLFit.
  ## As they are not parameters for that modelling approach, they will be 
  ## ignored
  block <- colData(counts)[[pair_col]]
  set.seed(1e6)
  ind <- sample.int(nrow(counts), n_max, replace = FALSE)
  paired_cors <- duplicateCorrelation(
    object = assay(counts, assay_name)[ind, ],
    design = X,
    block = block
  )$consensus.correlation # This will be ignored in '...' if block = NULL
  txt <- glue(
    "During model fitting, data were nested within {{pair_col}} as a potential source of correlation. ",
    "The estimated correlation within replicate samples was $\\hat{\\rho} = {{round(paired_cors, 3)}}$",
    .open = "{{", .close = "}}"
  )
}
fit <- fitAssayDiff(
  counts, assay = assay_name, design = X, coef = treat_levels[[2]],
  method = method, norm = ifelse(norm == "sq", "none", norm), 
  fc = params$fc, block = block, correlation = paired_cors
) 
pcols <- c("PValue", "p_mu0")
if (win_type == "sliding") {
  results <- mergeByHMP(
    fit, pval = pcols, merge_within = floor(1 + 2 * params$window_size / 3),
    hm_pre = ""
  ) %>%
    plyranges::select(
      starts_with("n_"), keyval_range, starts_with("log"), any_of(pcols),
      FDR = PValue_fdr
    ) %>% 
    addDiffStatus(alpha = params$alpha)
  ## Map genes, features & regions, which are otherwise propagated through
  results$region <- bestOverlap(results, unlist(gene_regions), var = "region") 
  results$region <- factor(results$region, levels = names(region_colours))
  if (has_features) results$feature <- bestOverlap(
    results, external_features, missing = "no_feature"
  )
  which_prom <- grepl("prom", str_to_lower(names(external_features)))
  feat_prom <- external_features[which_prom] %>%
    unlist() %>%
    GenomicRanges::reduce()
  which_enh <- grepl("enhanc", str_to_lower(names(external_features)))
  feat_enh <- external_features[which_enh] %>%
    unlist() %>%
    GenomicRanges::reduce()
  prom <- GenomicRanges::reduce(c(feat_prom, granges(gene_regions$promoter)))
  results <- mapByFeature(
    results, gtf_gene,
    prom = prom,
    enh = feat_enh,
    gi = hic,
    gr2gene = mapping_params$gr2gene,
    prom2gene = mapping_params$prom2gene,
    enh2gene = mapping_params$enh2gene,
    gi2gene = mapping_params$gi2gene
  )
} else {
  results <- rowRanges(fit) %>% addDiffStatus(alpha = params$alpha)
}
fdr_column <- "FDR"
n_sig <- sum(results$FDR < params$alpha)
```

`r txt`

### Independent Hypothesis Weighting {.tabset}

`r ifelse(ihw_method == "none", "No independent Hypothesis Weighting was specified", "")`

```{r ihw, eval = ihw_method != "none", echo = TRUE, child = here::here(glue("workflow/modules/ihw.Rmd"))}
```


<!-- ### Mapping Windows To Genes -->

<!-- In addition to statistical analysis, all ranges were first mapped to the gene-centric region with the largest overlap. -->
<!-- `r ifelse(has_features, "Ranges were then mapped to the external features provided in the same manner", "")`, followed by mapping to all annotated genes. -->

<!-- During mapping to genes, promoters were defined as the union of all potential promoter regions defined earlier, and any external features which were detected as promoters using string matching in the `feature` column. -->
<!-- `r ifelse(has_features, glue("Enhancers were any regions defined in {basename(config$external$features)} as enhancers."), glue(""))` -->
<!-- `r ifelse(length(hic) > 0, glue("A set of {comma(length(hic))} HiC-interactions was also included to enable the use of long-range interactions during the mappig process."), "")` -->

<!-- These features were used to map ranges to features using the process defined in the function `extraChIPs::mapByFeature()`: -->

<!-- 1. Ranges *overlapping a promoter* are assigned to genes `r ifelse(mapping_params$prom2gene == 0, "directly overlapping", paste("within", mapping_params$prom2gene, "bp of"))` that specific promoter -->
<!-- 2. Ranges *overlapping an enhancer* are assigned to all genes `r ifelse(mapping_params$enh2gene == 0, "directly overlapping", paste("within", round(mapping_params$enh2gene/1e3, 1), "kb of"))` the enhancer -->
<!-- 3. Ranges *overlapping a long-range interaction* are assigned to all genes `r ifelse(mapping_params$gi2gene == 0, "directly overlapping", paste("within", round(mapping_params$gi2gene/1e3, 1), "kb of"))` either end of the interaction -->
<!-- 4. Ranges with *no gene assignment from the previous steps* are assigned to all overlapping genes, or the nearest gene within `r round(mapping_params$gr2gene/1e3, 1)`kb -->

<!-- Notably, genes are only passed to step 4 if no gene assignment has been made in steps 1, 2 or 3. -->
<!-- For visualisation purposes, only genes which were considered as detected in any provided RNA-Seq data will be shown as the mapping targets. -->

## Results 

### Result Tables {.tabset}

```{r tbl-setup}
n_unch <- sum(results$status == "Unchanged")
n_windows <- length(results)
type <- ifelse(win_type == "fixed", "Peaks", "Windows")
tbl_cols <- list(
  Region = colDef(
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  feature = colDef(
    "Feature", cell = \(value) str_sep_to_title(value),
    footer = htmltools::tags$b("Total"), minWidth = 200
  ),
  Increased = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- up_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Decreasd = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- down_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Ambiguous = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / (n_windows - n_unch)
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  Unchanged = colDef(
    format = comma_col,
    style = \(value) {
      normalized <- value / n_windows
      color <- unch_col(normalized)
      list(background = color)
    },
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Changed` = colDef(
    format = percent_col,
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    align = "right",
    footer = htmltools::tags$b(
      percent(sum(1 - n_unch / n_windows), 0.1)
    )
  ),
  Total = colDef(
    format = comma_col,
    style = \(value) {
      bar_style(width = value / n_windows, fill = "#B3B3B3", align = "right")
    },
    align = "right",
    footer = \(values) htmltools::tags$b(comma(sum(values)))
  ),
  `% Of All Windows` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  ),
  `% Of All Peaks` = colDef(
    style = \(value) bar_style(width = value, fill = "#B3B3B3", align = "right"),
    format = percent_col
  )
)
```


#### Overall Results

```{r tab-overall}
tbl <- results %>% 
  mutate(w = width) %>% 
  as_tibble() %>% 
  summarise(
    n = dplyr::n(), 
    width = median(w),
    logCPM = median(logCPM),
    .by = all_of("status")
  ) %>% 
  mutate(`%` = n / sum(n)) %>% 
  dplyr::select(status, n, `%`, everything()) %>% 
  reactable(
    searchable = FALSE, filterable = FALSE,
    columns = list(
      status = colDef(
        name = "Status", maxWidth = 150,
        footer = htmltools::tags$b("Overall")
      ),
      n = colDef(
        name = glue("Nbr of {type}"), maxWidth = 150, format = colFormat(separators = TRUE),
        footer = htmltools::tags$b(comma(length(results)))
      ),
      width = colDef(
        name = "Median Width (bp)", format = colFormat(digits = 1),
        footer = htmltools::tags$b(round(median(width(results)), 1)),
        maxWidth = 200
      ),
      `%` = colDef(
        name = glue("% Total {type}"), format = colFormat(percent = TRUE, digits = 1),
        style = \(value) bar_style(width = value, align = "right"),
        maxWidth = 150
      ),
      logCPM = colDef(
        name = "Median Signal (logCPM)",
        format = colFormat(digits = 3),
        maxWidth = 200,
        footer = htmltools::tags$b(
          round(median(results$logCPM), 3)
        )
      )
    )
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison."
  )
)
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


#### Summary By Region

```{r tab-res-by-region}
df <- results %>% 
  select(status, !!sym(fdr_column), region) %>% 
  as_tibble() %>% 
  group_by(region, status) %>% 
  summarise(n = dplyr::n(), .groups = "drop") %>% 
  complete(region, status, fill = list(n = 0)) %>% 
  group_by(region) %>% 
  mutate(Total = sum(n)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    "% Of All {type}" := Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(region) %>% 
  dplyr::select(
    Region = region,
    any_of(names(direction_colours)),
    `% Changed`, Total, starts_with("% Of All")
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which genomic region contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = \(values) htmltools::tags$b(comma(sum(values)))
    ),
    fullWidth = TRUE, elementId = 'tbl-results-by-region'
  )
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r ifelse(has_features, "#### Summary By Feature", "")`

```{r tab-res-by-feature, echo = has_features, eval = has_features}
df <- results %>% 
  select(status, !!sym(fdr_column), feature) %>% 
  as_tibble() %>% 
  group_by(feature, status) %>% 
  tally() %>% 
  ungroup() %>% 
  complete(feature, status, fill = list(n = 0)) %>% 
  mutate(Total = sum(n), .by = all_of("feature")) %>% 
  pivot_wider(names_from = "status", values_from = "n") %>% 
  dplyr::filter(Total > 0) %>% 
  mutate(
    "% Of All {type}" := Total / length(results),
    `% Changed` = 1 - Unchanged / Total
  ) %>% 
  arrange(feature) %>% 
  dplyr::select(
    feature, any_of(names(direction_colours)),
    `% Changed`, Total, starts_with("% Of All")
  )
cp <- htmltools::em(
  glue(
    "Overall results for changed {target} signal in the ",
    glue_collapse(rev(treat_levels), last = " Vs. "),
    " comparison, broken down by which external feature contains the largest ", 
    "overlap with each range in the set of results."
  )
)
tbl <- df %>%
  reactable(
    columns = tbl_cols[colnames(df)],
    defaultColDef = colDef(
      footer = \(values) htmltools::tags$b(comma(sum(values)))
    ),
    elementId = 'tbl-results-by-feature'
  )
tl <- tagList(tbl, cp)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```


#### Most Highly Ranked

```{r tab-highly-ranked}
show_n <- min(200, length(results))
scaling_vals <- list(
  logFC = c(-1, 1)*max(abs(results$logFC)),
  logCPM = range(results$logCPM),
  Width = max(width(results))
)
cp <- htmltools::em(
  glue(
    "The {show_n} most highly-ranked ranges by FDR, with {comma(n_sig)} ", 
    "in total showing evidence of changed {target} signal. ",
    "Regions were assigned based on which genomic region showed the largest ",
    "overlap with the range being analysed. ",
    ifelse(
      has_features, 
      glue(
        glue("Features are as provided in "), 
        glue_collapse(config$external$features, sep = ", ", last = " and ")
      ),
      glue("")
    ),
    "For ranges mapped to large numbers of genes, hovering a mouse over the ", 
    "cell will reveal the full set of genes. "
  )
)
fs <- 12
tbl <- results %>%
  mutate(w = width) %>% 
  arrange(!!sym(fdr_column)) %>% 
  plyranges::slice(seq_len(show_n)) %>% 
  plyranges::select(
    w, starts_with("log"), !!sym(fdr_column), status,
    Region = region, any_of("feature"), Genes = gene_name
  ) %>% 
  as_tibble() %>% 
  dplyr::rename(Range = range, `Width (bp)` = w) %>% 
  rename_with(\(x) str_replace_all(x, "feature", "Feature")) %>% 
  mutate(
    Genes = map_chr(Genes, paste, collapse = "; "),
    across(any_of("Feature"), str_sep_to_title)
  ) %>% 
  reactable(
    filterable = TRUE,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 20, 50, show_n), defaultPageSize = 10,
    borderless  = TRUE,
    columns = list2(
      Range = colDef(
        minWidth = 10 * fs,
        cell = \(value) str_replace_all(value, ":", ": ")
      ),
      `Width (bp)` = colDef(
        style = \(value) {
          x <- value / scaling_vals$Width
          colour <- expr_col(x)
          list(
            background = colour, 
            borderRight = "1px solid rgba(0, 0, 0, 0.1)"
          )
        },
        maxWidth = 5 * fs
      ),
      logCPM = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logCPM)) / diff(scaling_vals$logCPM)
          colour = expr_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      logFC = colDef(
        cell = \(value) round(value, 2),
        style = \(value) {
          x <- (value - min(scaling_vals$logFC)) / diff(scaling_vals$logFC)
          colour <- lfc_col(x)
          list(background = colour)
        },
        maxWidth = 5.5 * fs
      ),
      "{fdr_column}" := colDef(
        name = "FDR",
        cell = \(value) {
          fmt <- ifelse(value < 0.01, "%.2e", "%.3f")
          sprintf(fmt, value)
        },
        style = \(value) {
          text_colour <- ifelse(
            value < params$alpha, "black", direction_colours[["Unchanged"]]
          )
          list(color = text_colour, borderRight = "1px solid rgba(0, 0, 0, 0.1)")
        },
        maxWidth = 5.5 * fs
      ),
      status = colDef(
        "Status", maxWidth = 80,
        style = \(value) {
          i <- which(names(direction_colours) == value)
          list(color = direction_colours[[i]])
        } 
      ),
      Region = colDef(maxWidth = 150),
      Genes = colDef(
        cell = \(value) with_tooltip(value, width = ifelse(has_features, 30, 60)),
        minWidth = 11 * fs
      )
    ),
    theme = reactableTheme(style = list(fontSize = fs)),
    elementId = 'tbl-top-ranked'
  )
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('tbl-top-ranked', '{comp}_top_ranked.csv')"
    )
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('tbl-top-ranked', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```



### Summary Plots {.tabset}

```{r make-heatmaps}
type <- str_to_lower(type)
bw_type <- match.arg(heat_params$bw_type, c("FE", "coverage"))
fill_type <- c(coverage = "logCPM", FE = "Fold-Enrichment")[bw_type]
bwfl <- file.path(
  all_paths$macs2, target, ifelse(
    bw_type == "coverage",
    "{target}_{treat_levels}_merged_treat_pileup.bw",
    "{target}_{treat_levels}_merged_FE.bw"
  )
) %>% 
  glue() %>% 
  BigWigFileList() %>% 
  setNames(treat_levels) 
sig_ranges <- results %>% 
  filter(!!sym(fdr_column) < params$alpha) %>%
  splitAsList(f = .$status) %>% 
  .[map_int(., length) > heat_params$min_ranges] 
if (win_type == "sliding") {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "keyval_range")
} else {
  sig_ranges <- endoapply(sig_ranges, colToRanges, "centred_peak")
}
sig_profiles <- lapply(sig_ranges, as.null)
for (i in names(sig_profiles)) {
  set.seed(threads)
  temp_gr <- granges(sig_ranges[[i]])
  n <- length(temp_gr)
  if (n > heat_params$max_ranges) 
    temp_gr <- temp_gr[sort(sample.int(n, heat_params$max_ranges))]
  sig_profiles[[i]] <- getProfileData(
    bwfl, temp_gr, upstream = heat_params$width / 2, 
    log = bw_type == "coverage", bins = heat_params$n_bins, 
    BPPARAM = bpparam()
  )
  rm(temp_gr)
}
profile_heatmaps <- list()

if (length(sig_profiles) > 0) {
  profile_heatmaps <- sig_profiles %>% 
    parallel::mclapply(
      plotProfileHeatmap,
      profileCol = "profile_data", colour = "name",
      xLab = "Distance from Centre (kb)", fillLab = fill_type,
      labelFunX = comma_format(accuracy = 0.1, scale = 1e-3),
      mc.cores = max(1, length(sig_profiles))
    ) 
  fill_range <- profile_heatmaps %>% 
    lapply(\(x) x$data[,"score"]) %>% 
    unlist() %>%
    range()
  sidey_range <- profile_heatmaps %>% 
    lapply(\(x) x$layers[[3]]$data$y) %>% 
    unlist() %>% 
    range()
  profile_heatmaps <- profile_heatmaps %>% 
    lapply(
      \(x) {
        suppressWarnings(
          x + 
            scale_fill_gradientn(
                colours = heat_params$gradient, limits = fill_range
            ) +
            scale_xsidey_continuous(limits = sidey_range) +
            scale_colour_manual(values = treat_colours) +
            labs(
              x = "Distance from Centre (kb)",
              fill = fill_type, colour = "Treat"
            ) +
            theme(strip.text.y = element_text(angle = 0))
        )
      }
    )
}
```


#### MA Plot

```{r plot-ma, fig.cap = glue("*MA plot showing the status of all {type} under consideration. The two most extreme {type} are labelled by region and any associated genes, whilst the overall pattern of association between signal level (logCPM) and changed signal (logFC) is shown as the blue curve.*")}
if (!"Ambiguous" %in% levels(results$status)) 
  direction_colours <- direction_colours[names(direction_colours) != "Ambiguous"]
results %>% 
  as_tibble() %>%
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, bs = "cs")) +
  geom_hline(yintercept = 0) +
  geom_label_repel(
    aes(y = logFC, label = annot, colour = status),
    data = . %>%
      dplyr::filter(!!sym(fdr_column) < params$alpha) %>% 
      arrange(desc(abs(logFC))) %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(x = "Ave Signal (logCPM)", colour = "Status") 
```


#### Volcano Plot

```{r plot-volcano, fig.cap = glue("*Volcano plot showing {type} with evidence of differential {target} signal. The most significant {type} are labelled along with any genes these regions are mapped to.*")}
results %>% 
  as_tibble() %>% 
  ggplot(aes(logFC, -log10(PValue))) +
  geom_point(aes(colour = status), alpha = 0.6) +
  geom_label_repel(
    aes(label = annot, colour = status),
    data = . %>%
      arrange(PValue) %>%
      dplyr::filter(!!sym(fdr_column) < params$alpha) %>% 
      droplevels() %>% 
      dplyr::slice(1:2, .by = status) %>% 
      mutate(
        detected = gene_name %>%
          lapply(paste, collapse = ", ") %>%
          unlist() %>%
          str_replace("^NA$", "") %>%
          str_wrap(width = 30) %>% 
          str_trunc(60),
        range = ifelse(detected == "", range, paste0(range, "\n")),
        annot = glue("{range}{detected}")
      ),
    fill = rgb(1, 1, 1, 0.4),
    size = 3,
    show.legend = FALSE
  ) +
  scale_colour_manual(values = direction_colours) +
  labs(
    x = "logFC",
    y = expression(paste(-log[10], "p")),
    colour = "Status"
  )
```



```{r plot-all-profile-heatmaps, echo = FALSE}
htmltools::tagList(
  mclapply(
    seq_along(profile_heatmaps),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(profile_heatmaps)[[i]])
      img_out <- file.path(
        fig_path,
        glue("{nm}_profile_heatmap.{fig_type}")
      )
      n_ranges <- length(sig_profiles[[i]][[1]])
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = min(
          3.5 + knitr::opts_current$get("fig.height") * n_ranges / 1.5e3, 
          10
        )
      )
      print(profile_heatmaps[[i]])
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(
        glue(
          "
        {n_ranges} {type} selected as showing {nm} signal. Heatmaps were 
        restricted to a maximum of {comma(heat_params$max_ranges)} {type}. Values 
        shown are use the {bw_type}-based bigwig files produced by macs2 callpeak.
        "
        )
      )
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(
            glue("Profile Heatmaps: {str_to_title(nm)} Signal")
          ),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


#### Signal By Region

```{r boxplot-regions, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each genomic region.*"}
results %>% 
  select(logCPM, logFC, region) %>% 
  as_tibble() %>% 
  mutate(
    x = fct_relabel(
      region, str_replace_all, pattern = " \\(", replacement = "\n("
    ),
  ) %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(x, value, fill = region)) +
  geom_boxplot() +
  facet_grid(rows = vars(name), scales = "free", switch = "y") +
  scale_fill_manual(values = region_colours) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r if (n_sig > 0) "#### Differential Signal By Region"`

```{r plot-db-regions, eval = n_sig > 0, echo = n_sig > 0, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all genomic regions.*")}
results %>% 
  dplyr::filter(!!sym(fdr_column) < params$alpha) %>%
  as_tibble() %>% 
  dplyr::rename("{target}" := status, Region = region) %>% 
  droplevels() %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Region", min_p = 0.02,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = region_colours
  )
```

`r ifelse(has_features, "#### Signal By Feature", "")`

```{r boxplot-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = "*Distributions of overall signal (logCPM) and changed signal (logFC) for each external features.*"}
results %>% 
  select(logCPM, logFC, feature) %>% 
  as_tibble() %>% 
  pivot_longer(cols = c("logCPM", "logFC")) %>% 
  ggplot(aes(feature, value, fill = feature)) +
  geom_boxplot() +
  facet_grid(
    name~., scales = "free", switch = "y"
  ) +
  scale_fill_manual(values = colours$features) +
  labs(x = "Region", y = c(), fill = "Overlaps") 
```

`r ifelse(has_features, "#### Differential Signal By Feature", "")`

```{r plot-db-features, eval = has_features, echo = has_features, fig.height = 7, fig.cap = glue("*Merged windows considered as showing differential {target} signal across all external features.*")}
results %>% 
  dplyr::filter(!!sym(fdr_column) < params$alpha) %>%
  as_tibble() %>% 
  mutate(feature = str_sep_to_title(feature)) %>% 
  dplyr::rename("{target}" := status, Feature = feature) %>% 
  plotSplitDonut(
    inner = !!sym(target), outer = "Feature", min_p = 0.01,
    inner_glue = "{.data[[inner]]}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    outer_glue = "{str_wrap(.data[[outer]], 12)}\nn = {comma(n, 1)}\n{percent(p, 0.1)}",
    inner_palette = direction_colours,
    outer_palette = feature_colours
  )
```


### Inspection of Top-Ranked Regions {.tabset}

```{r get-cmn-plot-objects}
cb <- config$genome$build %>% 
  str_to_lower() %>% 
  paste0(".cytobands") 
data(list = cb)
bands_df <- get(cb)
stopifnot(
  colnames(bands_df) == c("chrom", "chromStart", "chromEnd", "name", "gieStain")
)
trans_models <- file.path(all_paths$annotation, "trans_models.rds") %>% 
  read_rds() 
```


```{r grl-to-plot}
## Define a GRL with the key ranges.
## Then we can step through it & make all of the requisite plots
grl_to_plot <- GRangesList(
  
  top_inc_by_fdr = results %>% 
    filter(logFC > 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_inc_by_lfc = filter(results, logFC == max(logFC)),
  
  top_dec_by_fdr = results %>% 
    filter(logFC < 0, !!sym(fdr_column) < params$alpha) %>% 
    arrange(PValue) %>% 
    .[min(1, length(.))],
  top_dec_by_lfc = filter(results, logFC == min(logFC))
  
) %>% 
  unlist() %>% 
  .[!duplicated(.)] %>%
  splitAsList(names(.)) %>% 
  lapply(setNames, c()) %>% 
  lapply(\(x) x[1]) %>%
  GRangesList()
```


```{r prepare-plot-objects}
## The coverage
bwfl <- list2(
  "{target}" := file.path(
    all_paths$macs2, target, "{target}_{treat_levels}_merged_treat_pileup.bw"
  ) %>% 
    glue() %>% 
    BigWigFileList() %>% 
    setNames(treat_levels)
)
line_col <- list2("{target}" := treat_colours)
## Coverage annotations
annot <- results %>% 
  splitAsList(.$status) %>% 
  .[map_int(., length) > 0] %>% 
  endoapply(granges) %>% 
  list() %>% 
  setNames(target)
## Coverage y-limits
ind <- counts %>% 
  assay("counts") %>% 
  apply(MARGIN = 2, which.max) %>%
  unique()
max_ranges <- rowRanges(counts[ind])
y_lim <- bwfl[[target]] %>%
  lapply(import.bw, which = max_ranges) %>%
  lapply(\(x) c(0, max(x$score))) %>% 
  unlist() %>% 
  range() %>% 
  list() %>% 
  setNames(target)

## The features track
feat_gr <- gene_regions %>% 
  lapply(granges) %>% 
  GRangesList()
feat_col_hfgc <- colours$regions
if (has_features) {
  feat_gr <- list(Regions = feat_gr)
  feat_gr$Features <- external_features
  feat_col_hfgc <- list(
    Regions = unlist(colours$regions),
    Features = unlist(colours$features)
  )
}

## The genes track
hfgc_genes <- trans_models
gene_col <- "grey"
if (has_rnaseq) {
  if (!is.na(rna_lfc_col) & !is.na(rna_fdr_col)) {
    hfgc_genes <- trans_models %>% 
      mutate(
        status = case_when(
          !gene %in% rnaseq$gene_id ~ "Undetected",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) > 0, !!sym(rna_fdr_col) < params$alpha
          )$gene_id ~ "Up",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_lfc_col) < 0, !!sym(rna_fdr_col) < params$alpha
          )$gene_id ~ "Down",
          gene %in% dplyr::filter(
            rnaseq, !!sym(rna_fdr_col) >= params$alpha
          )$gene_id ~ "Unchanged",
        )
      ) %>% 
      splitAsList(.$status) %>% 
      lapply(select, -status) %>% 
      GRangesList()
    gene_col <- colours$direction %>% 
      setNames(str_to_title(names(.)))
  }
}

## External Coverage (Optional)
if (!is.null(config$external$coverage)) {
  ext_cov_path <- config$external$coverage %>% 
    lapply(unlist) %>% 
    lapply(\(x) setNames(here::here(x), names(x)))
  bwfl <- c(
    bwfl[target],
    lapply(ext_cov_path, \(x) setNames(BigWigFileList(x), names(x)))
  )
  line_col <- c(
    line_col[target],
    ext_cov_path %>% 
      lapply(
        \(x) {
          missing <- setdiff(names(x), names(colours$treat))
          cmn <- intersect(names(x), names(colours$treat))
          col <- setNames(character(length(names(x))), names(x))
          if (length(cmn) > 0) col[cmn] <- colours$treat[cmn]
          if (length(missing) > 0) 
            col[missing] <- hcl.colors(
              max(5, length(missing)), "Zissou 1")[seq_along(missing)]
          col
        }
      )
  )
  
  y_ranges <- grl_to_plot %>% 
    unlist() %>% 
    granges() %>% 
    resize(w = 10 * width(.), fix = 'center')
  
  y_lim <- c(
    y_lim[target],
    bwfl[names(bwfl) != target] %>% 
      lapply(
        \(x) {
          GRangesList(lapply(x, import.bw, which = y_ranges)) %>% 
            unlist() %>% 
            filter(score == max(score)) %>% 
            mcols() %>% 
            .[["score"]] %>% 
            c(0) %>% 
            range()
        }
      )
  )
  
}
```



```{r plot-all-top-ranges}
.makeCaption <- function(.gr) {
  if (is.null(.gr)) return(NULL)
  dir <- str_to_lower(.gr$status)
  reg <- case_when(
    str_detect(.gr$region, "Inter") ~ paste("an", .gr$region, "region"),
    str_detect(.gr$region, "Upstream") ~ paste("an", .gr$region),
    str_detect(.gr$region, "(Ex|Intr)on") ~ paste("an", .gr$region),
    str_detect(.gr$region, "^Prom") ~ paste("a", .gr$region)
  )
  feat <- c()
  if (has_features) feat <- case_when(
    str_detect(.gr$feature, "^[AEIOU]") ~ paste("an", .gr$feature),
    !str_detect(.gr$feature, "^[AEIOU]") ~ paste("a", .gr$feature)
  )
  gn <- unlist(.gr$gene_name)
  fdr <- mcols(.gr)[[fdr_column]]
  fdr <- ifelse(
    fdr < 0.001, sprintf('%.2e', fdr), sprintf('%.3f', fdr)
  )
  cp <- c(
    glue(
      "*The {width(.gr)}bp region showing {dir} {target} signal in response to ", 
      "{treat_levels[[2]]} treatment (FDR = {fdr}). ",
      "The range mostly overlapped with {reg}, with all ",
      "defined regions shown as a contiguous bar in the upper panel. ",
      ifelse(
        has_features,
        glue(
          "Using the features supplied in {basename(config$external$features)}, ",
          "this mostly overlapped {feat}, shown as a separate block ",
          "with the gene-centric regions. "
        ),
        glue("")
      )
    ),
    ifelse(
      .gr$overlaps_ref,
      paste(
        "A union peak overlapping this region was identified by",
        "`macs2 callpeak` when using merged samples."
      ),
      "No union peak was identified using `macs2 callpeak`."
    ),
    ifelse(
      length(gn) > 0,
      paste0(
        "Using the above mapping strategy, this range is likely to regulate ",
        collapseGenes(gn, format = ""), "."
      ),
      "No genes were able to be assigned to this region."
    ),
    paste(
      "For each sample, the y-axis limits represent the values from the window", 
      "with the highest signal.*"
    )
  )
  paste(cp, collapse = " ")
}
htmltools::tagList(
  mclapply(
    seq_along(grl_to_plot),
    \(i) {
      ## Export the image
      nm <- str_to_lower(names(grl_to_plot)[[i]])
      tag <- nm %>% 
        str_replace_all("_", " ") %>%
        str_to_title() %>% 
        str_replace_all("(Dec|Inc)", "\\1reased Range (") %>% 
        str_replace_all("Fdr", "FDR") %>% 
        str_replace_all("Lfc", "logFC") %>% 
        str_replace_all("\\( (.+)$", "(\\1)")
      img_out <- file.path(fig_path, glue("{nm}.{fig_type}"))
      fig_fun(
        filename = img_out,
        width = knitr::opts_current$get("fig.width"), 
        height = knitr::opts_current$get("fig.height")
      )
      plotHFGC(
        grl_to_plot[[i]],
        hic = hic,
        features = feat_gr,featcol = feat_col_hfgc, featsize = 1 + has_features,
        genes = hfgc_genes, genecol = gene_col,
        coverage = bwfl, linecol = line_col,
        annotation = annot, 
        annotcol = direction_colours,
        cytobands = bands_df,
        zoom = 10,
        max = 8e3,
        ylim = y_lim,
        col.title = "black", background.title = "white", showAxis = FALSE,
        rotation.title = 90
      )
      dev.off()
      ## Create html tags
      fig_link <- str_extract(img_out, "assets.+")
      cp <- htmltools::tags$em(.makeCaption(grl_to_plot[[i]]))
      htmltools::div(
        htmltools::div(
          id = img_out %>% 
            basename() %>% 
            str_remove_all(glue(".{fig_type}$")) %>% 
            str_to_lower() %>% 
            str_replace_all("_", "-"),
          class = "section level4",
          htmltools::h4(tag),
          htmltools::div(
            class = "figure", style = "text-align: center",
            htmltools::img(src = fig_link, width = "100%"),
            htmltools::tags$caption(cp)
          )
        )
      )
    },
    mc.cores = threads
  )
)
```


## Enrichment Testing 

```{r msigdb}
msigdb <- file.path(all_paths$annotation, "msigdb.rds") %>% read_rds()
gs_url <- msigdb$gs_url[!duplicated(names(msigdb$gs_url))]
enrich_method <- match.arg(enrich_params$method, c("great", "gene_id"))
adj_method <- match.arg(enrich_params$adj, p.adjust.methods)
net_layout <- c(network_params$layout, "fr")[[1]]
```

`r desc_enrichment(enrich_method)`

For all analyses below, the complete set of regions showing signal were used as the background ranges.
As such, if the majority of sites are showing change, there will be minimal opportunity for any pathways to emerge as enriched amongst the changed sites.
Likewise, when very few sites are changed, no enrichment is likely to be observed.

Three primary sets of genomic regions are tested for enrichment relative to background, with these being:

1. All sites showing any change
2. All sites showing increased signal
3. All sites showing decreased signal

All p-values will be adjusted using the `r adj_method` correction during testing.

### Any Changed Site {.tabset}

```{r enrich-changed}
enrich_args <- list(
  test_ranges = filter(results, !!sym(fdr_column) < enrich_params$alpha),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  changed_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  changed_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_changed_enrich <- sum(changed_enrich_df$adj_p < enrich_params$alpha)
tg_changed_enrich <- changed_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```

When testing for enrichment in the `r comma(sum(grepl("creased", results$status)))` sites (`r percent(mean(grepl("creased", results$status)), 0.1)`) showing evidence of any changed signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.

`r if (n_changed_enrich > 0) "#### Results Table"`

```{r tbl-changed-res, eval = n_enrich > 0, echo = n_enrich > 0}
tbl <- changed_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-any_of(c("gene_id"))) %>% 
  dplyr::select(
    gs_name, genes_with_hits, contains("gene"), everything()
  ) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
    columns = enrich_cols[colnames(.)],
    details =  function(index){
      htmltools::div(
        htmltools::tags$pre(
          str_wrap(
            paste(capture.output(changed_enrich_df$genes_with_hits[index]), collapse = "\n"),
            width = 120
          )
        )
      )
    },
    elementId = "changed-enrich-res-table"
  )
cp <- htmltools::em(
  glue(
    "
    Enrichment results for regions showing consistently changed signal for 
    {target}, regardless of direction, using an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('changed-enrich-res-table',
      '{target}_changed_enrich_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('changed-enrich-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('changed-enrich-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_changed_enrich > min_network_size) "#### Network Plot"`

```{r changed-network, echo = n_changed_enrich > min_network_size, eval = n_changed_enrich > min_network_size, fig.cap = glue("*The {n_changed_enrich} most highly ranked gene sets from enrichment analysis using all sites showing changed signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
tg_changed_enrich %>% 
  ggraph(layout = net_layout, weights = oc) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(
      fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
    ),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label, alpha = prop),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% 
          str_trunc(60) %>% 
          str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_changed_enrich) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.2) +
  scale_alpha(range = c(0.5, 1), trans = "sqrt") +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
  labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
  theme_void() 
```


### Any Increased Site {.tabset}

```{r enrich-increased}
enrich_args <- list(
  test_ranges = filter(results, status == "Increased"),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  increased_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  increased_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_increased_enrich <- sum(increased_enrich_df$adj_p < enrich_params$alpha)
tg_increased_enrich <- increased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```

When testing for enrichment in the `r comma(sum(grepl("Increased", results$status)))` sites (`r percent(mean(grepl("Increased", results$status)), 0.1)`) showing evidence of any *decreased* signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.


`r if (n_increased_enrich > 0) "#### Results Table"`

```{r tbl-increased-res, eval = n_enrich > 0, echo = n_enrich > 0}
tbl <- increased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-any_of(c("gene_id"))) %>% 
  dplyr::select(
    gs_name, genes_with_hits, contains("gene"), everything()
  ) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
    columns = enrich_cols[colnames(.)],
    details =  function(index){
      htmltools::div(
        htmltools::tags$pre(
          str_wrap(
            paste(capture.output(increased_enrich_df$genes_with_hits[index]), collapse = "\n"),
            width = 120
          )
        )
      )
    },
    elementId = "increased-enrich-res-table"
  )
cp <- htmltools::em(
  glue(
    "
    Enrichment results for regions showing consistently increased signal for 
    {target}, using direction of change along with an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('increased-enrich-res-table',
      '{target}_increased_enrich_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('increased-enrich-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('increased-enrich-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_increased_enrich > min_network_size) "#### Network Plot"`

```{r increased-network, echo = n_increased_enrich > min_network_size, eval = n_increased_enrich > min_network_size, fig.cap = glue("*The {n_increased_enrich} most highly ranked gene sets from enrichment analysis using only the sites showing consistently increasing signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
tg_increased_enrich %>% 
  ggraph(layout = net_layout, weights = oc) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(
      fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
    ),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label, alpha = prop),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% 
          str_trunc(60) %>% 
          str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_increased_enrich) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.2) +
  scale_alpha(range = c(0.5, 1), trans = "sqrt") +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
  labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
  theme_void() 
```

### Any Decreased Site {.tabset}

```{r enrich-decreased}
enrich_args <- list(
  test_ranges = filter(results, status == "Decreased"),
  db = msigdb, gtf = gtf_gene, bg = results, genome = ucsc$build,
  threads = threads, adj_method = adj_method, min_sig = enrich_params$min_sig,
  params = region_params$promoters
)
if (enrich_method == "great")
  decreased_enrich_df <- do.call(".great_enrich", enrich_args)
if (enrich_method == "gene_id")
  decreased_enrich_df <- do.call(".geneid_enrich", enrich_args)
n_decreased_enrich <- sum(decreased_enrich_df$adj_p < enrich_params$alpha)
tg_decreased_enrich <- decreased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  mutate(
    p = ifelse(p > 0, p, 1e-16),
    prop = observed_gene_hits / gene_set_size 
  ) %>% 
  make_tbl_graph(
    gs = .$gene_id, 
    alpha = enrich_params$alpha, p_col = "adj_p", gs_col = "gs_name", 
    hit_col = "observed_gene_hits", size_col = "gene_set_size", 
    min_dist = network_params$max_distance, max_gs = max(network_params$size)
  )
```


When testing for enrichment in the `r comma(sum(grepl("Decreased", results$status)))` sites (`r percent(mean(grepl("Decreased", results$status)), 0.1)`) showing evidence of any *decreased* signal, `r comma(n_changed_enrich)` pathways were considered to be enriched using an adjusted p-value < `r enrich_params$alpha` as the criteria for considering a pathway as enriched.



`r if (n_decreased_enrich > 0) "#### Results Table"`

```{r tbl-decreased-res, eval = n_enrich > 0, echo = n_enrich > 0}
tbl <- decreased_enrich_df %>% 
  dplyr::filter(adj_p < enrich_params$alpha) %>%
  dplyr::slice(seq_len(100)) %>%
  dplyr::select(-any_of(c("gene_id"))) %>% 
  dplyr::select(
    gs_name, genes_with_hits, contains("gene"), everything()
  ) %>% 
  reactable(
    sortable = TRUE, filterable = TRUE, showPageSizeOptions = TRUE, 
    columns = enrich_cols[colnames(.)],
    details =  function(index){
      htmltools::div(
        htmltools::tags$pre(
          str_wrap(
            paste(capture.output(decreased_enrich_df$genes_with_hits[index]), collapse = "\n"),
            width = 120
          )
        )
      )
    },
    elementId = "decreased-enrich-res-table"
  )
cp <- htmltools::em(
  glue(
    "
    Enrichment results for regions showing consistently decreased signal for 
    {target}, using direction of change along with an adjusted p-value 
    ({adj_method}) < {enrich_params$alpha} to determine significance. 
    The backround to determine relative enrichment was the entire set of tested 
    sites. In the case of large numbers of significant gene-sets, results are 
    limited to the 100  most highly ranked. For gene-sets where the analysis has
    returned a p-value of zero, the value <2e-16 will be printed.
    "
  )
)
tl <- tagList(
  tags$button(
    tagList(fontawesome::fa("download"), "Download as CSV"),
    onclick = glue(
      "Reactable.downloadDataCSV('decreased-enrich-res-table',
      '{target}_decreased_enrich_res.csv')"
    )
  ),
  tags$button(
    "Expand/Collapse All",
    onclick = "Reactable.toggleAllRowsExpanded('decreased-enrich-res-table')"
  ),
  tags$button(
    "Clear All Filters",
    onclick = "Reactable.setAllFilters('decreased-enrich-res-table', [])"
  ),
  tbl,
  cp
)
if (interactive()) {
  htmltools::browsable(tl)
} else {
  tl
}
```

`r if (n_decreased_enrich > min_network_size) "#### Network Plot"`

```{r decreased-network, echo = n_decreased_enrich > min_network_size, eval = n_decreased_enrich > min_network_size, fig.cap = glue("*The {n_decreased_enrich} most highly ranked gene sets from enrichment analysis using the sites showing constent decrease in signal. Edge thickness denotes simiarity between connected nodes. Lighter node colours indicate increased significance. Label transparency and the outline thickness of each node also represent the proportion of each gene set mapped to a range with changed {target}. Node size indicates the number of genes mapped to a range. Networks are capped at a maximum of {max(network_params$size)} gene sets*")}
tg_decreased_enrich %>% 
  ggraph(layout = net_layout, weights = oc) +
  geom_edge_link(aes(width = oc^2, alpha = oc^2)) +
  geom_node_point(
    aes(
      fill = -log10(p), size = observed_gene_hits, stroke = 1.5 * prop
    ),
    shape = 21
  ) +
  geom_node_text(
    aes(label = label, alpha = prop),
    colour = "black", size = 3, 
    data = . %>%
      mutate(
        label = str_replace_all(label, "_", " ") %>% 
          str_trunc(60) %>% 
          str_wrap(width = 18)
      ),
    repel = TRUE, max.overlaps = max(10, round(length(tg_decreased_enrich) / 4, 0)),
    bg.color = "white", bg.r = 0.1, 
  ) +
  scale_x_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  scale_fill_viridis_c(option = "inferno", begin = 0.2) +
  scale_alpha(range = c(0.5, 1), trans = "sqrt") +
  scale_size_continuous(range = c(1, 10)) +
  scale_edge_width(range = c(1, 6), limits = c(0, 1)) +
  scale_edge_alpha(range = c(0.1, 0.4), limits = c(0, 1))  +
  guides(edge_alpha = "none", edge_width = "none", alpha = "none") +
  labs(size = "Mapped\nGenes", fill = expr(paste("-", log[10], "p"))) +
  theme_void() 
```




# CHECK RNASEQ MODULE

```{r add-rna, eval = has_rnaseq, child = here::here('workflow/modules/rnaseq_differential.Rmd')}
```


## Data Export

```{r export-diff-by-gene}
results %>% 
  as_tibble() %>%
  unnest(all_of("gene_id")) %>%
  mutate(gene_name = id2gene[gene_id]) %>% 
  dplyr::select(
    gene_id, gene_name, range, logCPM, logFC, PValue, !!sym(fdr_column), 
    status, any_of(c("region", "feature")), macs2_peak = overlaps_ref,
  ) %>% 
  mutate(
    distance_to_gene = distance(
      GRanges(range),
      setNames(gtf_gene, gtf_gene$gene_id)[gene_id]
    )
  ) %>% 
  write_csv(
    gzfile(all_out$csv)
  )
```


```{r data-export, results='hide'}
write_rds(results, all_out$results, compress = "gz")
file.create(all_out$de_genes)
if (has_rnaseq) write_csv(de_genes_db_regions, all_out$de_genes)

file.create(all_out$up_regions)
if (sum(results$status == "Increased") > 0) {
  results %>% 
    filter(status == "Increased") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}

file.create(all_out$down_regions)
if (sum(results$status == "Decreased") > 0) {
  results %>% 
    filter(status == "Decreased") %>% 
    granges() %>% 
    export.bed(all_out$up_regions)
}
## Enrichment results need a bit of tweaking to match the tables
list2(
  `All Differentially Bound` = goseq_diff,
  "All Increased {target}" := goseq_up,
  "All Decreased {target}" := goseq_down
) %>% 
  bind_rows(.id = 'group') %>% 
  dplyr::filter(adj_p < enrich_alpha) %>% 
  left_join(
    dplyr::select(msigdb, gs_name, gene_name, gene_id, gs_url, gs_description),
    by = "gs_name"
  ) %>% 
  dplyr::filter(
    gene_id %in% unlist(subset(results, status != "Unchanged")$gene_id)
  ) %>% 
  dplyr::select(-gene_id) %>% 
  chop(gene_name) %>% 
  mutate(
    gene_name = map_chr(gene_name, paste, collapse = ": "),
    `%` = numDEInCat / numInCat,
  ) %>% 
  dplyr::select(
    group,
    `Gene Set` = gs_name, Description = gs_description, URL = gs_url,
    `%`, numDEInCat, numInCat, p = pval, adj_p, 
    `Genes Mapped to DB Windows` = gene_name
  ) %>% 
  write_csv(all_out$enrichment)
list2(
  `All Differentially Bound` = cmn_diff,
  "All Increased {target}" := cmn_up,
  "All Decreased {target}" := cmn_down
) %>% 
  bind_rows(.id = "group") %>% 
  mutate(
    genes = map_chr(leadingEdge, paste, collapse = "; "),
    leadingEdge = map_chr(leadingEdge, paste, collapse = "; "),
  ) %>% 
  write_csv(all_out$rna_enrichment)
## Save key memory on the HDD
gc()
save.image(all_out$renv)
```

During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, "output.+"))`

## References

<div id="refs"></div>
<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">

```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```

</div>
