import pandas as pd
import os
import re
import subprocess
import urllib
import sys
import random
import itertools
import yaml
import json

configfile: "config/config.yml"

## Figure out how to run check_yaml from here if possible
## python scripts/check_yaml.py

####################################
## Check all external files exist ##
####################################
for i in config['external']:
	f = config['external'][i]
	if type(f) == str:
		msg = "File " + f + " not found"
		assert (os.path.isfile(f)), msg
	if type(f) == dict:
		for j in f:
			for k in f[j]:
				msg = "File " + f[j][k] + " not found"
				assert(os.path.isfile(f[j][k])), msg
			

####################
## Define Samples ##
####################
df = pd.read_table(config['samples']['file'])

## Now set all values as required
samples = list(set(df['sample']))
targets = list(set(df['target']))
targets_ext = targets.copy()
targets_ext.extend(['shared']) # Enable 'shared' in widlcards
treats = list(set(df['treat']))
inputs = list(set(df['input']))

## Note that the last level in treats can never be the reference level
wildcard_constraints:
	target = "(" + '|'.join(targets_ext) + ")",
	sample = "(" + '|'.join(samples) + ")",
	treat = "(" + '|'.join(treats) + ")",
	ref = "(" + '|'.join(treats) + ")"

###############
## Key Paths ##
###############
bam_path = config['paths']['bam']
rmd_path = "analysis"
annotation_path = os.path.join("output", "annotations")
check_path =os.path.join("output", "checks")
diff_path = os.path.join("output", "differential_signal")
grey_path = os.path.join("output", "greylist")
json_path = os.path.join("config", "json")
macs2_path = os.path.join("output", "macs2")
peak_path = os.path.join("output", "peak_analysis")
log_path = os.path.join("workflow", "logs")


#######################
## Update parameters ##
#######################
def set_params(config, targets):
	out = {}
	for i in targets:
		out[i] = config['default'].copy()
		if i in config.keys():
			for j in config[i].keys():
				out[i][j] = config[i][j]
	return(out)

# Dump params to json. Might be handy later
os.makedirs(json_path, exist_ok = True)
macs2_param = set_params(config['macs2'], targets)
with open(os.path.join(json_path, "macs2_param.json"), 'w') as fp:
	json.dump(macs2_param, fp, indent = 4)

macs2_qc_param = set_params(config['macs2_qc'], targets)
with open(os.path.join(json_path, "macs2_qc_param.json"), 'w') as fp:
	json.dump(macs2_qc_param, fp, indent = 4)

motif_param = set_params(config['motif_analysis'], targets_ext)
with open(os.path.join(json_path, "motif_analysis_param.json"), 'w') as fp:
	json.dump(motif_param, fp, indent = 4)

## These do need more careful checking as not all levels may be found in each 
## target. Compare to df['treat'][df$target' == x] at some point
diff_sig_param = set_params(config['differential_signal'], targets)
rm_targets = []
for i in diff_sig_param.keys():
	poss_levels = set(df['treat'][df['target'] == i])
	valid_contrasts = []
	J = len(diff_sig_param[i]['contrasts'])
	for j in range(J):
		supplied = diff_sig_param[i]['contrasts'][j].copy()
		valid = poss_levels.intersection(supplied)
		if len(valid) == 2:
			valid_contrasts.extend([supplied])
			
	if len(valid_contrasts):
		diff_sig_param[i]['contrasts'] = valid_contrasts
		diff_sig_param[i]['target'] = i
	else:
		rm_targets.extend([i])

if len(rm_targets):
	for i in rm_targets:
		del diff_sig_param[i]

with open(os.path.join(json_path, "differential_signal_param.json"), 'w') as fp:
	json.dump(diff_sig_param, fp, indent = 4)

all_contrasts = []
if len(diff_sig_param):
	for i in diff_sig_param.keys():
		for j in range(len(diff_sig_param[i]['contrasts'])):
			lv = diff_sig_param[i]['contrasts'][j]
			cont = i + "_" + lv[0] + "_" + lv[1]
			all_contrasts.extend([cont])

all_contrasts.sort()

## Turn of all Diff Signal & Pairwise comps by uncommenting this line
all_contrasts = []

## use the contrasts to define all pairwise comparisons
pairs = []
for p in list(itertools.combinations(all_contrasts, 2)):
	pairs.extend([p[0] + "_" + p[1]])

pairs = []

#################
## Figure Type ##
#################
rmdconfigfile = "config/rmarkdown.yml"
rmd_config = yaml.safe_load(open(rmdconfigfile))
fig_type = rmd_config['knitr_opts']['dev']
if type(fig_type) is list:
	fig_type = fig_type[0]


###############################
## External Annotation Files ##
###############################
## These are required input for multiple steps
gtf = config['external']['gtf']
blacklist = config['external']['blacklist']
chrom_sizes = os.path.join(annotation_path, "chrom.sizes")

#################################
## Differential Signal Method ##
#################################

# Currently LibSize + QuasiLikelihood (ls-ql) or 
# SmoothQuantile + Limma-Trend (sq-lt)
# db_method = config['comparisons']['method']

#####################
## Prepare Outputs ##
#####################
ALL_OUTPUTS = []

############
## Checks ##
############
ALL_CHECKS = expand(
	os.path.join("output", "checks", "{f}.chk"),
	f = ['here', 'r-packages', 'external-files']
)

#####################################
## Annotations Defined in worfklow ##
#####################################

## These are dependent on H3K27Ac being a target. If so, promoters, enhancers
## and super-enhancers will be created. If not, only the tss regions will be
## created
ALL_RDS = expand(
	os.path.join(annotation_path, "{file}.rds"),
	file = [
		'colours', 'gene_regions', 'seqinfo', 'trans_models','tss', 'gtf_gene',
		'gtf_transcript', 'gtf_exon', 'blacklist', 'features', 'motif_list',
		'motif_uri'
	]
)
ALL_OUTPUTS.extend(ALL_RDS)

#######################
## Rmarkdown Outputs ##
#######################
HTML_OUT = expand(
	os.path.join("docs", "{file}.html"),
	file = ['annotation_description']
)

## Macs2 Summaries
HTML_OUT.extend(
	expand(
		os.path.join("docs", "{target}_macs2_summary.html"),
		target = targets
	)
)
if len(targets) > 1:
	HTML_OUT.extend([os.path.join("docs", "peak_comparison.html")])
	

## Try bringing in diffsignal again
COUNTS = expand(
	os.path.join(peak_path, "{target}", "{target}_counts.rds"),
	target = targets
)
ALL_OUTPUTS.extend(COUNTS)
RMD = expand(
	os.path.join(rmd_path, "{cont}_differential_signal.Rmd"),
	cont = all_contrasts
)
ALL_OUTPUTS.extend(RMD)


# Differential Signal
HTML_OUT.extend(
	expand(
		os.path.join("docs", "{cont}_differential_signal.html"),
		cont = all_contrasts
	)
)

## Pairwise Comparisons: Only if required
HTML_OUT.extend(
	expand(
		os.path.join("docs", "{comp}_pairwise_comparison.html"),
		comp = pairs
	)
)


ALL_OUTPUTS.extend(HTML_OUT)
## Keep the final index separate for easiers passing to other rules
# ALL_OUTPUTS.extend([os.path.join("docs", "index.html")])

## Consensus Peaks
CONS_PEAKS = expand(
	os.path.join(peak_path, "{target}", "{target}_consensus_peaks.bed.gz"),
	target = targets,
)
ALL_OUTPUTS.extend(CONS_PEAKS)


###########################
## Peak Files from macs2 ##
###########################
INDIV_PEAKS = expand(
	os.path.join(macs2_path, "{sample}", "{sample}_peaks.narrowPeak"),
	sample = samples
)
ALL_OUTPUTS.extend(INDIV_PEAKS)
df['merged_pre'] = df[['target', 'treat']].agg('_'.join, axis = 1)
merged_pre = set(df[['target', 'merged_pre']].agg('/'.join, axis = 1))
MERGED_PEAKS = expand(
	os.path.join(macs2_path, "{pre}_merged_peaks.narrowPeak"),
	pre = merged_pre
)
ALL_OUTPUTS.extend(MERGED_PEAKS)


##################
## BigWig Files ##
##################
# These aren't used anywhere in the workflow...
# INDIV_BW = expand(
# 	os.path.join(macs2_path, "{sample}", "{sample}_treat_pileup.bw"),
# 	sample = samples
# )
# ALL_OUTPUTS.extend(INDIV_BW)
MERGED_BW = expand(
	os.path.join(macs2_path, "{path}_merged_treat_pileup.bw"),
	path = merged_pre
)
ALL_OUTPUTS.extend(MERGED_BW)
# FE_BW = expand(
# 	os.path.join(macs2_path, "{path}_merged_FE.bw"), path = merged_pre
# )
# ALL_OUTPUTS.extend(FE_BW)

rule all:
	input:
		ALL_OUTPUTS

include: "rules/initial_checks.smk"
include: "rules/annotations.smk"
include: "rules/samtools.smk"
include: "rules/create_rmd.smk"
include: "rules/compile_rmd.smk"
include: "rules/macs2.smk"
include: "rules/consensus_peaks.smk"
include: "rules/make_greylist.smk"
include: "rules/bigwig.smk"
include: "rules/regioner.smk"
include: "rules/motif_analysis.smk"
include: "rules/differential_signal.smk"
# include: "rules/pairwise_comparisons.smk"