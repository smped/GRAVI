---
title: "Annotation Setup"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
editor_options:
  chunk_output_type: console
---

```{r set-knitr-opts, echo=FALSE, child = '../workflow/modules/setup_chunk.Rmd'}
```

```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(plyranges)
library(yaml)
library(Rsamtools)
library(parallel)
library(BiocParallel)
```

```{r remotes, results='hide'}
## Deal with github packages
# BiocManager::install("steveped/extraChIPs", ask = FALSE)

stopifnot(library(extraChIPs, logical.return = TRUE))
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
)
n_cores <- max(detectCores() - 2, 2)
str_sep_to_title <- function(x, sep = "_", replacement = " ") {
  str_replace_all(x, sep, replacement) %>% 
    str_to_title()
}
```


```{r config}
config <- read_yaml(here::here("config", "config.yml"))
```

```{r treat_levels}
treat_levels <- config$comparisons$contrasts %>% 
  unlist() %>% 
  unique()
samples <- here::here(config$samples$file) %>%
  read_tsv() %>% 
  mutate(
    treat = factor(treat, levels = unique(c(treat_levels, treat))),
    target = as.factor(target)
  )
treat_levels <- levels(samples$treat)
```


```{r annotation-path}
annotation_path <- here::here("output", "annotations")
if (!dir.exists(annotation_path)) dir.create(annotation_path, recursive = TRUE)
all_out <- list(
  seqinfo = file.path(annotation_path, "seqinfo.rds"),
  chrom_sizes = file.path(annotation_path, "chrom.sizes"),
  gtf  = file.path(annotation_path, "all_gr.rds"),
  transcript_models = file.path(annotation_path, "trans_models.rds"),
  gene_features = file.path(annotation_path, "gene_features.rds"),
  colours  = file.path(annotation_path, "colours.rds")
)
```


# Genome Annotations

Before analysing any datasets, annotations for the genome and transcriptome need to be defined.

## Genome Description

```{r sq}
sq <- samples %>% 
  mutate(
    path = here::here(config$paths$bam, target, glue("{sample}.bam"))
  ) %>% 
  .[["path"]] %>% 
  BamFileList() %>% 
  seqinfo() %>% 
  sortSeqlevels() %>% 
  as.data.frame() %>% 
  .[rownames(.) %in% paste0("chr", c(1:22, "X", "Y")),] %>%  # This covers mouse & rat
  mutate(
    isCircular = FALSE,
    genome = config$genome$build
  ) %>% 
  as("Seqinfo")
write_rds(sq, all_out$seqinfo)
sq %>% 
  as.data.frame() %>% 
  rownames_to_column("seqnames") %>% 
  dplyr::select(seqnames, seqlengths) %>% 
  write_tsv(all_out$chrom_sizes, col_names = FALSE)
```

As the foundation for all annotation objects, the description of the underlying genome is required as a `Seqinfo` object.
For this analysis, both the mitochondrial genome and scaffolds were excluded, giving only the autosomes and the X chromosome.
This `Seqinfo` will is added to all objects requiring information about the underlying genome, such as a `GenomicRanges` object.

## Blacklisted Regions {.tabset}

```{r blacklist}
blacklist <- file.path(annotation_path, "blacklist.bed.gz") %>%
  import.bed(seqinfo = sq) %>%
  sort()
```

### Summary

```{r tab-blacklist}
blacklist %>% 
  group_by(name) %>% 
  summarise(
    n = n(),
    p = percent(sum(width)/ sum(seqlengths(sq))),
    kb = sum(width) / 1e3,
    min = min(width) / 1e3,
    median = median(width) / 1e3,
    max = max(width) / 1e3
  ) %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  dplyr::rename_all(str_to_title) %>% 
  dplyr::rename(
    Type = Name, 
    `Nbr Regions` = N,
    `% Genome` = P, 
    `Total (kb)` = Kb,
    `Min (kb)` = Min,
    `Median (kb)` = Median,
    `Max (kb)` = Max
  ) %>% 
  pander(
    caption = glue(
      "Summary of genomic regions excluded in the blacklist. ",
      "The default set of blacklisted regions was used, as obtained from ",
      "https://github.com/Boyle-Lab/Blacklist (ENCODE)"
    ),
    justify = "lrrrrrr"
  )
```

### Breakdown

```{r plot-blacklist, fig.height = 6, fig.cap = "Breakdown of blacklisted regions by chromosome"}
blacklist %>% 
  as.data.frame() %>% 
  as_tibble() %>%
  group_by(seqnames) %>% 
  summarise(blacklisted = sum(width)) %>% 
  left_join(
    as.data.frame(sq) %>% 
      rownames_to_column("seqnames")
  ) %>% 
  mutate(
    whitelisted = seqlengths - blacklisted,
    seqnames = factor(seqnames, levels = seqlevels(sq))
  ) %>% 
  pivot_longer(
    ends_with("listed"), names_to = "category", values_to = "bp"
  ) %>% 
  ggplot(aes(fct_rev(seqnames), bp/1e6, fill = fct_rev(category))) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(expand = expansion(c(0, 0.05))) +
  scale_fill_manual(
    values = c(rgb(0.1, 0.3, 0.9), rgb(0.9, 0.2, 0.1))
  ) +
  labs(
    x = "Chromosome", y = "Length (Mb)", fill = "Status"
  )
```


# Gene and Transcript Annotations

## Basic Annotations

```{r load-gtf}
gtf <- glue(
  "{annotation_path}/",
  "gencode.v", config$genome$gencode, "lift", 
  str_extract(config$genome$build, '[0-9]+$'),
  ".annotation.gtf.gz"
  )
reqd_cols <- c(
  "type",
  "gene_id", "gene_type", "gene_name",
  "transcript_id", "transcript_type", "transcript_name",
  "exon_id"
)
if (!file.exists(all_out$gtf)) {
  all_gr <- gtf %>%
    import.gff(
      which = GRanges(sq),
      feature.type = c("gene", "transcript", "exon")
    ) %>%
    select(all_of(reqd_cols)) %>%
    mutate(
      gene_id = str_remove_all(gene_id, "\\..+$"),
      transcript_id = str_remove_all(transcript_id, "\\..+$"),
      exon_id = str_remove_all(exon_id, "\\..+$"),
    ) %>%
    sort() %>%
    subset(seqnames %in% seqlevels(sq)) %>% 
    keepSeqlevels(seqlevels(sq)) %>% 
    splitAsList(f = .$type)
  seqinfo(all_gr) <- sq
  write_rds(all_gr, all_out$gtf, compress = "gz")
} else {
  all_gr <- read_rds(all_out$gtf)
}
```

- The complete set of genes, transcripts and exons was loaded from the supplied `gtf`, excluding mitochondrial features.
- The previously generated `Seqinfo` was also placed as the foundation of this annotation object, ensuring this propagates through all subsequent objects
- Version numbers were removed from all gene, transcript and exon identifiers for convenience, with the minimal set of columns (`r pander(colnames(mcols(all_gr$gene)))`) retained.
- This master set of annotations was exported as an `rds` file for simple import into subsequent steps of the analysis

In total this object contained annotations for `r comma(length(all_gr$gene))` genes, `r comma(length(all_gr$transcript))` transcripts and `r comma(length(all_gr$exon))` exons.

```{r trans-models}
if (!file.exists(all_out$transcript_models)) {
  trans_models <- all_gr$exon %>% 
    as.data.frame() %>% 
    as_tibble() %>% 
    group_by(transcript_id) %>% 
    mutate(exon = paste0(transcript_id, "_", seq_along(transcript_id))) %>% 
    makeGRangesFromDataFrame(keep.extra.columns = TRUE) %>% 
    mutate(feature = as.character(type)) %>%  
    select(type, gene = gene_id, exon, transcript = transcript_id, symbol = gene_name) %>% 
    sort() %>% 
    setNames(.$transcript) %>% 
    set_genome_info(
      genome = genome(sq),
      seqnames = seqlevels(sq),
      seqlengths = seqlengths(sq),
      is_circular = isCircular(sq)
    )
  write_rds(trans_models, all_out$transcript_models, compress = "gz")
} else {
  trans_models <- read_rds(all_out$transcript_models)  
}
```

Visualisation using the Bioconductor package `Gviz` also requires a specific `GRanges` structure for gene and transcript models to be displayed.
This object was formed here, so they too could be simply imported during all visualisation stages.

## Gene-Centric Features

```{r gene-features}
rna_path <- here::here(config$external$rnaseq)
rnaseq <- tibble(gene_id = character())
if (!is.null(rna_path)) {
  stopifnot(file.exists(rna_path))
  if (str_detect(rna_path, "tsv$")) rnaseq <- read_tsv(rna_path)
  if (str_detect(rna_path, "csv$")) rnaseq <- read_csv(rna_path)
  if (!"gene_id" %in% colnames(rnaseq)) stop("Supplied RNA-Seq data must contain the column 'gene_id'")
}
## Setup the features as a hierarchy, where higher-level features take precedence
## Features can be merged within a category if they overlap
## 1. Promoters (+/-2kb)
## 2. Upstream promoter (2-5kb, but not overlapping another)
## 3. Introns
## 4. Exons (other gene body)

if (!file.exists(all_out$gene_features)) {
  gene_features <- list(
    tss = resize(all_gr$transcript, width = 1) %>% 
      mutate(type = "tss"),
    promoters = all_gr$transcript %>% 
      promoters(
        upstream = 1500, downstream = 500
      ) %>% 
      reduceMC() %>% 
      mutate(type = "promoter")
  )
  gene_features$upstream <- gene_features$promoters %>% 
    promoters(upstream = 3.5e3, downstream = 0) %>% 
    setdiffMC(gene_features$promoters) %>% 
    reduceMC() %>% 
    mutate(type = "upstream")
  ## Some of these will possibly extend into other genes.
  ## The only real solution is to cut any sections from the upstream ranges
  ## which overlap other genes, whilst retaining those ranges which are internal
  ## to the gene-of-origin. The only viable way to do that is to manually exclude 
  ## the gene-of-origin then take the setdiff. This will take an hour or two
  gene_features$upstream <- gene_features$upstream %>%
    split(f = seq_along(.)) %>%
    bplapply(
      function(x) {
        gr <- subset(all_gr$gene, !gene_id %in% unlist(x$gene_id))
        setdiffMC(x, gr)
      }
    ) %>% 
    GRangesList() %>% 
    unlist() %>% 
    setNames(c())
  gene_features$introns <- all_gr$gene %>% 
    setdiffMC(
      GRangesList(
        all_gr$exon,
        gene_features$promoters,
        gene_features$upstream
      ) %>% 
        unlist()
    ) %>% 
    mutate(type = "intron")
  gene_features$exons <- all_gr$gene %>% 
    setdiffMC(
      GRangesList(
        gene_features[c("promoters", "upstream", "introns")]
      ) %>% 
        unlist()
    ) %>% 
    mutate(type = "exon")
  write_rds(gene_features, all_out$gene_features, compress = "gz")
} else {
  gene_features <- read_rds(all_out$gene_features)
}
## Need to add in rnaseq at this point  

  
#   gene_features <- lapply(
#     gene_features, mutate, detected = gene_id %in% rnaseq$gene_id
#   )
#   tx_cols <- c("tx_id", "transcript_id")
#   if (any(tx_cols %in% colnames(rnaseq))) {
#     y <- intersect(tx_cols, colnames(rnaseq))[1]
#     gene_features$tss$detected <- gene_features$tss$transcript_id %in% rnaseq[[y]]
#     gene_features$promoters$detected <- gene_features$promoters$transcript_id %in% rnaseq[[y]]
#     gene_features$upstream$detected <- gene_features$upstream$transcript_id %in% rnaseq[[y]]
#     gene_features$exons$detected <- gene_features$exons$transcript_id %in% rnaseq[[y]]
#   }
```

Gene/Transcript-centric features were defined as:

1. The TSS 
2. Promoters (+/- 2kb from the TSS)
3. Upstream (2-5kb upstream)
4. Exons
5. First Introns
6. Other Introns

- TSS, Promoter and Upstream regions were defined in a transcript-centric manner, yielding multiple regions for `r comma(table(gene_features$tss$gene_id) %>% .[. > 1] %>% length())` genes.
- `r comma(length(gene_features$exons))` exons were again defined in a transcript-centric manner for `r comma(length(unique(gene_features$exons$transcript_id)))` transcripts of `r comma(length(unique(gene_features$exons$gene_id)))` genes.

Introns were defined across genes such that these represented the candidate intronic sequences never included in a transcript.
As such, genes containing any unspliced transcripts were unable to have any introns defined.
Intronic regions were additionally restricted such that *any regions which overlapped with a promoter or upstream region from an alternate TSS were not included as intronic.*
This ensures that any binding sites which overlap are truly overlapping an intronic region and not simply having their functional role misclassified as an artefact of annotation.

- `r comma(length(gene_features$first_intron))` first introns were defined for genes with > 1 exon.
- `r comma(length(gene_features$other_intron))` remaining introns were defined across the set of `r comma(length(unique(gene_features$other_intron$gene_id)))` genes containing more than one intron.

If RNA-Seq data was provided, transcripts were considered as detected if the transcript id was included as the column `r glue_collapse(tx_cols, sep = ", ", last = " or ")`.
This data was applied to all transcript-level features (TSS, Promoters, Upstream, Exons).
If no transcript ids were provided in this dataset, genes were considered as expressed if the gene_id was found in a column of the same name.
No genes or transcripts were considered as detected if no RNA-Seq data was provided.

As a consequence of the approach taken using transcript-level information, many genomic regions were assigned to multiple categories.
For example, an upstream promoter for a specific transcript may also be classified as an intron at the gene level.
Alternate TSSs for multiple transcripts may also overlap exons, promoters etc for other transcripts.
As such, *pie-charts will not be drawn in subsequent analyses* as is commonly seen elsewhere.

```{r tab-gene-features}
gene_features %>% 
  lapply(
    function(x) {
      tibble(
        genes = length(unique(x$gene_id)), 
        n_features = length(x), 
        n_detected = sum(x$detected),
        `% detected` = percent(mean(x$detected)),
        blacklisted = sum(overlapsAny(x, blacklist)),
        `% blacklisted` = percent(blacklisted / n_features, accuracy = 0.1)
      )
    }
  ) %>% 
  lapply(list) %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything(), names_to = "feature") %>% 
  unnest(value) %>% 
  mutate(feature = str_sep_to_title(feature)) %>% 
  rename_all(str_sep_to_title) %>% 
  pander(
    justify = "lrrrrrr",
    caption = glue(
      "Summary of features defined from annotations for {config$genome$build} ",
      "using Genocide release {config$genome$gencode}."
    )
  )
```

# Additional Features

```{r external-features}
feat_path <- here::here(config$external$features)
external_features <- c()
if (!is.null(feat_path)) {
  stopifnot(file.exists(feat_path))
  external_features <- suppressWarnings(
    import.gff(feat_path, genome = sq)
  )
  mcols(external_features) <- cbind(
    mcols(external_features),
    gene_features %>% 
      lapply(function(x) overlapsAny(external_features, x)) %>% 
      as("DataFrame")
  )
  external_features <- external_features %>% 
    join_nearest(granges(all_gr$gene), distance = TRUE) %>% 
    mutate(
      within_10kb = distance <= 10e3 & distance > 5e3, 
      within_100kb = distance > 10e3 & distance <= 100e3, 
      distal_intergenic = distance > 100e3
    ) %>% 
    select(-distance)
}
```

`r ifelse(is.null(external_features), "No additional features were supplied.", "Additional features were compared to the gene-centric annotations.")`

```{r plot-feature-by-region, eval = !is.null(external_features), echo = !is.null(external_features), fig.cap = "Comparison of additional features with gene-centric annotations."}
regions <- c(
  "tss", "promoters", "upstream", "exons", "first_intron", "other_intron", 
  "within_10kb", "within_100kb", "distal_intergenic"
)
external_features %>% 
  mcols() %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  group_by(feature) %>% 
  summarise(
    across(all_of(regions), mean)
  ) %>% 
  pivot_longer(cols = all_of(regions), names_to = "region", values_to = "p") %>% 
  dplyr::filter(p > 0) %>% 
  mutate(
    region = case_when(
      str_detect(region, "within") ~ str_replace_all(region, "within_(.+)", "Intergenic (within \\1)"),
      str_detect(region, "distal") ~ "Intergenic (distal)",
      str_detect(region, "intron") ~ str_replace_all(region, "(.+)_intron", "Intron (\\1)"),
      str_detect(region, "exon") ~ "Exon",
      str_detect(region, "tss") ~ "TSS",
      str_detect(region, "promoter") ~ "Promoter (+/- 2kb)",
      str_detect(region, "upstream") ~ "Promoter Upstream (< 5kb)"
    ),
    Feature = str_sep_to_title(feature)
  ) %>% 
  ggplot(
    aes(fct_rev(region), p, fill = feature)
  ) +
  geom_col() +
  geom_label(
    aes(label = percent(p, accuracy = 1)),
    alpha = 0.5,
    nudge_y = 0.03
  ) +
  coord_flip() +
  facet_grid(Feature~., scales = "free_y", space = "free") +
  scale_y_continuous(labels = percent, expand = expansion(c(0, 0.05))) +
  scale_fill_manual(values = feat_col) + # These are defined later. Needs to be fixed
  guides(fill = "none") +
  labs(x = "", y = "")
```

```{r}
## Now just restrict the genes to be the detected genes
## Also might need to consider the external_features as mutually exclusive,
## i.e. should enhancers be excluded if considered as super-enhancers
external_features <- external_features %>% 
  select(-any_of(regions))
mcols(external_features) <- cbind(
    mcols(external_features),
    gene_features %>% 
      lapply(function(x) overlapsAny(external_features, subset(x, detected))) %>% 
      as("DataFrame")
  )
external_features <- external_features %>% 
    join_nearest(granges(subset(all_gr$gene, gene_id %in% rnaseq$gene_id)), distance = TRUE) %>% 
    mutate(
      within_10kb = distance <= 10e3 & distance > 5e3, 
      within_100kb = distance > 10e3 & distance <= 100e3, 
      distal_intergenic = distance > 100e3
    ) %>% 
    select(-distance)
external_features %>% 
  mcols() %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  group_by(feature) %>% 
  summarise(
    across(all_of(regions), mean)
  ) %>% 
  pivot_longer(cols = all_of(regions), names_to = "region", values_to = "p") %>% 
  dplyr::filter(p > 0) %>% 
  mutate(
    region = case_when(
      str_detect(region, "within") ~ str_replace_all(region, "within_(.+)", "Intergenic (within \\1)"),
      str_detect(region, "distal") ~ "Intergenic (distal)",
      str_detect(region, "intron") ~ str_replace_all(region, "(.+)_intron", "Intron (\\1)"),
      str_detect(region, "exon") ~ "Exon",
      str_detect(region, "tss") ~ "TSS",
      str_detect(region, "promoter") ~ "Promoter (+/- 2kb)",
      str_detect(region, "upstream") ~ "Promoter Upstream (< 5kb)"
    ),
    Feature = str_sep_to_title(feature)
  ) %>% 
  ggplot(
    aes(fct_rev(region), p, fill = feature)
  ) +
  geom_col() +
  geom_label(
    aes(label = percent(p, accuracy = 1)),
    alpha = 0.5,
    nudge_y = 0.03
  ) +
  coord_flip() +
  facet_grid(Feature~., scales = "free_y", space = "free") +
  scale_y_continuous(labels = percent, expand = expansion(c(0, 0.05))) +
  scale_fill_manual(values = feat_col) + # These are defined later. Needs to be fixed
  guides(fill = "none") +
  labs(x = "", y = "")
```



# Colour Schemes {.tabset}

```{r set_colours}
col_config <- here::here("config", "rmarkdown.yml") %>%
  read_yaml() %>% 
  .[["colours"]]

## qc_colours need to have `Pass` and `Fail`
missing_qc_cols <- setdiff(c("pass", "fail"), names(col_config$qc))
if ("pass" %in% missing_qc_cols) col_config$qc$pass <- "#0571B0" # Blue
if ("fail" %in% missing_qc_cols) col_config$qc$fail <- "#CA0020" # Red
col_config$qc <- col_config$qc[c("pass", "fail")]

## The colours specified as treat_colours should contain all treat_levels + Input
## If Input is missing, set to #33333380 ('grey20' + alpha = 50)
## This should be a standard chunk for all workflows
missing_treat_cols <- setdiff(
  c("Input", treat_levels), names(col_config$treat)
)
if (length(missing_treat_cols) > 0) {
  if ("Input" %in% missing_treat_cols) 
    col_config$treat$Input <- "#33333380"
  ## Automatically sample from the viridis palette if no colour is assigned
  col_config$treat[setdiff(missing_treat_cols, "Input")] <- hcl.colors(
    length(setdiff(missing_treat_cols, "Input"))
  )
}

## Direction colours always need up, down, unchanged & undetected
missing_dir_cols <- setdiff(
  c("up", "down", "unchanged", "undetected"), names(col_config$direction)
)
if (length(missing_dir_cols) > 0){
  def_dir_cols <- c(
    up = "#CA0020", down = "#0571B0", 
    unchanged = "#7F7F7F", undetected = "#E5E5E5"
  )
  col_config$direction[missing_dir_cols] <- def_dir_cols[missing_dir_cols]
}
```

```{r feat-col}
features <- suppressWarnings(
  here::here(config$external$features) %>% 
    import.gff(genome = sq) %>% 
    sort()
)
stopifnot("feature" %in% colnames(mcols(features)))
feat_col <- col_config$features
feat_levels <- unique(features$feature)
missing_feat_col <- setdiff(feat_levels, names(feat_col))
if (length(missing_feat_col) > 0) {
  n <- length(missing_feat_col)
  feat_col[missing_feat_col] <- hcl.colors(max(9, n), "Spectral")[seq_len(n)]
}
col_config$features <- feat_col
```


```{r plot-scheme}
.plotScheme <- function(x, xlab = "", ylab = "") {
  x %>% 
    as_tibble() %>% 
    pivot_longer(cols = everything()) %>% 
    ggplot(
      aes(name, 1, fill = name)
    ) +
    geom_raster() +
    scale_fill_manual(values = unlist(x)) +
    scale_x_discrete(expand = expansion(c(0, 0))) +
    scale_y_continuous(expand = expansion(c(0, 0))) +
    labs(x = xlab, y = ylab) +
    guides(fill = "none") +
    theme(
      axis.text.y = element_blank(),  
      axis.ticks.y = element_blank()
    )
}
```

Colours were checked where provided and any missing colours were automatically assigned.
These colour schemes are shown below and will be propagated through all workflows.
To change any colours, simply add them to `config/rmarkdown.yml`.

## QC

```{r plot-qc, fig.height=3, fig.width=2 + length(col_config$qc)}
col_config$qc %>% 
  .plotScheme(xlab = "QC Category") 
```

## Treatment Groups

```{r plot-treat, fig.height=3, fig.width=2 + length(col_config$treat)}
col_config$treat %>% 
  .plotScheme(xlab = "Treatment")
```

## Features

```{r plot-feat, fig.height=3, fig.width=2 + length(col_config$features)}
feat_col %>% 
  .plotScheme(xlab = "Feature")
```

## Direction

```{r plot-dir, fig.height=3, fig.width=2 + length(col_config$direction)}
col_config$direction %>% 
  .plotScheme(xlab = "Direction")
```


# Data Export

```{r export-colours}
write_rds(col_config, all_out$colours)
```


During this workflow, the following files were exported:

`r pander(lapply(all_out, str_extract, paste0(basename(here::here()), ".+")))`


<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
